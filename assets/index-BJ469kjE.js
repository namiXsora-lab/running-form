function UD(n,t){for(var e=0;e<t.length;e++){const s=t[e];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in n)){const i=Object.getOwnPropertyDescriptor(s,r);i&&Object.defineProperty(n,r,i.get?i:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const i of r)if(i.type==="childList")for(const a of i.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&s(a)}).observe(document,{childList:!0,subtree:!0});function e(r){const i={};return r.integrity&&(i.integrity=r.integrity),r.referrerPolicy&&(i.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?i.credentials="include":r.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(r){if(r.ep)return;r.ep=!0;const i=e(r);fetch(r.href,i)}})();var JC=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function O_(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function WD(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var t=n.default;if(typeof t=="function"){var e=function s(){var r=!1;try{r=this instanceof s}catch{}return r?Reflect.construct(t,arguments,this.constructor):t.apply(this,arguments)};e.prototype=t.prototype}else e={};return Object.defineProperty(e,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var r=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(e,s,r.get?r:{enumerable:!0,get:function(){return n[s]}})}),e}var Qy={exports:{}},ph={};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var t$;function GD(){if(t$)return ph;t$=1;var n=Symbol.for("react.transitional.element"),t=Symbol.for("react.fragment");function e(s,r,i){var a=null;if(i!==void 0&&(a=""+i),r.key!==void 0&&(a=""+r.key),"key"in r){i={};for(var o in r)o!=="key"&&(i[o]=r[o])}else i=r;return r=i.ref,{$$typeof:n,type:s,key:a,ref:r!==void 0?r:null,props:i}}return ph.Fragment=t,ph.jsx=e,ph.jsxs=e,ph}var e$;function HD(){return e$||(e$=1,Qy.exports=GD()),Qy.exports}var Ot=HD(),Zy={exports:{}},se={};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var n$;function jD(){if(n$)return se;n$=1;var n=Symbol.for("react.transitional.element"),t=Symbol.for("react.portal"),e=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),i=Symbol.for("react.consumer"),a=Symbol.for("react.context"),o=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),f=Symbol.iterator;function m(H){return H===null||typeof H!="object"?null:(H=f&&H[f]||H["@@iterator"],typeof H=="function"?H:null)}var y={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},x=Object.assign,w={};function S(H,ut,xt){this.props=H,this.context=ut,this.refs=w,this.updater=xt||y}S.prototype.isReactComponent={},S.prototype.setState=function(H,ut){if(typeof H!="object"&&typeof H!="function"&&H!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,H,ut,"setState")},S.prototype.forceUpdate=function(H){this.updater.enqueueForceUpdate(this,H,"forceUpdate")};function C(){}C.prototype=S.prototype;function k(H,ut,xt){this.props=H,this.context=ut,this.refs=w,this.updater=xt||y}var E=k.prototype=new C;E.constructor=k,x(E,S.prototype),E.isPureReactComponent=!0;var R=Array.isArray,A={H:null,A:null,T:null,S:null,V:null},L=Object.prototype.hasOwnProperty;function V(H,ut,xt,bt,_t,Kt){return xt=Kt.ref,{$$typeof:n,type:H,key:ut,ref:xt!==void 0?xt:null,props:Kt}}function B(H,ut){return V(H.type,ut,void 0,void 0,void 0,H.props)}function z(H){return typeof H=="object"&&H!==null&&H.$$typeof===n}function U(H){var ut={"=":"=0",":":"=2"};return"$"+H.replace(/[=:]/g,function(xt){return ut[xt]})}var D=/\/+/g;function Y(H,ut){return typeof H=="object"&&H!==null&&H.key!=null?U(""+H.key):ut.toString(36)}function nt(){}function dt(H){switch(H.status){case"fulfilled":return H.value;case"rejected":throw H.reason;default:switch(typeof H.status=="string"?H.then(nt,nt):(H.status="pending",H.then(function(ut){H.status==="pending"&&(H.status="fulfilled",H.value=ut)},function(ut){H.status==="pending"&&(H.status="rejected",H.reason=ut)})),H.status){case"fulfilled":return H.value;case"rejected":throw H.reason}}throw H}function at(H,ut,xt,bt,_t){var Kt=typeof H;(Kt==="undefined"||Kt==="boolean")&&(H=null);var Mt=!1;if(H===null)Mt=!0;else switch(Kt){case"bigint":case"string":case"number":Mt=!0;break;case"object":switch(H.$$typeof){case n:case t:Mt=!0;break;case d:return Mt=H._init,at(Mt(H._payload),ut,xt,bt,_t)}}if(Mt)return _t=_t(H),Mt=bt===""?"."+Y(H,0):bt,R(_t)?(xt="",Mt!=null&&(xt=Mt.replace(D,"$&/")+"/"),at(_t,ut,xt,"",function(Zs){return Zs})):_t!=null&&(z(_t)&&(_t=B(_t,xt+(_t.key==null||H&&H.key===_t.key?"":(""+_t.key).replace(D,"$&/")+"/")+Mt)),ut.push(_t)),1;Mt=0;var Un=bt===""?".":bt+":";if(R(H))for(var ve=0;ve<H.length;ve++)bt=H[ve],Kt=Un+Y(bt,ve),Mt+=at(bt,ut,xt,Kt,_t);else if(ve=m(H),typeof ve=="function")for(H=ve.call(H),ve=0;!(bt=H.next()).done;)bt=bt.value,Kt=Un+Y(bt,ve++),Mt+=at(bt,ut,xt,Kt,_t);else if(Kt==="object"){if(typeof H.then=="function")return at(dt(H),ut,xt,bt,_t);throw ut=String(H),Error("Objects are not valid as a React child (found: "+(ut==="[object Object]"?"object with keys {"+Object.keys(H).join(", ")+"}":ut)+"). If you meant to render a collection of children, use an array instead.")}return Mt}function K(H,ut,xt){if(H==null)return H;var bt=[],_t=0;return at(H,bt,"","",function(Kt){return ut.call(xt,Kt,_t++)}),bt}function ct(H){if(H._status===-1){var ut=H._result;ut=ut(),ut.then(function(xt){(H._status===0||H._status===-1)&&(H._status=1,H._result=xt)},function(xt){(H._status===0||H._status===-1)&&(H._status=2,H._result=xt)}),H._status===-1&&(H._status=0,H._result=ut)}if(H._status===1)return H._result.default;throw H._result}var yt=typeof reportError=="function"?reportError:function(H){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var ut=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof H=="object"&&H!==null&&typeof H.message=="string"?String(H.message):String(H),error:H});if(!window.dispatchEvent(ut))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",H);return}console.error(H)};function $t(){}return se.Children={map:K,forEach:function(H,ut,xt){K(H,function(){ut.apply(this,arguments)},xt)},count:function(H){var ut=0;return K(H,function(){ut++}),ut},toArray:function(H){return K(H,function(ut){return ut})||[]},only:function(H){if(!z(H))throw Error("React.Children.only expected to receive a single React element child.");return H}},se.Component=S,se.Fragment=e,se.Profiler=r,se.PureComponent=k,se.StrictMode=s,se.Suspense=u,se.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=A,se.__COMPILER_RUNTIME={__proto__:null,c:function(H){return A.H.useMemoCache(H)}},se.cache=function(H){return function(){return H.apply(null,arguments)}},se.cloneElement=function(H,ut,xt){if(H==null)throw Error("The argument must be a React element, but you passed "+H+".");var bt=x({},H.props),_t=H.key,Kt=void 0;if(ut!=null)for(Mt in ut.ref!==void 0&&(Kt=void 0),ut.key!==void 0&&(_t=""+ut.key),ut)!L.call(ut,Mt)||Mt==="key"||Mt==="__self"||Mt==="__source"||Mt==="ref"&&ut.ref===void 0||(bt[Mt]=ut[Mt]);var Mt=arguments.length-2;if(Mt===1)bt.children=xt;else if(1<Mt){for(var Un=Array(Mt),ve=0;ve<Mt;ve++)Un[ve]=arguments[ve+2];bt.children=Un}return V(H.type,_t,void 0,void 0,Kt,bt)},se.createContext=function(H){return H={$$typeof:a,_currentValue:H,_currentValue2:H,_threadCount:0,Provider:null,Consumer:null},H.Provider=H,H.Consumer={$$typeof:i,_context:H},H},se.createElement=function(H,ut,xt){var bt,_t={},Kt=null;if(ut!=null)for(bt in ut.key!==void 0&&(Kt=""+ut.key),ut)L.call(ut,bt)&&bt!=="key"&&bt!=="__self"&&bt!=="__source"&&(_t[bt]=ut[bt]);var Mt=arguments.length-2;if(Mt===1)_t.children=xt;else if(1<Mt){for(var Un=Array(Mt),ve=0;ve<Mt;ve++)Un[ve]=arguments[ve+2];_t.children=Un}if(H&&H.defaultProps)for(bt in Mt=H.defaultProps,Mt)_t[bt]===void 0&&(_t[bt]=Mt[bt]);return V(H,Kt,void 0,void 0,null,_t)},se.createRef=function(){return{current:null}},se.forwardRef=function(H){return{$$typeof:o,render:H}},se.isValidElement=z,se.lazy=function(H){return{$$typeof:d,_payload:{_status:-1,_result:H},_init:ct}},se.memo=function(H,ut){return{$$typeof:h,type:H,compare:ut===void 0?null:ut}},se.startTransition=function(H){var ut=A.T,xt={};A.T=xt;try{var bt=H(),_t=A.S;_t!==null&&_t(xt,bt),typeof bt=="object"&&bt!==null&&typeof bt.then=="function"&&bt.then($t,yt)}catch(Kt){yt(Kt)}finally{A.T=ut}},se.unstable_useCacheRefresh=function(){return A.H.useCacheRefresh()},se.use=function(H){return A.H.use(H)},se.useActionState=function(H,ut,xt){return A.H.useActionState(H,ut,xt)},se.useCallback=function(H,ut){return A.H.useCallback(H,ut)},se.useContext=function(H){return A.H.useContext(H)},se.useDebugValue=function(){},se.useDeferredValue=function(H,ut){return A.H.useDeferredValue(H,ut)},se.useEffect=function(H,ut,xt){var bt=A.H;if(typeof xt=="function")throw Error("useEffect CRUD overload is not enabled in this build of React.");return bt.useEffect(H,ut)},se.useId=function(){return A.H.useId()},se.useImperativeHandle=function(H,ut,xt){return A.H.useImperativeHandle(H,ut,xt)},se.useInsertionEffect=function(H,ut){return A.H.useInsertionEffect(H,ut)},se.useLayoutEffect=function(H,ut){return A.H.useLayoutEffect(H,ut)},se.useMemo=function(H,ut){return A.H.useMemo(H,ut)},se.useOptimistic=function(H,ut){return A.H.useOptimistic(H,ut)},se.useReducer=function(H,ut,xt){return A.H.useReducer(H,ut,xt)},se.useRef=function(H){return A.H.useRef(H)},se.useState=function(H){return A.H.useState(H)},se.useSyncExternalStore=function(H,ut,xt){return A.H.useSyncExternalStore(H,ut,xt)},se.useTransition=function(){return A.H.useTransition()},se.version="19.1.1",se}var s$;function F0(){return s$||(s$=1,Zy.exports=jD()),Zy.exports}var Ut=F0();const P_=O_(Ut);var Jy={exports:{}},mh={},tx={exports:{}},ex={};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var r$;function XD(){return r$||(r$=1,(function(n){function t(K,ct){var yt=K.length;K.push(ct);t:for(;0<yt;){var $t=yt-1>>>1,H=K[$t];if(0<r(H,ct))K[$t]=ct,K[yt]=H,yt=$t;else break t}}function e(K){return K.length===0?null:K[0]}function s(K){if(K.length===0)return null;var ct=K[0],yt=K.pop();if(yt!==ct){K[0]=yt;t:for(var $t=0,H=K.length,ut=H>>>1;$t<ut;){var xt=2*($t+1)-1,bt=K[xt],_t=xt+1,Kt=K[_t];if(0>r(bt,yt))_t<H&&0>r(Kt,bt)?(K[$t]=Kt,K[_t]=yt,$t=_t):(K[$t]=bt,K[xt]=yt,$t=xt);else if(_t<H&&0>r(Kt,yt))K[$t]=Kt,K[_t]=yt,$t=_t;else break t}}return ct}function r(K,ct){var yt=K.sortIndex-ct.sortIndex;return yt!==0?yt:K.id-ct.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var i=performance;n.unstable_now=function(){return i.now()}}else{var a=Date,o=a.now();n.unstable_now=function(){return a.now()-o}}var u=[],h=[],d=1,f=null,m=3,y=!1,x=!1,w=!1,S=!1,C=typeof setTimeout=="function"?setTimeout:null,k=typeof clearTimeout=="function"?clearTimeout:null,E=typeof setImmediate<"u"?setImmediate:null;function R(K){for(var ct=e(h);ct!==null;){if(ct.callback===null)s(h);else if(ct.startTime<=K)s(h),ct.sortIndex=ct.expirationTime,t(u,ct);else break;ct=e(h)}}function A(K){if(w=!1,R(K),!x)if(e(u)!==null)x=!0,L||(L=!0,Y());else{var ct=e(h);ct!==null&&at(A,ct.startTime-K)}}var L=!1,V=-1,B=5,z=-1;function U(){return S?!0:!(n.unstable_now()-z<B)}function D(){if(S=!1,L){var K=n.unstable_now();z=K;var ct=!0;try{t:{x=!1,w&&(w=!1,k(V),V=-1),y=!0;var yt=m;try{e:{for(R(K),f=e(u);f!==null&&!(f.expirationTime>K&&U());){var $t=f.callback;if(typeof $t=="function"){f.callback=null,m=f.priorityLevel;var H=$t(f.expirationTime<=K);if(K=n.unstable_now(),typeof H=="function"){f.callback=H,R(K),ct=!0;break e}f===e(u)&&s(u),R(K)}else s(u);f=e(u)}if(f!==null)ct=!0;else{var ut=e(h);ut!==null&&at(A,ut.startTime-K),ct=!1}}break t}finally{f=null,m=yt,y=!1}ct=void 0}}finally{ct?Y():L=!1}}}var Y;if(typeof E=="function")Y=function(){E(D)};else if(typeof MessageChannel<"u"){var nt=new MessageChannel,dt=nt.port2;nt.port1.onmessage=D,Y=function(){dt.postMessage(null)}}else Y=function(){C(D,0)};function at(K,ct){V=C(function(){K(n.unstable_now())},ct)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(K){K.callback=null},n.unstable_forceFrameRate=function(K){0>K||125<K?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):B=0<K?Math.floor(1e3/K):5},n.unstable_getCurrentPriorityLevel=function(){return m},n.unstable_next=function(K){switch(m){case 1:case 2:case 3:var ct=3;break;default:ct=m}var yt=m;m=ct;try{return K()}finally{m=yt}},n.unstable_requestPaint=function(){S=!0},n.unstable_runWithPriority=function(K,ct){switch(K){case 1:case 2:case 3:case 4:case 5:break;default:K=3}var yt=m;m=K;try{return ct()}finally{m=yt}},n.unstable_scheduleCallback=function(K,ct,yt){var $t=n.unstable_now();switch(typeof yt=="object"&&yt!==null?(yt=yt.delay,yt=typeof yt=="number"&&0<yt?$t+yt:$t):yt=$t,K){case 1:var H=-1;break;case 2:H=250;break;case 5:H=1073741823;break;case 4:H=1e4;break;default:H=5e3}return H=yt+H,K={id:d++,callback:ct,priorityLevel:K,startTime:yt,expirationTime:H,sortIndex:-1},yt>$t?(K.sortIndex=yt,t(h,K),e(u)===null&&K===e(h)&&(w?(k(V),V=-1):w=!0,at(A,yt-$t))):(K.sortIndex=H,t(u,K),x||y||(x=!0,L||(L=!0,Y()))),K},n.unstable_shouldYield=U,n.unstable_wrapCallback=function(K){var ct=m;return function(){var yt=m;m=ct;try{return K.apply(this,arguments)}finally{m=yt}}}})(ex)),ex}var i$;function qD(){return i$||(i$=1,tx.exports=XD()),tx.exports}var nx={exports:{}},os={};/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var a$;function KD(){if(a$)return os;a$=1;var n=F0();function t(u){var h="https://react.dev/errors/"+u;if(1<arguments.length){h+="?args[]="+encodeURIComponent(arguments[1]);for(var d=2;d<arguments.length;d++)h+="&args[]="+encodeURIComponent(arguments[d])}return"Minified React error #"+u+"; visit "+h+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function e(){}var s={d:{f:e,r:function(){throw Error(t(522))},D:e,C:e,L:e,m:e,X:e,S:e,M:e},p:0,findDOMNode:null},r=Symbol.for("react.portal");function i(u,h,d){var f=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:r,key:f==null?null:""+f,children:u,containerInfo:h,implementation:d}}var a=n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function o(u,h){if(u==="font")return"";if(typeof h=="string")return h==="use-credentials"?h:""}return os.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=s,os.createPortal=function(u,h){var d=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!h||h.nodeType!==1&&h.nodeType!==9&&h.nodeType!==11)throw Error(t(299));return i(u,h,null,d)},os.flushSync=function(u){var h=a.T,d=s.p;try{if(a.T=null,s.p=2,u)return u()}finally{a.T=h,s.p=d,s.d.f()}},os.preconnect=function(u,h){typeof u=="string"&&(h?(h=h.crossOrigin,h=typeof h=="string"?h==="use-credentials"?h:"":void 0):h=null,s.d.C(u,h))},os.prefetchDNS=function(u){typeof u=="string"&&s.d.D(u)},os.preinit=function(u,h){if(typeof u=="string"&&h&&typeof h.as=="string"){var d=h.as,f=o(d,h.crossOrigin),m=typeof h.integrity=="string"?h.integrity:void 0,y=typeof h.fetchPriority=="string"?h.fetchPriority:void 0;d==="style"?s.d.S(u,typeof h.precedence=="string"?h.precedence:void 0,{crossOrigin:f,integrity:m,fetchPriority:y}):d==="script"&&s.d.X(u,{crossOrigin:f,integrity:m,fetchPriority:y,nonce:typeof h.nonce=="string"?h.nonce:void 0})}},os.preinitModule=function(u,h){if(typeof u=="string")if(typeof h=="object"&&h!==null){if(h.as==null||h.as==="script"){var d=o(h.as,h.crossOrigin);s.d.M(u,{crossOrigin:d,integrity:typeof h.integrity=="string"?h.integrity:void 0,nonce:typeof h.nonce=="string"?h.nonce:void 0})}}else h==null&&s.d.M(u)},os.preload=function(u,h){if(typeof u=="string"&&typeof h=="object"&&h!==null&&typeof h.as=="string"){var d=h.as,f=o(d,h.crossOrigin);s.d.L(u,d,{crossOrigin:f,integrity:typeof h.integrity=="string"?h.integrity:void 0,nonce:typeof h.nonce=="string"?h.nonce:void 0,type:typeof h.type=="string"?h.type:void 0,fetchPriority:typeof h.fetchPriority=="string"?h.fetchPriority:void 0,referrerPolicy:typeof h.referrerPolicy=="string"?h.referrerPolicy:void 0,imageSrcSet:typeof h.imageSrcSet=="string"?h.imageSrcSet:void 0,imageSizes:typeof h.imageSizes=="string"?h.imageSizes:void 0,media:typeof h.media=="string"?h.media:void 0})}},os.preloadModule=function(u,h){if(typeof u=="string")if(h){var d=o(h.as,h.crossOrigin);s.d.m(u,{as:typeof h.as=="string"&&h.as!=="script"?h.as:void 0,crossOrigin:d,integrity:typeof h.integrity=="string"?h.integrity:void 0})}else s.d.m(u)},os.requestFormReset=function(u){s.d.r(u)},os.unstable_batchedUpdates=function(u,h){return u(h)},os.useFormState=function(u,h,d){return a.H.useFormState(u,h,d)},os.useFormStatus=function(){return a.H.useHostTransitionStatus()},os.version="19.1.1",os}var o$;function YD(){if(o$)return nx.exports;o$=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(t){console.error(t)}}return n(),nx.exports=KD(),nx.exports}/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var l$;function QD(){if(l$)return mh;l$=1;var n=qD(),t=F0(),e=YD();function s(l){var c="https://react.dev/errors/"+l;if(1<arguments.length){c+="?args[]="+encodeURIComponent(arguments[1]);for(var p=2;p<arguments.length;p++)c+="&args[]="+encodeURIComponent(arguments[p])}return"Minified React error #"+l+"; visit "+c+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function r(l){return!(!l||l.nodeType!==1&&l.nodeType!==9&&l.nodeType!==11)}function i(l){var c=l,p=l;if(l.alternate)for(;c.return;)c=c.return;else{l=c;do c=l,(c.flags&4098)!==0&&(p=c.return),l=c.return;while(l)}return c.tag===3?p:null}function a(l){if(l.tag===13){var c=l.memoizedState;if(c===null&&(l=l.alternate,l!==null&&(c=l.memoizedState)),c!==null)return c.dehydrated}return null}function o(l){if(i(l)!==l)throw Error(s(188))}function u(l){var c=l.alternate;if(!c){if(c=i(l),c===null)throw Error(s(188));return c!==l?null:l}for(var p=l,g=c;;){var b=p.return;if(b===null)break;var $=b.alternate;if($===null){if(g=b.return,g!==null){p=g;continue}break}if(b.child===$.child){for($=b.child;$;){if($===p)return o(b),l;if($===g)return o(b),c;$=$.sibling}throw Error(s(188))}if(p.return!==g.return)p=b,g=$;else{for(var I=!1,P=b.child;P;){if(P===p){I=!0,p=b,g=$;break}if(P===g){I=!0,g=b,p=$;break}P=P.sibling}if(!I){for(P=$.child;P;){if(P===p){I=!0,p=$,g=b;break}if(P===g){I=!0,g=$,p=b;break}P=P.sibling}if(!I)throw Error(s(189))}}if(p.alternate!==g)throw Error(s(190))}if(p.tag!==3)throw Error(s(188));return p.stateNode.current===p?l:c}function h(l){var c=l.tag;if(c===5||c===26||c===27||c===6)return l;for(l=l.child;l!==null;){if(c=h(l),c!==null)return c;l=l.sibling}return null}var d=Object.assign,f=Symbol.for("react.element"),m=Symbol.for("react.transitional.element"),y=Symbol.for("react.portal"),x=Symbol.for("react.fragment"),w=Symbol.for("react.strict_mode"),S=Symbol.for("react.profiler"),C=Symbol.for("react.provider"),k=Symbol.for("react.consumer"),E=Symbol.for("react.context"),R=Symbol.for("react.forward_ref"),A=Symbol.for("react.suspense"),L=Symbol.for("react.suspense_list"),V=Symbol.for("react.memo"),B=Symbol.for("react.lazy"),z=Symbol.for("react.activity"),U=Symbol.for("react.memo_cache_sentinel"),D=Symbol.iterator;function Y(l){return l===null||typeof l!="object"?null:(l=D&&l[D]||l["@@iterator"],typeof l=="function"?l:null)}var nt=Symbol.for("react.client.reference");function dt(l){if(l==null)return null;if(typeof l=="function")return l.$$typeof===nt?null:l.displayName||l.name||null;if(typeof l=="string")return l;switch(l){case x:return"Fragment";case S:return"Profiler";case w:return"StrictMode";case A:return"Suspense";case L:return"SuspenseList";case z:return"Activity"}if(typeof l=="object")switch(l.$$typeof){case y:return"Portal";case E:return(l.displayName||"Context")+".Provider";case k:return(l._context.displayName||"Context")+".Consumer";case R:var c=l.render;return l=l.displayName,l||(l=c.displayName||c.name||"",l=l!==""?"ForwardRef("+l+")":"ForwardRef"),l;case V:return c=l.displayName||null,c!==null?c:dt(l.type)||"Memo";case B:c=l._payload,l=l._init;try{return dt(l(c))}catch{}}return null}var at=Array.isArray,K=t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,ct=e.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,yt={pending:!1,data:null,method:null,action:null},$t=[],H=-1;function ut(l){return{current:l}}function xt(l){0>H||(l.current=$t[H],$t[H]=null,H--)}function bt(l,c){H++,$t[H]=l.current,l.current=c}var _t=ut(null),Kt=ut(null),Mt=ut(null),Un=ut(null);function ve(l,c){switch(bt(Mt,c),bt(Kt,l),bt(_t,null),c.nodeType){case 9:case 11:l=(l=c.documentElement)&&(l=l.namespaceURI)?_C(l):0;break;default:if(l=c.tagName,c=c.namespaceURI)c=_C(c),l=NC(c,l);else switch(l){case"svg":l=1;break;case"math":l=2;break;default:l=0}}xt(_t),bt(_t,l)}function Zs(){xt(_t),xt(Kt),xt(Mt)}function Vr(l){l.memoizedState!==null&&bt(Un,l);var c=_t.current,p=NC(c,l.type);c!==p&&(bt(Kt,l),bt(_t,p))}function yr(l){Kt.current===l&&(xt(_t),xt(Kt)),Un.current===l&&(xt(Un),uh._currentValue=yt)}var fa=Object.prototype.hasOwnProperty,je=n.unstable_scheduleCallback,on=n.unstable_cancelCallback,co=n.unstable_shouldYield,pc=n.unstable_requestPaint,gs=n.unstable_now,ho=n.unstable_getCurrentPriorityLevel,Ti=n.unstable_ImmediatePriority,fo=n.unstable_UserBlockingPriority,ki=n.unstable_NormalPriority,po=n.unstable_LowPriority,pa=n.unstable_IdlePriority,Ur=n.log,Pl=n.unstable_setDisableYieldValue,xr=null,Ze=null;function br(l){if(typeof Ur=="function"&&Pl(l),Ze&&typeof Ze.setStrictMode=="function")try{Ze.setStrictMode(xr,l)}catch{}}var An=Math.clz32?Math.clz32:St,mc=Math.log,mo=Math.LN2;function St(l){return l>>>=0,l===0?32:31-(mc(l)/mo|0)|0}var It=256,Wt=4194304;function Xe(l){var c=l&42;if(c!==0)return c;switch(l&-l){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return l&4194048;case 4194304:case 8388608:case 16777216:case 33554432:return l&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return l}}function ge(l,c,p){var g=l.pendingLanes;if(g===0)return 0;var b=0,$=l.suspendedLanes,I=l.pingedLanes;l=l.warmLanes;var P=g&134217727;return P!==0?(g=P&~$,g!==0?b=Xe(g):(I&=P,I!==0?b=Xe(I):p||(p=P&~l,p!==0&&(b=Xe(p))))):(P=g&~$,P!==0?b=Xe(P):I!==0?b=Xe(I):p||(p=g&~l,p!==0&&(b=Xe(p)))),b===0?0:c!==0&&c!==b&&(c&$)===0&&($=b&-b,p=c&-c,$>=p||$===32&&(p&4194048)!==0)?c:b}function We(l,c){return(l.pendingLanes&~(l.suspendedLanes&~l.pingedLanes)&c)===0}function we(l,c){switch(l){case 1:case 2:case 4:case 8:case 64:return c+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return c+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function nn(){var l=It;return It<<=1,(It&4194048)===0&&(It=256),l}function Wn(){var l=Wt;return Wt<<=1,(Wt&62914560)===0&&(Wt=4194304),l}function Wr(l){for(var c=[],p=0;31>p;p++)c.push(l);return c}function Dn(l,c){l.pendingLanes|=c,c!==268435456&&(l.suspendedLanes=0,l.pingedLanes=0,l.warmLanes=0)}function Se(l,c,p,g,b,$){var I=l.pendingLanes;l.pendingLanes=p,l.suspendedLanes=0,l.pingedLanes=0,l.warmLanes=0,l.expiredLanes&=p,l.entangledLanes&=p,l.errorRecoveryDisabledLanes&=p,l.shellSuspendCounter=0;var P=l.entanglements,X=l.expirationTimes,rt=l.hiddenUpdates;for(p=I&~p;0<p;){var pt=31-An(p),gt=1<<pt;P[pt]=0,X[pt]=-1;var it=rt[pt];if(it!==null)for(rt[pt]=null,pt=0;pt<it.length;pt++){var lt=it[pt];lt!==null&&(lt.lane&=-536870913)}p&=~gt}g!==0&&ke(l,g,0),$!==0&&b===0&&l.tag!==0&&(l.suspendedLanes|=$&~(I&~c))}function ke(l,c,p){l.pendingLanes|=c,l.suspendedLanes&=~c;var g=31-An(c);l.entangledLanes|=c,l.entanglements[g]=l.entanglements[g]|1073741824|p&4194090}function Gn(l,c){var p=l.entangledLanes|=c;for(l=l.entanglements;p;){var g=31-An(p),b=1<<g;b&c|l[g]&c&&(l[g]|=c),p&=~b}}function Is(l){switch(l){case 2:l=1;break;case 8:l=4;break;case 32:l=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:l=128;break;case 268435456:l=134217728;break;default:l=0}return l}function ys(l){return l&=-l,2<l?8<l?(l&134217727)!==0?32:268435456:8:2}function ss(){var l=ct.p;return l!==0?l:(l=window.event,l===void 0?32:XC(l.type))}function te(l,c){var p=ct.p;try{return ct.p=l,c()}finally{ct.p=p}}var Hn=Math.random().toString(36).slice(2),_e="__reactFiber$"+Hn,Je="__reactProps$"+Hn,wn="__reactContainer$"+Hn,Js="__reactEvents$"+Hn,Fl="__reactListeners$"+Hn,tn="__reactHandles$"+Hn,xs="__reactResources$"+Hn,Gr="__reactMarker$"+Hn;function ii(l){delete l[_e],delete l[Je],delete l[Js],delete l[Fl],delete l[tn]}function rs(l){var c=l[_e];if(c)return c;for(var p=l.parentNode;p;){if(c=p[wn]||p[_e]){if(p=c.alternate,c.child!==null||p!==null&&p.child!==null)for(l=AC(l);l!==null;){if(p=l[_e])return p;l=AC(l)}return c}l=p,p=l.parentNode}return null}function bs(l){if(l=l[_e]||l[wn]){var c=l.tag;if(c===5||c===6||c===13||c===26||c===27||c===3)return l}return null}function vs(l){var c=l.tag;if(c===5||c===26||c===27||c===6)return l.stateNode;throw Error(s(33))}function ws(l){var c=l[xs];return c||(c=l[xs]={hoistableStyles:new Map,hoistableScripts:new Map}),c}function sn(l){l[Gr]=!0}var _i=new Set,As={};function jn(l,c){Sn(l,c),Sn(l+"Capture",c)}function Sn(l,c){for(As[l]=c,l=0;l<c.length;l++)_i.add(c[l])}var Ds=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),ma={},Ll={};function gc(l){return fa.call(Ll,l)?!0:fa.call(ma,l)?!1:Ds.test(l)?Ll[l]=!0:(ma[l]=!0,!1)}function go(l,c,p){if(gc(c))if(p===null)l.removeAttribute(c);else{switch(typeof p){case"undefined":case"function":case"symbol":l.removeAttribute(c);return;case"boolean":var g=c.toLowerCase().slice(0,5);if(g!=="data-"&&g!=="aria-"){l.removeAttribute(c);return}}l.setAttribute(c,""+p)}}function ga(l,c,p){if(p===null)l.removeAttribute(c);else{switch(typeof p){case"undefined":case"function":case"symbol":case"boolean":l.removeAttribute(c);return}l.setAttribute(c,""+p)}}function Cn(l,c,p,g){if(g===null)l.removeAttribute(p);else{switch(typeof g){case"undefined":case"function":case"symbol":case"boolean":l.removeAttribute(p);return}l.setAttributeNS(c,p,""+g)}}var Ml,yo;function Xn(l){if(Ml===void 0)try{throw Error()}catch(p){var c=p.stack.trim().match(/\n( *(at )?)/);Ml=c&&c[1]||"",yo=-1<p.stack.indexOf(`
    at`)?" (<anonymous>)":-1<p.stack.indexOf("@")?"@unknown:0:0":""}return`
`+Ml+l+yo}var ya=!1;function yc(l,c){if(!l||ya)return"";ya=!0;var p=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var g={DetermineComponentFrameRoot:function(){try{if(c){var gt=function(){throw Error()};if(Object.defineProperty(gt.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(gt,[])}catch(lt){var it=lt}Reflect.construct(l,[],gt)}else{try{gt.call()}catch(lt){it=lt}l.call(gt.prototype)}}else{try{throw Error()}catch(lt){it=lt}(gt=l())&&typeof gt.catch=="function"&&gt.catch(function(){})}}catch(lt){if(lt&&it&&typeof lt.stack=="string")return[lt.stack,it.stack]}return[null,null]}};g.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var b=Object.getOwnPropertyDescriptor(g.DetermineComponentFrameRoot,"name");b&&b.configurable&&Object.defineProperty(g.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var $=g.DetermineComponentFrameRoot(),I=$[0],P=$[1];if(I&&P){var X=I.split(`
`),rt=P.split(`
`);for(b=g=0;g<X.length&&!X[g].includes("DetermineComponentFrameRoot");)g++;for(;b<rt.length&&!rt[b].includes("DetermineComponentFrameRoot");)b++;if(g===X.length||b===rt.length)for(g=X.length-1,b=rt.length-1;1<=g&&0<=b&&X[g]!==rt[b];)b--;for(;1<=g&&0<=b;g--,b--)if(X[g]!==rt[b]){if(g!==1||b!==1)do if(g--,b--,0>b||X[g]!==rt[b]){var pt=`
`+X[g].replace(" at new "," at ");return l.displayName&&pt.includes("<anonymous>")&&(pt=pt.replace("<anonymous>",l.displayName)),pt}while(1<=g&&0<=b);break}}}finally{ya=!1,Error.prepareStackTrace=p}return(p=l?l.displayName||l.name:"")?Xn(p):""}function Dd(l){switch(l.tag){case 26:case 27:case 5:return Xn(l.type);case 16:return Xn("Lazy");case 13:return Xn("Suspense");case 19:return Xn("SuspenseList");case 0:case 15:return yc(l.type,!1);case 11:return yc(l.type.render,!1);case 1:return yc(l.type,!0);case 31:return Xn("Activity");default:return""}}function zl(l){try{var c="";do c+=Dd(l),l=l.return;while(l);return c}catch(p){return`
Error generating stack: `+p.message+`
`+p.stack}}function Os(l){switch(typeof l){case"bigint":case"boolean":case"number":case"string":case"undefined":return l;case"object":return l;default:return""}}function Od(l){var c=l.type;return(l=l.nodeName)&&l.toLowerCase()==="input"&&(c==="checkbox"||c==="radio")}function Pd(l){var c=Od(l)?"checked":"value",p=Object.getOwnPropertyDescriptor(l.constructor.prototype,c),g=""+l[c];if(!l.hasOwnProperty(c)&&typeof p<"u"&&typeof p.get=="function"&&typeof p.set=="function"){var b=p.get,$=p.set;return Object.defineProperty(l,c,{configurable:!0,get:function(){return b.call(this)},set:function(I){g=""+I,$.call(this,I)}}),Object.defineProperty(l,c,{enumerable:p.enumerable}),{getValue:function(){return g},setValue:function(I){g=""+I},stopTracking:function(){l._valueTracker=null,delete l[c]}}}}function xo(l){l._valueTracker||(l._valueTracker=Pd(l))}function xc(l){if(!l)return!1;var c=l._valueTracker;if(!c)return!0;var p=c.getValue(),g="";return l&&(g=Od(l)?l.checked?"true":"false":l.value),l=g,l!==p?(c.setValue(l),!0):!1}function bo(l){if(l=l||(typeof document<"u"?document:void 0),typeof l>"u")return null;try{return l.activeElement||l.body}catch{return l.body}}var is=/[\n"\\]/g;function Ss(l){return l.replace(is,function(c){return"\\"+c.charCodeAt(0).toString(16)+" "})}function Bl(l,c,p,g,b,$,I,P){l.name="",I!=null&&typeof I!="function"&&typeof I!="symbol"&&typeof I!="boolean"?l.type=I:l.removeAttribute("type"),c!=null?I==="number"?(c===0&&l.value===""||l.value!=c)&&(l.value=""+Os(c)):l.value!==""+Os(c)&&(l.value=""+Os(c)):I!=="submit"&&I!=="reset"||l.removeAttribute("value"),c!=null?Vl(l,I,Os(c)):p!=null?Vl(l,I,Os(p)):g!=null&&l.removeAttribute("value"),b==null&&$!=null&&(l.defaultChecked=!!$),b!=null&&(l.checked=b&&typeof b!="function"&&typeof b!="symbol"),P!=null&&typeof P!="function"&&typeof P!="symbol"&&typeof P!="boolean"?l.name=""+Os(P):l.removeAttribute("name")}function vo(l,c,p,g,b,$,I,P){if($!=null&&typeof $!="function"&&typeof $!="symbol"&&typeof $!="boolean"&&(l.type=$),c!=null||p!=null){if(!($!=="submit"&&$!=="reset"||c!=null))return;p=p!=null?""+Os(p):"",c=c!=null?""+Os(c):p,P||c===l.value||(l.value=c),l.defaultValue=c}g=g??b,g=typeof g!="function"&&typeof g!="symbol"&&!!g,l.checked=P?l.checked:!!g,l.defaultChecked=!!g,I!=null&&typeof I!="function"&&typeof I!="symbol"&&typeof I!="boolean"&&(l.name=I)}function Vl(l,c,p){c==="number"&&bo(l.ownerDocument)===l||l.defaultValue===""+p||(l.defaultValue=""+p)}function Ni(l,c,p,g){if(l=l.options,c){c={};for(var b=0;b<p.length;b++)c["$"+p[b]]=!0;for(p=0;p<l.length;p++)b=c.hasOwnProperty("$"+l[p].value),l[p].selected!==b&&(l[p].selected=b),b&&g&&(l[p].defaultSelected=!0)}else{for(p=""+Os(p),c=null,b=0;b<l.length;b++){if(l[b].value===p){l[b].selected=!0,g&&(l[b].defaultSelected=!0);return}c!==null||l[b].disabled||(c=l[b])}c!==null&&(c.selected=!0)}}function Fd(l,c,p){if(c!=null&&(c=""+Os(c),c!==l.value&&(l.value=c),p==null)){l.defaultValue!==c&&(l.defaultValue=c);return}l.defaultValue=p!=null?""+Os(p):""}function Ld(l,c,p,g){if(c==null){if(g!=null){if(p!=null)throw Error(s(92));if(at(g)){if(1<g.length)throw Error(s(93));g=g[0]}p=g}p==null&&(p=""),c=p}p=Os(c),l.defaultValue=p,g=l.textContent,g===p&&g!==""&&g!==null&&(l.value=g)}function Ei(l,c){if(c){var p=l.firstChild;if(p&&p===l.lastChild&&p.nodeType===3){p.nodeValue=c;return}}l.textContent=c}var Md=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function wo(l,c,p){var g=c.indexOf("--")===0;p==null||typeof p=="boolean"||p===""?g?l.setProperty(c,""):c==="float"?l.cssFloat="":l[c]="":g?l.setProperty(c,p):typeof p!="number"||p===0||Md.has(c)?c==="float"?l.cssFloat=p:l[c]=(""+p).trim():l[c]=p+"px"}function bc(l,c,p){if(c!=null&&typeof c!="object")throw Error(s(62));if(l=l.style,p!=null){for(var g in p)!p.hasOwnProperty(g)||c!=null&&c.hasOwnProperty(g)||(g.indexOf("--")===0?l.setProperty(g,""):g==="float"?l.cssFloat="":l[g]="");for(var b in c)g=c[b],c.hasOwnProperty(b)&&p[b]!==g&&wo(l,b,g)}else for(var $ in c)c.hasOwnProperty($)&&wo(l,$,c[$])}function Ul(l){if(l.indexOf("-")===-1)return!1;switch(l){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var So=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),Gm=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function Wl(l){return Gm.test(""+l)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":l}var vc=null;function wc(l){return l=l.target||l.srcElement||window,l.correspondingUseElement&&(l=l.correspondingUseElement),l.nodeType===3?l.parentNode:l}var ai=null,vr=null;function zd(l){var c=bs(l);if(c&&(l=c.stateNode)){var p=l[Je]||null;t:switch(l=c.stateNode,c.type){case"input":if(Bl(l,p.value,p.defaultValue,p.defaultValue,p.checked,p.defaultChecked,p.type,p.name),c=p.name,p.type==="radio"&&c!=null){for(p=l;p.parentNode;)p=p.parentNode;for(p=p.querySelectorAll('input[name="'+Ss(""+c)+'"][type="radio"]'),c=0;c<p.length;c++){var g=p[c];if(g!==l&&g.form===l.form){var b=g[Je]||null;if(!b)throw Error(s(90));Bl(g,b.value,b.defaultValue,b.defaultValue,b.checked,b.defaultChecked,b.type,b.name)}}for(c=0;c<p.length;c++)g=p[c],g.form===l.form&&xc(g)}break t;case"textarea":Fd(l,p.value,p.defaultValue);break t;case"select":c=p.value,c!=null&&Ni(l,!!p.multiple,c,!1)}}}var Sc=!1;function Bd(l,c,p){if(Sc)return l(c,p);Sc=!0;try{var g=l(c);return g}finally{if(Sc=!1,(ai!==null||vr!==null)&&(Ef(),ai&&(c=ai,l=vr,vr=ai=null,zd(c),l)))for(c=0;c<l.length;c++)zd(l[c])}}function Co(l,c){var p=l.stateNode;if(p===null)return null;var g=p[Je]||null;if(g===null)return null;p=g[c];t:switch(c){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(g=!g.disabled)||(l=l.type,g=!(l==="button"||l==="input"||l==="select"||l==="textarea")),l=!g;break t;default:l=!1}if(l)return null;if(p&&typeof p!="function")throw Error(s(231,c,typeof p));return p}var tr=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Gl=!1;if(tr)try{var xa={};Object.defineProperty(xa,"passive",{get:function(){Gl=!0}}),window.addEventListener("test",xa,xa),window.removeEventListener("test",xa,xa)}catch{Gl=!1}var Ps=null,Cs=null,Hl=null;function Vd(){if(Hl)return Hl;var l,c=Cs,p=c.length,g,b="value"in Ps?Ps.value:Ps.textContent,$=b.length;for(l=0;l<p&&c[l]===b[l];l++);var I=p-l;for(g=1;g<=I&&c[p-g]===b[$-g];g++);return Hl=b.slice(l,1<g?1-g:void 0)}function $o(l){var c=l.keyCode;return"charCode"in l?(l=l.charCode,l===0&&c===13&&(l=13)):l=c,l===10&&(l=13),32<=l||l===13?l:0}function To(){return!0}function jl(){return!1}function On(l){function c(p,g,b,$,I){this._reactName=p,this._targetInst=b,this.type=g,this.nativeEvent=$,this.target=I,this.currentTarget=null;for(var P in l)l.hasOwnProperty(P)&&(p=l[P],this[P]=p?p($):$[P]);return this.isDefaultPrevented=($.defaultPrevented!=null?$.defaultPrevented:$.returnValue===!1)?To:jl,this.isPropagationStopped=jl,this}return d(c.prototype,{preventDefault:function(){this.defaultPrevented=!0;var p=this.nativeEvent;p&&(p.preventDefault?p.preventDefault():typeof p.returnValue!="unknown"&&(p.returnValue=!1),this.isDefaultPrevented=To)},stopPropagation:function(){var p=this.nativeEvent;p&&(p.stopPropagation?p.stopPropagation():typeof p.cancelBubble!="unknown"&&(p.cancelBubble=!0),this.isPropagationStopped=To)},persist:function(){},isPersistent:To}),c}var Fs={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(l){return l.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},ko=On(Fs),Ri=d({},Fs,{view:0,detail:0}),Hm=On(Ri),Cc,Ii,ba,_o=d({},Ri,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:ql,button:0,buttons:0,relatedTarget:function(l){return l.relatedTarget===void 0?l.fromElement===l.srcElement?l.toElement:l.fromElement:l.relatedTarget},movementX:function(l){return"movementX"in l?l.movementX:(l!==ba&&(ba&&l.type==="mousemove"?(Cc=l.screenX-ba.screenX,Ii=l.screenY-ba.screenY):Ii=Cc=0,ba=l),Cc)},movementY:function(l){return"movementY"in l?l.movementY:Ii}}),Ud=On(_o),jm=d({},_o,{dataTransfer:0}),Xl=On(jm),Wd=d({},Ri,{relatedTarget:0}),$c=On(Wd),Gd=d({},Fs,{animationName:0,elapsedTime:0,pseudoElement:0}),Xm=On(Gd),qm=d({},Fs,{clipboardData:function(l){return"clipboardData"in l?l.clipboardData:window.clipboardData}}),Tc=On(qm),kc=d({},Fs,{data:0}),_c=On(kc),Km={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Ym={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Qm={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Zm(l){var c=this.nativeEvent;return c.getModifierState?c.getModifierState(l):(l=Qm[l])?!!c[l]:!1}function ql(){return Zm}var Jm=d({},Ri,{key:function(l){if(l.key){var c=Km[l.key]||l.key;if(c!=="Unidentified")return c}return l.type==="keypress"?(l=$o(l),l===13?"Enter":String.fromCharCode(l)):l.type==="keydown"||l.type==="keyup"?Ym[l.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:ql,charCode:function(l){return l.type==="keypress"?$o(l):0},keyCode:function(l){return l.type==="keydown"||l.type==="keyup"?l.keyCode:0},which:function(l){return l.type==="keypress"?$o(l):l.type==="keydown"||l.type==="keyup"?l.keyCode:0}}),tg=On(Jm),Nc=d({},_o,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Hd=On(Nc),eg=d({},Ri,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:ql}),ng=On(eg),Kl=d({},Fs,{propertyName:0,elapsedTime:0,pseudoElement:0}),sg=On(Kl),rg=d({},_o,{deltaX:function(l){return"deltaX"in l?l.deltaX:"wheelDeltaX"in l?-l.wheelDeltaX:0},deltaY:function(l){return"deltaY"in l?l.deltaY:"wheelDeltaY"in l?-l.wheelDeltaY:"wheelDelta"in l?-l.wheelDelta:0},deltaZ:0,deltaMode:0}),ig=On(rg),jd=d({},Fs,{newState:0,oldState:0}),Xd=On(jd),v=[9,13,27,32],T=tr&&"CompositionEvent"in window,N=null;tr&&"documentMode"in document&&(N=document.documentMode);var O=tr&&"TextEvent"in window&&!N,W=tr&&(!T||N&&8<N&&11>=N),j=" ",G=!1;function Z(l,c){switch(l){case"keyup":return v.indexOf(c.keyCode)!==-1;case"keydown":return c.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function ot(l){return l=l.detail,typeof l=="object"&&"data"in l?l.data:null}var vt=!1;function Nt(l,c){switch(l){case"compositionend":return ot(c);case"keypress":return c.which!==32?null:(G=!0,j);case"textInput":return l=c.data,l===j&&G?null:l;default:return null}}function jt(l,c){if(vt)return l==="compositionend"||!T&&Z(l,c)?(l=Vd(),Hl=Cs=Ps=null,vt=!1,l):null;switch(l){case"paste":return null;case"keypress":if(!(c.ctrlKey||c.altKey||c.metaKey)||c.ctrlKey&&c.altKey){if(c.char&&1<c.char.length)return c.char;if(c.which)return String.fromCharCode(c.which)}return null;case"compositionend":return W&&c.locale!=="ko"?null:c.data;default:return null}}var Bt={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Dt(l){var c=l&&l.nodeName&&l.nodeName.toLowerCase();return c==="input"?!!Bt[l.type]:c==="textarea"}function Gt(l,c,p,g){ai?vr?vr.push(g):vr=[g]:ai=g,c=Pf(c,"onChange"),0<c.length&&(p=new ko("onChange","change",null,p,g),l.push({event:p,listeners:c}))}var Zt=null,Ce=null;function Le(l){SC(l,0)}function dn(l){var c=vs(l);if(xc(c))return l}function $s(l,c){if(l==="change")return c}var qn=!1;if(tr){var he;if(tr){var gn="oninput"in document;if(!gn){var Hr=document.createElement("div");Hr.setAttribute("oninput","return;"),gn=typeof Hr.oninput=="function"}he=gn}else he=!1;qn=he&&(!document.documentMode||9<document.documentMode)}function qd(){Zt&&(Zt.detachEvent("onpropertychange",Kd),Ce=Zt=null)}function Kd(l){if(l.propertyName==="value"&&dn(Ce)){var c=[];Gt(c,Ce,l,wc(l)),Bd(Le,c)}}function ag(l,c,p){l==="focusin"?(qd(),Zt=c,Ce=p,Zt.attachEvent("onpropertychange",Kd)):l==="focusout"&&qd()}function og(l){if(l==="selectionchange"||l==="keyup"||l==="keydown")return dn(Ce)}function lg(l,c){if(l==="click")return dn(c)}function Yl(l,c){if(l==="input"||l==="change")return dn(c)}function SA(l,c){return l===c&&(l!==0||1/l===1/c)||l!==l&&c!==c}var er=typeof Object.is=="function"?Object.is:SA;function Ec(l,c){if(er(l,c))return!0;if(typeof l!="object"||l===null||typeof c!="object"||c===null)return!1;var p=Object.keys(l),g=Object.keys(c);if(p.length!==g.length)return!1;for(g=0;g<p.length;g++){var b=p[g];if(!fa.call(c,b)||!er(l[b],c[b]))return!1}return!0}function qw(l){for(;l&&l.firstChild;)l=l.firstChild;return l}function Kw(l,c){var p=qw(l);l=0;for(var g;p;){if(p.nodeType===3){if(g=l+p.textContent.length,l<=c&&g>=c)return{node:p,offset:c-l};l=g}t:{for(;p;){if(p.nextSibling){p=p.nextSibling;break t}p=p.parentNode}p=void 0}p=qw(p)}}function Yw(l,c){return l&&c?l===c?!0:l&&l.nodeType===3?!1:c&&c.nodeType===3?Yw(l,c.parentNode):"contains"in l?l.contains(c):l.compareDocumentPosition?!!(l.compareDocumentPosition(c)&16):!1:!1}function Qw(l){l=l!=null&&l.ownerDocument!=null&&l.ownerDocument.defaultView!=null?l.ownerDocument.defaultView:window;for(var c=bo(l.document);c instanceof l.HTMLIFrameElement;){try{var p=typeof c.contentWindow.location.href=="string"}catch{p=!1}if(p)l=c.contentWindow;else break;c=bo(l.document)}return c}function ug(l){var c=l&&l.nodeName&&l.nodeName.toLowerCase();return c&&(c==="input"&&(l.type==="text"||l.type==="search"||l.type==="tel"||l.type==="url"||l.type==="password")||c==="textarea"||l.contentEditable==="true")}var CA=tr&&"documentMode"in document&&11>=document.documentMode,Ql=null,cg=null,Rc=null,hg=!1;function Zw(l,c,p){var g=p.window===p?p.document:p.nodeType===9?p:p.ownerDocument;hg||Ql==null||Ql!==bo(g)||(g=Ql,"selectionStart"in g&&ug(g)?g={start:g.selectionStart,end:g.selectionEnd}:(g=(g.ownerDocument&&g.ownerDocument.defaultView||window).getSelection(),g={anchorNode:g.anchorNode,anchorOffset:g.anchorOffset,focusNode:g.focusNode,focusOffset:g.focusOffset}),Rc&&Ec(Rc,g)||(Rc=g,g=Pf(cg,"onSelect"),0<g.length&&(c=new ko("onSelect","select",null,c,p),l.push({event:c,listeners:g}),c.target=Ql)))}function No(l,c){var p={};return p[l.toLowerCase()]=c.toLowerCase(),p["Webkit"+l]="webkit"+c,p["Moz"+l]="moz"+c,p}var Zl={animationend:No("Animation","AnimationEnd"),animationiteration:No("Animation","AnimationIteration"),animationstart:No("Animation","AnimationStart"),transitionrun:No("Transition","TransitionRun"),transitionstart:No("Transition","TransitionStart"),transitioncancel:No("Transition","TransitionCancel"),transitionend:No("Transition","TransitionEnd")},dg={},Jw={};tr&&(Jw=document.createElement("div").style,"AnimationEvent"in window||(delete Zl.animationend.animation,delete Zl.animationiteration.animation,delete Zl.animationstart.animation),"TransitionEvent"in window||delete Zl.transitionend.transition);function Eo(l){if(dg[l])return dg[l];if(!Zl[l])return l;var c=Zl[l],p;for(p in c)if(c.hasOwnProperty(p)&&p in Jw)return dg[l]=c[p];return l}var t2=Eo("animationend"),e2=Eo("animationiteration"),n2=Eo("animationstart"),$A=Eo("transitionrun"),TA=Eo("transitionstart"),kA=Eo("transitioncancel"),s2=Eo("transitionend"),r2=new Map,fg="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");fg.push("scrollEnd");function jr(l,c){r2.set(l,c),jn(c,[l])}var i2=new WeakMap;function wr(l,c){if(typeof l=="object"&&l!==null){var p=i2.get(l);return p!==void 0?p:(c={value:l,source:c,stack:zl(c)},i2.set(l,c),c)}return{value:l,source:c,stack:zl(c)}}var Sr=[],Jl=0,pg=0;function Yd(){for(var l=Jl,c=pg=Jl=0;c<l;){var p=Sr[c];Sr[c++]=null;var g=Sr[c];Sr[c++]=null;var b=Sr[c];Sr[c++]=null;var $=Sr[c];if(Sr[c++]=null,g!==null&&b!==null){var I=g.pending;I===null?b.next=b:(b.next=I.next,I.next=b),g.pending=b}$!==0&&a2(p,b,$)}}function Qd(l,c,p,g){Sr[Jl++]=l,Sr[Jl++]=c,Sr[Jl++]=p,Sr[Jl++]=g,pg|=g,l.lanes|=g,l=l.alternate,l!==null&&(l.lanes|=g)}function mg(l,c,p,g){return Qd(l,c,p,g),Zd(l)}function tu(l,c){return Qd(l,null,null,c),Zd(l)}function a2(l,c,p){l.lanes|=p;var g=l.alternate;g!==null&&(g.lanes|=p);for(var b=!1,$=l.return;$!==null;)$.childLanes|=p,g=$.alternate,g!==null&&(g.childLanes|=p),$.tag===22&&(l=$.stateNode,l===null||l._visibility&1||(b=!0)),l=$,$=$.return;return l.tag===3?($=l.stateNode,b&&c!==null&&(b=31-An(p),l=$.hiddenUpdates,g=l[b],g===null?l[b]=[c]:g.push(c),c.lane=p|536870912),$):null}function Zd(l){if(50<eh)throw eh=0,wy=null,Error(s(185));for(var c=l.return;c!==null;)l=c,c=l.return;return l.tag===3?l.stateNode:null}var eu={};function _A(l,c,p,g){this.tag=l,this.key=p,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=c,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=g,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function nr(l,c,p,g){return new _A(l,c,p,g)}function gg(l){return l=l.prototype,!(!l||!l.isReactComponent)}function Ai(l,c){var p=l.alternate;return p===null?(p=nr(l.tag,c,l.key,l.mode),p.elementType=l.elementType,p.type=l.type,p.stateNode=l.stateNode,p.alternate=l,l.alternate=p):(p.pendingProps=c,p.type=l.type,p.flags=0,p.subtreeFlags=0,p.deletions=null),p.flags=l.flags&65011712,p.childLanes=l.childLanes,p.lanes=l.lanes,p.child=l.child,p.memoizedProps=l.memoizedProps,p.memoizedState=l.memoizedState,p.updateQueue=l.updateQueue,c=l.dependencies,p.dependencies=c===null?null:{lanes:c.lanes,firstContext:c.firstContext},p.sibling=l.sibling,p.index=l.index,p.ref=l.ref,p.refCleanup=l.refCleanup,p}function o2(l,c){l.flags&=65011714;var p=l.alternate;return p===null?(l.childLanes=0,l.lanes=c,l.child=null,l.subtreeFlags=0,l.memoizedProps=null,l.memoizedState=null,l.updateQueue=null,l.dependencies=null,l.stateNode=null):(l.childLanes=p.childLanes,l.lanes=p.lanes,l.child=p.child,l.subtreeFlags=0,l.deletions=null,l.memoizedProps=p.memoizedProps,l.memoizedState=p.memoizedState,l.updateQueue=p.updateQueue,l.type=p.type,c=p.dependencies,l.dependencies=c===null?null:{lanes:c.lanes,firstContext:c.firstContext}),l}function Jd(l,c,p,g,b,$){var I=0;if(g=l,typeof l=="function")gg(l)&&(I=1);else if(typeof l=="string")I=ED(l,p,_t.current)?26:l==="html"||l==="head"||l==="body"?27:5;else t:switch(l){case z:return l=nr(31,p,c,b),l.elementType=z,l.lanes=$,l;case x:return Ro(p.children,b,$,c);case w:I=8,b|=24;break;case S:return l=nr(12,p,c,b|2),l.elementType=S,l.lanes=$,l;case A:return l=nr(13,p,c,b),l.elementType=A,l.lanes=$,l;case L:return l=nr(19,p,c,b),l.elementType=L,l.lanes=$,l;default:if(typeof l=="object"&&l!==null)switch(l.$$typeof){case C:case E:I=10;break t;case k:I=9;break t;case R:I=11;break t;case V:I=14;break t;case B:I=16,g=null;break t}I=29,p=Error(s(130,l===null?"null":typeof l,"")),g=null}return c=nr(I,p,c,b),c.elementType=l,c.type=g,c.lanes=$,c}function Ro(l,c,p,g){return l=nr(7,l,g,c),l.lanes=p,l}function yg(l,c,p){return l=nr(6,l,null,c),l.lanes=p,l}function xg(l,c,p){return c=nr(4,l.children!==null?l.children:[],l.key,c),c.lanes=p,c.stateNode={containerInfo:l.containerInfo,pendingChildren:null,implementation:l.implementation},c}var nu=[],su=0,tf=null,ef=0,Cr=[],$r=0,Io=null,Di=1,Oi="";function Ao(l,c){nu[su++]=ef,nu[su++]=tf,tf=l,ef=c}function l2(l,c,p){Cr[$r++]=Di,Cr[$r++]=Oi,Cr[$r++]=Io,Io=l;var g=Di;l=Oi;var b=32-An(g)-1;g&=~(1<<b),p+=1;var $=32-An(c)+b;if(30<$){var I=b-b%5;$=(g&(1<<I)-1).toString(32),g>>=I,b-=I,Di=1<<32-An(c)+b|p<<b|g,Oi=$+l}else Di=1<<$|p<<b|g,Oi=l}function bg(l){l.return!==null&&(Ao(l,1),l2(l,1,0))}function vg(l){for(;l===tf;)tf=nu[--su],nu[su]=null,ef=nu[--su],nu[su]=null;for(;l===Io;)Io=Cr[--$r],Cr[$r]=null,Oi=Cr[--$r],Cr[$r]=null,Di=Cr[--$r],Cr[$r]=null}var Ts=null,fn=null,$e=!1,Do=null,oi=!1,wg=Error(s(519));function Oo(l){var c=Error(s(418,""));throw Dc(wr(c,l)),wg}function u2(l){var c=l.stateNode,p=l.type,g=l.memoizedProps;switch(c[_e]=l,c[Je]=g,p){case"dialog":ce("cancel",c),ce("close",c);break;case"iframe":case"object":case"embed":ce("load",c);break;case"video":case"audio":for(p=0;p<sh.length;p++)ce(sh[p],c);break;case"source":ce("error",c);break;case"img":case"image":case"link":ce("error",c),ce("load",c);break;case"details":ce("toggle",c);break;case"input":ce("invalid",c),vo(c,g.value,g.defaultValue,g.checked,g.defaultChecked,g.type,g.name,!0),xo(c);break;case"select":ce("invalid",c);break;case"textarea":ce("invalid",c),Ld(c,g.value,g.defaultValue,g.children),xo(c)}p=g.children,typeof p!="string"&&typeof p!="number"&&typeof p!="bigint"||c.textContent===""+p||g.suppressHydrationWarning===!0||kC(c.textContent,p)?(g.popover!=null&&(ce("beforetoggle",c),ce("toggle",c)),g.onScroll!=null&&ce("scroll",c),g.onScrollEnd!=null&&ce("scrollend",c),g.onClick!=null&&(c.onclick=Ff),c=!0):c=!1,c||Oo(l)}function c2(l){for(Ts=l.return;Ts;)switch(Ts.tag){case 5:case 13:oi=!1;return;case 27:case 3:oi=!0;return;default:Ts=Ts.return}}function Ic(l){if(l!==Ts)return!1;if(!$e)return c2(l),$e=!0,!1;var c=l.tag,p;if((p=c!==3&&c!==27)&&((p=c===5)&&(p=l.type,p=!(p!=="form"&&p!=="button")||Ly(l.type,l.memoizedProps)),p=!p),p&&fn&&Oo(l),c2(l),c===13){if(l=l.memoizedState,l=l!==null?l.dehydrated:null,!l)throw Error(s(317));t:{for(l=l.nextSibling,c=0;l;){if(l.nodeType===8)if(p=l.data,p==="/$"){if(c===0){fn=qr(l.nextSibling);break t}c--}else p!=="$"&&p!=="$!"&&p!=="$?"||c++;l=l.nextSibling}fn=null}}else c===27?(c=fn,Pa(l.type)?(l=Vy,Vy=null,fn=l):fn=c):fn=Ts?qr(l.stateNode.nextSibling):null;return!0}function Ac(){fn=Ts=null,$e=!1}function h2(){var l=Do;return l!==null&&(zs===null?zs=l:zs.push.apply(zs,l),Do=null),l}function Dc(l){Do===null?Do=[l]:Do.push(l)}var Sg=ut(null),Po=null,Pi=null;function va(l,c,p){bt(Sg,c._currentValue),c._currentValue=p}function Fi(l){l._currentValue=Sg.current,xt(Sg)}function Cg(l,c,p){for(;l!==null;){var g=l.alternate;if((l.childLanes&c)!==c?(l.childLanes|=c,g!==null&&(g.childLanes|=c)):g!==null&&(g.childLanes&c)!==c&&(g.childLanes|=c),l===p)break;l=l.return}}function $g(l,c,p,g){var b=l.child;for(b!==null&&(b.return=l);b!==null;){var $=b.dependencies;if($!==null){var I=b.child;$=$.firstContext;t:for(;$!==null;){var P=$;$=b;for(var X=0;X<c.length;X++)if(P.context===c[X]){$.lanes|=p,P=$.alternate,P!==null&&(P.lanes|=p),Cg($.return,p,l),g||(I=null);break t}$=P.next}}else if(b.tag===18){if(I=b.return,I===null)throw Error(s(341));I.lanes|=p,$=I.alternate,$!==null&&($.lanes|=p),Cg(I,p,l),I=null}else I=b.child;if(I!==null)I.return=b;else for(I=b;I!==null;){if(I===l){I=null;break}if(b=I.sibling,b!==null){b.return=I.return,I=b;break}I=I.return}b=I}}function Oc(l,c,p,g){l=null;for(var b=c,$=!1;b!==null;){if(!$){if((b.flags&524288)!==0)$=!0;else if((b.flags&262144)!==0)break}if(b.tag===10){var I=b.alternate;if(I===null)throw Error(s(387));if(I=I.memoizedProps,I!==null){var P=b.type;er(b.pendingProps.value,I.value)||(l!==null?l.push(P):l=[P])}}else if(b===Un.current){if(I=b.alternate,I===null)throw Error(s(387));I.memoizedState.memoizedState!==b.memoizedState.memoizedState&&(l!==null?l.push(uh):l=[uh])}b=b.return}l!==null&&$g(c,l,p,g),c.flags|=262144}function nf(l){for(l=l.firstContext;l!==null;){if(!er(l.context._currentValue,l.memoizedValue))return!0;l=l.next}return!1}function Fo(l){Po=l,Pi=null,l=l.dependencies,l!==null&&(l.firstContext=null)}function as(l){return d2(Po,l)}function sf(l,c){return Po===null&&Fo(l),d2(l,c)}function d2(l,c){var p=c._currentValue;if(c={context:c,memoizedValue:p,next:null},Pi===null){if(l===null)throw Error(s(308));Pi=c,l.dependencies={lanes:0,firstContext:c},l.flags|=524288}else Pi=Pi.next=c;return p}var NA=typeof AbortController<"u"?AbortController:function(){var l=[],c=this.signal={aborted:!1,addEventListener:function(p,g){l.push(g)}};this.abort=function(){c.aborted=!0,l.forEach(function(p){return p()})}},EA=n.unstable_scheduleCallback,RA=n.unstable_NormalPriority,_n={$$typeof:E,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function Tg(){return{controller:new NA,data:new Map,refCount:0}}function Pc(l){l.refCount--,l.refCount===0&&EA(RA,function(){l.controller.abort()})}var Fc=null,kg=0,ru=0,iu=null;function IA(l,c){if(Fc===null){var p=Fc=[];kg=0,ru=Ny(),iu={status:"pending",value:void 0,then:function(g){p.push(g)}}}return kg++,c.then(f2,f2),c}function f2(){if(--kg===0&&Fc!==null){iu!==null&&(iu.status="fulfilled");var l=Fc;Fc=null,ru=0,iu=null;for(var c=0;c<l.length;c++)(0,l[c])()}}function AA(l,c){var p=[],g={status:"pending",value:null,reason:null,then:function(b){p.push(b)}};return l.then(function(){g.status="fulfilled",g.value=c;for(var b=0;b<p.length;b++)(0,p[b])(c)},function(b){for(g.status="rejected",g.reason=b,b=0;b<p.length;b++)(0,p[b])(void 0)}),g}var p2=K.S;K.S=function(l,c){typeof c=="object"&&c!==null&&typeof c.then=="function"&&IA(l,c),p2!==null&&p2(l,c)};var Lo=ut(null);function _g(){var l=Lo.current;return l!==null?l:qe.pooledCache}function rf(l,c){c===null?bt(Lo,Lo.current):bt(Lo,c.pool)}function m2(){var l=_g();return l===null?null:{parent:_n._currentValue,pool:l}}var Lc=Error(s(460)),g2=Error(s(474)),af=Error(s(542)),Ng={then:function(){}};function y2(l){return l=l.status,l==="fulfilled"||l==="rejected"}function of(){}function x2(l,c,p){switch(p=l[p],p===void 0?l.push(c):p!==c&&(c.then(of,of),c=p),c.status){case"fulfilled":return c.value;case"rejected":throw l=c.reason,v2(l),l;default:if(typeof c.status=="string")c.then(of,of);else{if(l=qe,l!==null&&100<l.shellSuspendCounter)throw Error(s(482));l=c,l.status="pending",l.then(function(g){if(c.status==="pending"){var b=c;b.status="fulfilled",b.value=g}},function(g){if(c.status==="pending"){var b=c;b.status="rejected",b.reason=g}})}switch(c.status){case"fulfilled":return c.value;case"rejected":throw l=c.reason,v2(l),l}throw Mc=c,Lc}}var Mc=null;function b2(){if(Mc===null)throw Error(s(459));var l=Mc;return Mc=null,l}function v2(l){if(l===Lc||l===af)throw Error(s(483))}var wa=!1;function Eg(l){l.updateQueue={baseState:l.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function Rg(l,c){l=l.updateQueue,c.updateQueue===l&&(c.updateQueue={baseState:l.baseState,firstBaseUpdate:l.firstBaseUpdate,lastBaseUpdate:l.lastBaseUpdate,shared:l.shared,callbacks:null})}function Sa(l){return{lane:l,tag:0,payload:null,callback:null,next:null}}function Ca(l,c,p){var g=l.updateQueue;if(g===null)return null;if(g=g.shared,(Ie&2)!==0){var b=g.pending;return b===null?c.next=c:(c.next=b.next,b.next=c),g.pending=c,c=Zd(l),a2(l,null,p),c}return Qd(l,g,c,p),Zd(l)}function zc(l,c,p){if(c=c.updateQueue,c!==null&&(c=c.shared,(p&4194048)!==0)){var g=c.lanes;g&=l.pendingLanes,p|=g,c.lanes=p,Gn(l,p)}}function Ig(l,c){var p=l.updateQueue,g=l.alternate;if(g!==null&&(g=g.updateQueue,p===g)){var b=null,$=null;if(p=p.firstBaseUpdate,p!==null){do{var I={lane:p.lane,tag:p.tag,payload:p.payload,callback:null,next:null};$===null?b=$=I:$=$.next=I,p=p.next}while(p!==null);$===null?b=$=c:$=$.next=c}else b=$=c;p={baseState:g.baseState,firstBaseUpdate:b,lastBaseUpdate:$,shared:g.shared,callbacks:g.callbacks},l.updateQueue=p;return}l=p.lastBaseUpdate,l===null?p.firstBaseUpdate=c:l.next=c,p.lastBaseUpdate=c}var Ag=!1;function Bc(){if(Ag){var l=iu;if(l!==null)throw l}}function Vc(l,c,p,g){Ag=!1;var b=l.updateQueue;wa=!1;var $=b.firstBaseUpdate,I=b.lastBaseUpdate,P=b.shared.pending;if(P!==null){b.shared.pending=null;var X=P,rt=X.next;X.next=null,I===null?$=rt:I.next=rt,I=X;var pt=l.alternate;pt!==null&&(pt=pt.updateQueue,P=pt.lastBaseUpdate,P!==I&&(P===null?pt.firstBaseUpdate=rt:P.next=rt,pt.lastBaseUpdate=X))}if($!==null){var gt=b.baseState;I=0,pt=rt=X=null,P=$;do{var it=P.lane&-536870913,lt=it!==P.lane;if(lt?(ye&it)===it:(g&it)===it){it!==0&&it===ru&&(Ag=!0),pt!==null&&(pt=pt.next={lane:0,tag:P.tag,payload:P.payload,callback:null,next:null});t:{var Qt=l,Ht=P;it=c;var Be=p;switch(Ht.tag){case 1:if(Qt=Ht.payload,typeof Qt=="function"){gt=Qt.call(Be,gt,it);break t}gt=Qt;break t;case 3:Qt.flags=Qt.flags&-65537|128;case 0:if(Qt=Ht.payload,it=typeof Qt=="function"?Qt.call(Be,gt,it):Qt,it==null)break t;gt=d({},gt,it);break t;case 2:wa=!0}}it=P.callback,it!==null&&(l.flags|=64,lt&&(l.flags|=8192),lt=b.callbacks,lt===null?b.callbacks=[it]:lt.push(it))}else lt={lane:it,tag:P.tag,payload:P.payload,callback:P.callback,next:null},pt===null?(rt=pt=lt,X=gt):pt=pt.next=lt,I|=it;if(P=P.next,P===null){if(P=b.shared.pending,P===null)break;lt=P,P=lt.next,lt.next=null,b.lastBaseUpdate=lt,b.shared.pending=null}}while(!0);pt===null&&(X=gt),b.baseState=X,b.firstBaseUpdate=rt,b.lastBaseUpdate=pt,$===null&&(b.shared.lanes=0),Ia|=I,l.lanes=I,l.memoizedState=gt}}function w2(l,c){if(typeof l!="function")throw Error(s(191,l));l.call(c)}function S2(l,c){var p=l.callbacks;if(p!==null)for(l.callbacks=null,l=0;l<p.length;l++)w2(p[l],c)}var au=ut(null),lf=ut(0);function C2(l,c){l=Wi,bt(lf,l),bt(au,c),Wi=l|c.baseLanes}function Dg(){bt(lf,Wi),bt(au,au.current)}function Og(){Wi=lf.current,xt(au),xt(lf)}var $a=0,oe=null,Me=null,$n=null,uf=!1,ou=!1,Mo=!1,cf=0,Uc=0,lu=null,DA=0;function yn(){throw Error(s(321))}function Pg(l,c){if(c===null)return!1;for(var p=0;p<c.length&&p<l.length;p++)if(!er(l[p],c[p]))return!1;return!0}function Fg(l,c,p,g,b,$){return $a=$,oe=c,c.memoizedState=null,c.updateQueue=null,c.lanes=0,K.H=l===null||l.memoizedState===null?aS:oS,Mo=!1,$=p(g,b),Mo=!1,ou&&($=T2(c,p,g,b)),$2(l),$}function $2(l){K.H=gf;var c=Me!==null&&Me.next!==null;if($a=0,$n=Me=oe=null,uf=!1,Uc=0,lu=null,c)throw Error(s(300));l===null||Pn||(l=l.dependencies,l!==null&&nf(l)&&(Pn=!0))}function T2(l,c,p,g){oe=l;var b=0;do{if(ou&&(lu=null),Uc=0,ou=!1,25<=b)throw Error(s(301));if(b+=1,$n=Me=null,l.updateQueue!=null){var $=l.updateQueue;$.lastEffect=null,$.events=null,$.stores=null,$.memoCache!=null&&($.memoCache.index=0)}K.H=BA,$=c(p,g)}while(ou);return $}function OA(){var l=K.H,c=l.useState()[0];return c=typeof c.then=="function"?Wc(c):c,l=l.useState()[0],(Me!==null?Me.memoizedState:null)!==l&&(oe.flags|=1024),c}function Lg(){var l=cf!==0;return cf=0,l}function Mg(l,c,p){c.updateQueue=l.updateQueue,c.flags&=-2053,l.lanes&=~p}function zg(l){if(uf){for(l=l.memoizedState;l!==null;){var c=l.queue;c!==null&&(c.pending=null),l=l.next}uf=!1}$a=0,$n=Me=oe=null,ou=!1,Uc=cf=0,lu=null}function Ls(){var l={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return $n===null?oe.memoizedState=$n=l:$n=$n.next=l,$n}function Tn(){if(Me===null){var l=oe.alternate;l=l!==null?l.memoizedState:null}else l=Me.next;var c=$n===null?oe.memoizedState:$n.next;if(c!==null)$n=c,Me=l;else{if(l===null)throw oe.alternate===null?Error(s(467)):Error(s(310));Me=l,l={memoizedState:Me.memoizedState,baseState:Me.baseState,baseQueue:Me.baseQueue,queue:Me.queue,next:null},$n===null?oe.memoizedState=$n=l:$n=$n.next=l}return $n}function Bg(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function Wc(l){var c=Uc;return Uc+=1,lu===null&&(lu=[]),l=x2(lu,l,c),c=oe,($n===null?c.memoizedState:$n.next)===null&&(c=c.alternate,K.H=c===null||c.memoizedState===null?aS:oS),l}function hf(l){if(l!==null&&typeof l=="object"){if(typeof l.then=="function")return Wc(l);if(l.$$typeof===E)return as(l)}throw Error(s(438,String(l)))}function Vg(l){var c=null,p=oe.updateQueue;if(p!==null&&(c=p.memoCache),c==null){var g=oe.alternate;g!==null&&(g=g.updateQueue,g!==null&&(g=g.memoCache,g!=null&&(c={data:g.data.map(function(b){return b.slice()}),index:0})))}if(c==null&&(c={data:[],index:0}),p===null&&(p=Bg(),oe.updateQueue=p),p.memoCache=c,p=c.data[c.index],p===void 0)for(p=c.data[c.index]=Array(l),g=0;g<l;g++)p[g]=U;return c.index++,p}function Li(l,c){return typeof c=="function"?c(l):c}function df(l){var c=Tn();return Ug(c,Me,l)}function Ug(l,c,p){var g=l.queue;if(g===null)throw Error(s(311));g.lastRenderedReducer=p;var b=l.baseQueue,$=g.pending;if($!==null){if(b!==null){var I=b.next;b.next=$.next,$.next=I}c.baseQueue=b=$,g.pending=null}if($=l.baseState,b===null)l.memoizedState=$;else{c=b.next;var P=I=null,X=null,rt=c,pt=!1;do{var gt=rt.lane&-536870913;if(gt!==rt.lane?(ye&gt)===gt:($a&gt)===gt){var it=rt.revertLane;if(it===0)X!==null&&(X=X.next={lane:0,revertLane:0,action:rt.action,hasEagerState:rt.hasEagerState,eagerState:rt.eagerState,next:null}),gt===ru&&(pt=!0);else if(($a&it)===it){rt=rt.next,it===ru&&(pt=!0);continue}else gt={lane:0,revertLane:rt.revertLane,action:rt.action,hasEagerState:rt.hasEagerState,eagerState:rt.eagerState,next:null},X===null?(P=X=gt,I=$):X=X.next=gt,oe.lanes|=it,Ia|=it;gt=rt.action,Mo&&p($,gt),$=rt.hasEagerState?rt.eagerState:p($,gt)}else it={lane:gt,revertLane:rt.revertLane,action:rt.action,hasEagerState:rt.hasEagerState,eagerState:rt.eagerState,next:null},X===null?(P=X=it,I=$):X=X.next=it,oe.lanes|=gt,Ia|=gt;rt=rt.next}while(rt!==null&&rt!==c);if(X===null?I=$:X.next=P,!er($,l.memoizedState)&&(Pn=!0,pt&&(p=iu,p!==null)))throw p;l.memoizedState=$,l.baseState=I,l.baseQueue=X,g.lastRenderedState=$}return b===null&&(g.lanes=0),[l.memoizedState,g.dispatch]}function Wg(l){var c=Tn(),p=c.queue;if(p===null)throw Error(s(311));p.lastRenderedReducer=l;var g=p.dispatch,b=p.pending,$=c.memoizedState;if(b!==null){p.pending=null;var I=b=b.next;do $=l($,I.action),I=I.next;while(I!==b);er($,c.memoizedState)||(Pn=!0),c.memoizedState=$,c.baseQueue===null&&(c.baseState=$),p.lastRenderedState=$}return[$,g]}function k2(l,c,p){var g=oe,b=Tn(),$=$e;if($){if(p===void 0)throw Error(s(407));p=p()}else p=c();var I=!er((Me||b).memoizedState,p);I&&(b.memoizedState=p,Pn=!0),b=b.queue;var P=E2.bind(null,g,b,l);if(Gc(2048,8,P,[l]),b.getSnapshot!==c||I||$n!==null&&$n.memoizedState.tag&1){if(g.flags|=2048,uu(9,ff(),N2.bind(null,g,b,p,c),null),qe===null)throw Error(s(349));$||($a&124)!==0||_2(g,c,p)}return p}function _2(l,c,p){l.flags|=16384,l={getSnapshot:c,value:p},c=oe.updateQueue,c===null?(c=Bg(),oe.updateQueue=c,c.stores=[l]):(p=c.stores,p===null?c.stores=[l]:p.push(l))}function N2(l,c,p,g){c.value=p,c.getSnapshot=g,R2(c)&&I2(l)}function E2(l,c,p){return p(function(){R2(c)&&I2(l)})}function R2(l){var c=l.getSnapshot;l=l.value;try{var p=c();return!er(l,p)}catch{return!0}}function I2(l){var c=tu(l,2);c!==null&&or(c,l,2)}function Gg(l){var c=Ls();if(typeof l=="function"){var p=l;if(l=p(),Mo){br(!0);try{p()}finally{br(!1)}}}return c.memoizedState=c.baseState=l,c.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Li,lastRenderedState:l},c}function A2(l,c,p,g){return l.baseState=p,Ug(l,Me,typeof g=="function"?g:Li)}function PA(l,c,p,g,b){if(mf(l))throw Error(s(485));if(l=c.action,l!==null){var $={payload:b,action:l,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(I){$.listeners.push(I)}};K.T!==null?p(!0):$.isTransition=!1,g($),p=c.pending,p===null?($.next=c.pending=$,D2(c,$)):($.next=p.next,c.pending=p.next=$)}}function D2(l,c){var p=c.action,g=c.payload,b=l.state;if(c.isTransition){var $=K.T,I={};K.T=I;try{var P=p(b,g),X=K.S;X!==null&&X(I,P),O2(l,c,P)}catch(rt){Hg(l,c,rt)}finally{K.T=$}}else try{$=p(b,g),O2(l,c,$)}catch(rt){Hg(l,c,rt)}}function O2(l,c,p){p!==null&&typeof p=="object"&&typeof p.then=="function"?p.then(function(g){P2(l,c,g)},function(g){return Hg(l,c,g)}):P2(l,c,p)}function P2(l,c,p){c.status="fulfilled",c.value=p,F2(c),l.state=p,c=l.pending,c!==null&&(p=c.next,p===c?l.pending=null:(p=p.next,c.next=p,D2(l,p)))}function Hg(l,c,p){var g=l.pending;if(l.pending=null,g!==null){g=g.next;do c.status="rejected",c.reason=p,F2(c),c=c.next;while(c!==g)}l.action=null}function F2(l){l=l.listeners;for(var c=0;c<l.length;c++)(0,l[c])()}function L2(l,c){return c}function M2(l,c){if($e){var p=qe.formState;if(p!==null){t:{var g=oe;if($e){if(fn){e:{for(var b=fn,$=oi;b.nodeType!==8;){if(!$){b=null;break e}if(b=qr(b.nextSibling),b===null){b=null;break e}}$=b.data,b=$==="F!"||$==="F"?b:null}if(b){fn=qr(b.nextSibling),g=b.data==="F!";break t}}Oo(g)}g=!1}g&&(c=p[0])}}return p=Ls(),p.memoizedState=p.baseState=c,g={pending:null,lanes:0,dispatch:null,lastRenderedReducer:L2,lastRenderedState:c},p.queue=g,p=sS.bind(null,oe,g),g.dispatch=p,g=Gg(!1),$=Yg.bind(null,oe,!1,g.queue),g=Ls(),b={state:c,dispatch:null,action:l,pending:null},g.queue=b,p=PA.bind(null,oe,b,$,p),b.dispatch=p,g.memoizedState=l,[c,p,!1]}function z2(l){var c=Tn();return B2(c,Me,l)}function B2(l,c,p){if(c=Ug(l,c,L2)[0],l=df(Li)[0],typeof c=="object"&&c!==null&&typeof c.then=="function")try{var g=Wc(c)}catch(I){throw I===Lc?af:I}else g=c;c=Tn();var b=c.queue,$=b.dispatch;return p!==c.memoizedState&&(oe.flags|=2048,uu(9,ff(),FA.bind(null,b,p),null)),[g,$,l]}function FA(l,c){l.action=c}function V2(l){var c=Tn(),p=Me;if(p!==null)return B2(c,p,l);Tn(),c=c.memoizedState,p=Tn();var g=p.queue.dispatch;return p.memoizedState=l,[c,g,!1]}function uu(l,c,p,g){return l={tag:l,create:p,deps:g,inst:c,next:null},c=oe.updateQueue,c===null&&(c=Bg(),oe.updateQueue=c),p=c.lastEffect,p===null?c.lastEffect=l.next=l:(g=p.next,p.next=l,l.next=g,c.lastEffect=l),l}function ff(){return{destroy:void 0,resource:void 0}}function U2(){return Tn().memoizedState}function pf(l,c,p,g){var b=Ls();g=g===void 0?null:g,oe.flags|=l,b.memoizedState=uu(1|c,ff(),p,g)}function Gc(l,c,p,g){var b=Tn();g=g===void 0?null:g;var $=b.memoizedState.inst;Me!==null&&g!==null&&Pg(g,Me.memoizedState.deps)?b.memoizedState=uu(c,$,p,g):(oe.flags|=l,b.memoizedState=uu(1|c,$,p,g))}function W2(l,c){pf(8390656,8,l,c)}function G2(l,c){Gc(2048,8,l,c)}function H2(l,c){return Gc(4,2,l,c)}function j2(l,c){return Gc(4,4,l,c)}function X2(l,c){if(typeof c=="function"){l=l();var p=c(l);return function(){typeof p=="function"?p():c(null)}}if(c!=null)return l=l(),c.current=l,function(){c.current=null}}function q2(l,c,p){p=p!=null?p.concat([l]):null,Gc(4,4,X2.bind(null,c,l),p)}function jg(){}function K2(l,c){var p=Tn();c=c===void 0?null:c;var g=p.memoizedState;return c!==null&&Pg(c,g[1])?g[0]:(p.memoizedState=[l,c],l)}function Y2(l,c){var p=Tn();c=c===void 0?null:c;var g=p.memoizedState;if(c!==null&&Pg(c,g[1]))return g[0];if(g=l(),Mo){br(!0);try{l()}finally{br(!1)}}return p.memoizedState=[g,c],g}function Xg(l,c,p){return p===void 0||($a&1073741824)!==0?l.memoizedState=c:(l.memoizedState=p,l=JS(),oe.lanes|=l,Ia|=l,p)}function Q2(l,c,p,g){return er(p,c)?p:au.current!==null?(l=Xg(l,p,g),er(l,c)||(Pn=!0),l):($a&42)===0?(Pn=!0,l.memoizedState=p):(l=JS(),oe.lanes|=l,Ia|=l,c)}function Z2(l,c,p,g,b){var $=ct.p;ct.p=$!==0&&8>$?$:8;var I=K.T,P={};K.T=P,Yg(l,!1,c,p);try{var X=b(),rt=K.S;if(rt!==null&&rt(P,X),X!==null&&typeof X=="object"&&typeof X.then=="function"){var pt=AA(X,g);Hc(l,c,pt,ar(l))}else Hc(l,c,g,ar(l))}catch(gt){Hc(l,c,{then:function(){},status:"rejected",reason:gt},ar())}finally{ct.p=$,K.T=I}}function LA(){}function qg(l,c,p,g){if(l.tag!==5)throw Error(s(476));var b=J2(l).queue;Z2(l,b,c,yt,p===null?LA:function(){return tS(l),p(g)})}function J2(l){var c=l.memoizedState;if(c!==null)return c;c={memoizedState:yt,baseState:yt,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Li,lastRenderedState:yt},next:null};var p={};return c.next={memoizedState:p,baseState:p,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Li,lastRenderedState:p},next:null},l.memoizedState=c,l=l.alternate,l!==null&&(l.memoizedState=c),c}function tS(l){var c=J2(l).next.queue;Hc(l,c,{},ar())}function Kg(){return as(uh)}function eS(){return Tn().memoizedState}function nS(){return Tn().memoizedState}function MA(l){for(var c=l.return;c!==null;){switch(c.tag){case 24:case 3:var p=ar();l=Sa(p);var g=Ca(c,l,p);g!==null&&(or(g,c,p),zc(g,c,p)),c={cache:Tg()},l.payload=c;return}c=c.return}}function zA(l,c,p){var g=ar();p={lane:g,revertLane:0,action:p,hasEagerState:!1,eagerState:null,next:null},mf(l)?rS(c,p):(p=mg(l,c,p,g),p!==null&&(or(p,l,g),iS(p,c,g)))}function sS(l,c,p){var g=ar();Hc(l,c,p,g)}function Hc(l,c,p,g){var b={lane:g,revertLane:0,action:p,hasEagerState:!1,eagerState:null,next:null};if(mf(l))rS(c,b);else{var $=l.alternate;if(l.lanes===0&&($===null||$.lanes===0)&&($=c.lastRenderedReducer,$!==null))try{var I=c.lastRenderedState,P=$(I,p);if(b.hasEagerState=!0,b.eagerState=P,er(P,I))return Qd(l,c,b,0),qe===null&&Yd(),!1}catch{}finally{}if(p=mg(l,c,b,g),p!==null)return or(p,l,g),iS(p,c,g),!0}return!1}function Yg(l,c,p,g){if(g={lane:2,revertLane:Ny(),action:g,hasEagerState:!1,eagerState:null,next:null},mf(l)){if(c)throw Error(s(479))}else c=mg(l,p,g,2),c!==null&&or(c,l,2)}function mf(l){var c=l.alternate;return l===oe||c!==null&&c===oe}function rS(l,c){ou=uf=!0;var p=l.pending;p===null?c.next=c:(c.next=p.next,p.next=c),l.pending=c}function iS(l,c,p){if((p&4194048)!==0){var g=c.lanes;g&=l.pendingLanes,p|=g,c.lanes=p,Gn(l,p)}}var gf={readContext:as,use:hf,useCallback:yn,useContext:yn,useEffect:yn,useImperativeHandle:yn,useLayoutEffect:yn,useInsertionEffect:yn,useMemo:yn,useReducer:yn,useRef:yn,useState:yn,useDebugValue:yn,useDeferredValue:yn,useTransition:yn,useSyncExternalStore:yn,useId:yn,useHostTransitionStatus:yn,useFormState:yn,useActionState:yn,useOptimistic:yn,useMemoCache:yn,useCacheRefresh:yn},aS={readContext:as,use:hf,useCallback:function(l,c){return Ls().memoizedState=[l,c===void 0?null:c],l},useContext:as,useEffect:W2,useImperativeHandle:function(l,c,p){p=p!=null?p.concat([l]):null,pf(4194308,4,X2.bind(null,c,l),p)},useLayoutEffect:function(l,c){return pf(4194308,4,l,c)},useInsertionEffect:function(l,c){pf(4,2,l,c)},useMemo:function(l,c){var p=Ls();c=c===void 0?null:c;var g=l();if(Mo){br(!0);try{l()}finally{br(!1)}}return p.memoizedState=[g,c],g},useReducer:function(l,c,p){var g=Ls();if(p!==void 0){var b=p(c);if(Mo){br(!0);try{p(c)}finally{br(!1)}}}else b=c;return g.memoizedState=g.baseState=b,l={pending:null,lanes:0,dispatch:null,lastRenderedReducer:l,lastRenderedState:b},g.queue=l,l=l.dispatch=zA.bind(null,oe,l),[g.memoizedState,l]},useRef:function(l){var c=Ls();return l={current:l},c.memoizedState=l},useState:function(l){l=Gg(l);var c=l.queue,p=sS.bind(null,oe,c);return c.dispatch=p,[l.memoizedState,p]},useDebugValue:jg,useDeferredValue:function(l,c){var p=Ls();return Xg(p,l,c)},useTransition:function(){var l=Gg(!1);return l=Z2.bind(null,oe,l.queue,!0,!1),Ls().memoizedState=l,[!1,l]},useSyncExternalStore:function(l,c,p){var g=oe,b=Ls();if($e){if(p===void 0)throw Error(s(407));p=p()}else{if(p=c(),qe===null)throw Error(s(349));(ye&124)!==0||_2(g,c,p)}b.memoizedState=p;var $={value:p,getSnapshot:c};return b.queue=$,W2(E2.bind(null,g,$,l),[l]),g.flags|=2048,uu(9,ff(),N2.bind(null,g,$,p,c),null),p},useId:function(){var l=Ls(),c=qe.identifierPrefix;if($e){var p=Oi,g=Di;p=(g&~(1<<32-An(g)-1)).toString(32)+p,c="«"+c+"R"+p,p=cf++,0<p&&(c+="H"+p.toString(32)),c+="»"}else p=DA++,c="«"+c+"r"+p.toString(32)+"»";return l.memoizedState=c},useHostTransitionStatus:Kg,useFormState:M2,useActionState:M2,useOptimistic:function(l){var c=Ls();c.memoizedState=c.baseState=l;var p={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return c.queue=p,c=Yg.bind(null,oe,!0,p),p.dispatch=c,[l,c]},useMemoCache:Vg,useCacheRefresh:function(){return Ls().memoizedState=MA.bind(null,oe)}},oS={readContext:as,use:hf,useCallback:K2,useContext:as,useEffect:G2,useImperativeHandle:q2,useInsertionEffect:H2,useLayoutEffect:j2,useMemo:Y2,useReducer:df,useRef:U2,useState:function(){return df(Li)},useDebugValue:jg,useDeferredValue:function(l,c){var p=Tn();return Q2(p,Me.memoizedState,l,c)},useTransition:function(){var l=df(Li)[0],c=Tn().memoizedState;return[typeof l=="boolean"?l:Wc(l),c]},useSyncExternalStore:k2,useId:eS,useHostTransitionStatus:Kg,useFormState:z2,useActionState:z2,useOptimistic:function(l,c){var p=Tn();return A2(p,Me,l,c)},useMemoCache:Vg,useCacheRefresh:nS},BA={readContext:as,use:hf,useCallback:K2,useContext:as,useEffect:G2,useImperativeHandle:q2,useInsertionEffect:H2,useLayoutEffect:j2,useMemo:Y2,useReducer:Wg,useRef:U2,useState:function(){return Wg(Li)},useDebugValue:jg,useDeferredValue:function(l,c){var p=Tn();return Me===null?Xg(p,l,c):Q2(p,Me.memoizedState,l,c)},useTransition:function(){var l=Wg(Li)[0],c=Tn().memoizedState;return[typeof l=="boolean"?l:Wc(l),c]},useSyncExternalStore:k2,useId:eS,useHostTransitionStatus:Kg,useFormState:V2,useActionState:V2,useOptimistic:function(l,c){var p=Tn();return Me!==null?A2(p,Me,l,c):(p.baseState=l,[l,p.queue.dispatch])},useMemoCache:Vg,useCacheRefresh:nS},cu=null,jc=0;function yf(l){var c=jc;return jc+=1,cu===null&&(cu=[]),x2(cu,l,c)}function Xc(l,c){c=c.props.ref,l.ref=c!==void 0?c:null}function xf(l,c){throw c.$$typeof===f?Error(s(525)):(l=Object.prototype.toString.call(c),Error(s(31,l==="[object Object]"?"object with keys {"+Object.keys(c).join(", ")+"}":l)))}function lS(l){var c=l._init;return c(l._payload)}function uS(l){function c(et,J){if(l){var st=et.deletions;st===null?(et.deletions=[J],et.flags|=16):st.push(J)}}function p(et,J){if(!l)return null;for(;J!==null;)c(et,J),J=J.sibling;return null}function g(et){for(var J=new Map;et!==null;)et.key!==null?J.set(et.key,et):J.set(et.index,et),et=et.sibling;return J}function b(et,J){return et=Ai(et,J),et.index=0,et.sibling=null,et}function $(et,J,st){return et.index=st,l?(st=et.alternate,st!==null?(st=st.index,st<J?(et.flags|=67108866,J):st):(et.flags|=67108866,J)):(et.flags|=1048576,J)}function I(et){return l&&et.alternate===null&&(et.flags|=67108866),et}function P(et,J,st,mt){return J===null||J.tag!==6?(J=yg(st,et.mode,mt),J.return=et,J):(J=b(J,st),J.return=et,J)}function X(et,J,st,mt){var Ft=st.type;return Ft===x?pt(et,J,st.props.children,mt,st.key):J!==null&&(J.elementType===Ft||typeof Ft=="object"&&Ft!==null&&Ft.$$typeof===B&&lS(Ft)===J.type)?(J=b(J,st.props),Xc(J,st),J.return=et,J):(J=Jd(st.type,st.key,st.props,null,et.mode,mt),Xc(J,st),J.return=et,J)}function rt(et,J,st,mt){return J===null||J.tag!==4||J.stateNode.containerInfo!==st.containerInfo||J.stateNode.implementation!==st.implementation?(J=xg(st,et.mode,mt),J.return=et,J):(J=b(J,st.children||[]),J.return=et,J)}function pt(et,J,st,mt,Ft){return J===null||J.tag!==7?(J=Ro(st,et.mode,mt,Ft),J.return=et,J):(J=b(J,st),J.return=et,J)}function gt(et,J,st){if(typeof J=="string"&&J!==""||typeof J=="number"||typeof J=="bigint")return J=yg(""+J,et.mode,st),J.return=et,J;if(typeof J=="object"&&J!==null){switch(J.$$typeof){case m:return st=Jd(J.type,J.key,J.props,null,et.mode,st),Xc(st,J),st.return=et,st;case y:return J=xg(J,et.mode,st),J.return=et,J;case B:var mt=J._init;return J=mt(J._payload),gt(et,J,st)}if(at(J)||Y(J))return J=Ro(J,et.mode,st,null),J.return=et,J;if(typeof J.then=="function")return gt(et,yf(J),st);if(J.$$typeof===E)return gt(et,sf(et,J),st);xf(et,J)}return null}function it(et,J,st,mt){var Ft=J!==null?J.key:null;if(typeof st=="string"&&st!==""||typeof st=="number"||typeof st=="bigint")return Ft!==null?null:P(et,J,""+st,mt);if(typeof st=="object"&&st!==null){switch(st.$$typeof){case m:return st.key===Ft?X(et,J,st,mt):null;case y:return st.key===Ft?rt(et,J,st,mt):null;case B:return Ft=st._init,st=Ft(st._payload),it(et,J,st,mt)}if(at(st)||Y(st))return Ft!==null?null:pt(et,J,st,mt,null);if(typeof st.then=="function")return it(et,J,yf(st),mt);if(st.$$typeof===E)return it(et,J,sf(et,st),mt);xf(et,st)}return null}function lt(et,J,st,mt,Ft){if(typeof mt=="string"&&mt!==""||typeof mt=="number"||typeof mt=="bigint")return et=et.get(st)||null,P(J,et,""+mt,Ft);if(typeof mt=="object"&&mt!==null){switch(mt.$$typeof){case m:return et=et.get(mt.key===null?st:mt.key)||null,X(J,et,mt,Ft);case y:return et=et.get(mt.key===null?st:mt.key)||null,rt(J,et,mt,Ft);case B:var le=mt._init;return mt=le(mt._payload),lt(et,J,st,mt,Ft)}if(at(mt)||Y(mt))return et=et.get(st)||null,pt(J,et,mt,Ft,null);if(typeof mt.then=="function")return lt(et,J,st,yf(mt),Ft);if(mt.$$typeof===E)return lt(et,J,st,sf(J,mt),Ft);xf(J,mt)}return null}function Qt(et,J,st,mt){for(var Ft=null,le=null,Vt=J,Xt=J=0,Ln=null;Vt!==null&&Xt<st.length;Xt++){Vt.index>Xt?(Ln=Vt,Vt=null):Ln=Vt.sibling;var be=it(et,Vt,st[Xt],mt);if(be===null){Vt===null&&(Vt=Ln);break}l&&Vt&&be.alternate===null&&c(et,Vt),J=$(be,J,Xt),le===null?Ft=be:le.sibling=be,le=be,Vt=Ln}if(Xt===st.length)return p(et,Vt),$e&&Ao(et,Xt),Ft;if(Vt===null){for(;Xt<st.length;Xt++)Vt=gt(et,st[Xt],mt),Vt!==null&&(J=$(Vt,J,Xt),le===null?Ft=Vt:le.sibling=Vt,le=Vt);return $e&&Ao(et,Xt),Ft}for(Vt=g(Vt);Xt<st.length;Xt++)Ln=lt(Vt,et,Xt,st[Xt],mt),Ln!==null&&(l&&Ln.alternate!==null&&Vt.delete(Ln.key===null?Xt:Ln.key),J=$(Ln,J,Xt),le===null?Ft=Ln:le.sibling=Ln,le=Ln);return l&&Vt.forEach(function(Ba){return c(et,Ba)}),$e&&Ao(et,Xt),Ft}function Ht(et,J,st,mt){if(st==null)throw Error(s(151));for(var Ft=null,le=null,Vt=J,Xt=J=0,Ln=null,be=st.next();Vt!==null&&!be.done;Xt++,be=st.next()){Vt.index>Xt?(Ln=Vt,Vt=null):Ln=Vt.sibling;var Ba=it(et,Vt,be.value,mt);if(Ba===null){Vt===null&&(Vt=Ln);break}l&&Vt&&Ba.alternate===null&&c(et,Vt),J=$(Ba,J,Xt),le===null?Ft=Ba:le.sibling=Ba,le=Ba,Vt=Ln}if(be.done)return p(et,Vt),$e&&Ao(et,Xt),Ft;if(Vt===null){for(;!be.done;Xt++,be=st.next())be=gt(et,be.value,mt),be!==null&&(J=$(be,J,Xt),le===null?Ft=be:le.sibling=be,le=be);return $e&&Ao(et,Xt),Ft}for(Vt=g(Vt);!be.done;Xt++,be=st.next())be=lt(Vt,et,Xt,be.value,mt),be!==null&&(l&&be.alternate!==null&&Vt.delete(be.key===null?Xt:be.key),J=$(be,J,Xt),le===null?Ft=be:le.sibling=be,le=be);return l&&Vt.forEach(function(VD){return c(et,VD)}),$e&&Ao(et,Xt),Ft}function Be(et,J,st,mt){if(typeof st=="object"&&st!==null&&st.type===x&&st.key===null&&(st=st.props.children),typeof st=="object"&&st!==null){switch(st.$$typeof){case m:t:{for(var Ft=st.key;J!==null;){if(J.key===Ft){if(Ft=st.type,Ft===x){if(J.tag===7){p(et,J.sibling),mt=b(J,st.props.children),mt.return=et,et=mt;break t}}else if(J.elementType===Ft||typeof Ft=="object"&&Ft!==null&&Ft.$$typeof===B&&lS(Ft)===J.type){p(et,J.sibling),mt=b(J,st.props),Xc(mt,st),mt.return=et,et=mt;break t}p(et,J);break}else c(et,J);J=J.sibling}st.type===x?(mt=Ro(st.props.children,et.mode,mt,st.key),mt.return=et,et=mt):(mt=Jd(st.type,st.key,st.props,null,et.mode,mt),Xc(mt,st),mt.return=et,et=mt)}return I(et);case y:t:{for(Ft=st.key;J!==null;){if(J.key===Ft)if(J.tag===4&&J.stateNode.containerInfo===st.containerInfo&&J.stateNode.implementation===st.implementation){p(et,J.sibling),mt=b(J,st.children||[]),mt.return=et,et=mt;break t}else{p(et,J);break}else c(et,J);J=J.sibling}mt=xg(st,et.mode,mt),mt.return=et,et=mt}return I(et);case B:return Ft=st._init,st=Ft(st._payload),Be(et,J,st,mt)}if(at(st))return Qt(et,J,st,mt);if(Y(st)){if(Ft=Y(st),typeof Ft!="function")throw Error(s(150));return st=Ft.call(st),Ht(et,J,st,mt)}if(typeof st.then=="function")return Be(et,J,yf(st),mt);if(st.$$typeof===E)return Be(et,J,sf(et,st),mt);xf(et,st)}return typeof st=="string"&&st!==""||typeof st=="number"||typeof st=="bigint"?(st=""+st,J!==null&&J.tag===6?(p(et,J.sibling),mt=b(J,st),mt.return=et,et=mt):(p(et,J),mt=yg(st,et.mode,mt),mt.return=et,et=mt),I(et)):p(et,J)}return function(et,J,st,mt){try{jc=0;var Ft=Be(et,J,st,mt);return cu=null,Ft}catch(Vt){if(Vt===Lc||Vt===af)throw Vt;var le=nr(29,Vt,null,et.mode);return le.lanes=mt,le.return=et,le}finally{}}}var hu=uS(!0),cS=uS(!1),Tr=ut(null),li=null;function Ta(l){var c=l.alternate;bt(Nn,Nn.current&1),bt(Tr,l),li===null&&(c===null||au.current!==null||c.memoizedState!==null)&&(li=l)}function hS(l){if(l.tag===22){if(bt(Nn,Nn.current),bt(Tr,l),li===null){var c=l.alternate;c!==null&&c.memoizedState!==null&&(li=l)}}else ka()}function ka(){bt(Nn,Nn.current),bt(Tr,Tr.current)}function Mi(l){xt(Tr),li===l&&(li=null),xt(Nn)}var Nn=ut(0);function bf(l){for(var c=l;c!==null;){if(c.tag===13){var p=c.memoizedState;if(p!==null&&(p=p.dehydrated,p===null||p.data==="$?"||By(p)))return c}else if(c.tag===19&&c.memoizedProps.revealOrder!==void 0){if((c.flags&128)!==0)return c}else if(c.child!==null){c.child.return=c,c=c.child;continue}if(c===l)break;for(;c.sibling===null;){if(c.return===null||c.return===l)return null;c=c.return}c.sibling.return=c.return,c=c.sibling}return null}function Qg(l,c,p,g){c=l.memoizedState,p=p(g,c),p=p==null?c:d({},c,p),l.memoizedState=p,l.lanes===0&&(l.updateQueue.baseState=p)}var Zg={enqueueSetState:function(l,c,p){l=l._reactInternals;var g=ar(),b=Sa(g);b.payload=c,p!=null&&(b.callback=p),c=Ca(l,b,g),c!==null&&(or(c,l,g),zc(c,l,g))},enqueueReplaceState:function(l,c,p){l=l._reactInternals;var g=ar(),b=Sa(g);b.tag=1,b.payload=c,p!=null&&(b.callback=p),c=Ca(l,b,g),c!==null&&(or(c,l,g),zc(c,l,g))},enqueueForceUpdate:function(l,c){l=l._reactInternals;var p=ar(),g=Sa(p);g.tag=2,c!=null&&(g.callback=c),c=Ca(l,g,p),c!==null&&(or(c,l,p),zc(c,l,p))}};function dS(l,c,p,g,b,$,I){return l=l.stateNode,typeof l.shouldComponentUpdate=="function"?l.shouldComponentUpdate(g,$,I):c.prototype&&c.prototype.isPureReactComponent?!Ec(p,g)||!Ec(b,$):!0}function fS(l,c,p,g){l=c.state,typeof c.componentWillReceiveProps=="function"&&c.componentWillReceiveProps(p,g),typeof c.UNSAFE_componentWillReceiveProps=="function"&&c.UNSAFE_componentWillReceiveProps(p,g),c.state!==l&&Zg.enqueueReplaceState(c,c.state,null)}function zo(l,c){var p=c;if("ref"in c){p={};for(var g in c)g!=="ref"&&(p[g]=c[g])}if(l=l.defaultProps){p===c&&(p=d({},p));for(var b in l)p[b]===void 0&&(p[b]=l[b])}return p}var vf=typeof reportError=="function"?reportError:function(l){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var c=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof l=="object"&&l!==null&&typeof l.message=="string"?String(l.message):String(l),error:l});if(!window.dispatchEvent(c))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",l);return}console.error(l)};function pS(l){vf(l)}function mS(l){console.error(l)}function gS(l){vf(l)}function wf(l,c){try{var p=l.onUncaughtError;p(c.value,{componentStack:c.stack})}catch(g){setTimeout(function(){throw g})}}function yS(l,c,p){try{var g=l.onCaughtError;g(p.value,{componentStack:p.stack,errorBoundary:c.tag===1?c.stateNode:null})}catch(b){setTimeout(function(){throw b})}}function Jg(l,c,p){return p=Sa(p),p.tag=3,p.payload={element:null},p.callback=function(){wf(l,c)},p}function xS(l){return l=Sa(l),l.tag=3,l}function bS(l,c,p,g){var b=p.type.getDerivedStateFromError;if(typeof b=="function"){var $=g.value;l.payload=function(){return b($)},l.callback=function(){yS(c,p,g)}}var I=p.stateNode;I!==null&&typeof I.componentDidCatch=="function"&&(l.callback=function(){yS(c,p,g),typeof b!="function"&&(Aa===null?Aa=new Set([this]):Aa.add(this));var P=g.stack;this.componentDidCatch(g.value,{componentStack:P!==null?P:""})})}function VA(l,c,p,g,b){if(p.flags|=32768,g!==null&&typeof g=="object"&&typeof g.then=="function"){if(c=p.alternate,c!==null&&Oc(c,p,b,!0),p=Tr.current,p!==null){switch(p.tag){case 13:return li===null?Cy():p.alternate===null&&pn===0&&(pn=3),p.flags&=-257,p.flags|=65536,p.lanes=b,g===Ng?p.flags|=16384:(c=p.updateQueue,c===null?p.updateQueue=new Set([g]):c.add(g),Ty(l,g,b)),!1;case 22:return p.flags|=65536,g===Ng?p.flags|=16384:(c=p.updateQueue,c===null?(c={transitions:null,markerInstances:null,retryQueue:new Set([g])},p.updateQueue=c):(p=c.retryQueue,p===null?c.retryQueue=new Set([g]):p.add(g)),Ty(l,g,b)),!1}throw Error(s(435,p.tag))}return Ty(l,g,b),Cy(),!1}if($e)return c=Tr.current,c!==null?((c.flags&65536)===0&&(c.flags|=256),c.flags|=65536,c.lanes=b,g!==wg&&(l=Error(s(422),{cause:g}),Dc(wr(l,p)))):(g!==wg&&(c=Error(s(423),{cause:g}),Dc(wr(c,p))),l=l.current.alternate,l.flags|=65536,b&=-b,l.lanes|=b,g=wr(g,p),b=Jg(l.stateNode,g,b),Ig(l,b),pn!==4&&(pn=2)),!1;var $=Error(s(520),{cause:g});if($=wr($,p),th===null?th=[$]:th.push($),pn!==4&&(pn=2),c===null)return!0;g=wr(g,p),p=c;do{switch(p.tag){case 3:return p.flags|=65536,l=b&-b,p.lanes|=l,l=Jg(p.stateNode,g,l),Ig(p,l),!1;case 1:if(c=p.type,$=p.stateNode,(p.flags&128)===0&&(typeof c.getDerivedStateFromError=="function"||$!==null&&typeof $.componentDidCatch=="function"&&(Aa===null||!Aa.has($))))return p.flags|=65536,b&=-b,p.lanes|=b,b=xS(b),bS(b,l,p,g),Ig(p,b),!1}p=p.return}while(p!==null);return!1}var vS=Error(s(461)),Pn=!1;function Kn(l,c,p,g){c.child=l===null?cS(c,null,p,g):hu(c,l.child,p,g)}function wS(l,c,p,g,b){p=p.render;var $=c.ref;if("ref"in g){var I={};for(var P in g)P!=="ref"&&(I[P]=g[P])}else I=g;return Fo(c),g=Fg(l,c,p,I,$,b),P=Lg(),l!==null&&!Pn?(Mg(l,c,b),zi(l,c,b)):($e&&P&&bg(c),c.flags|=1,Kn(l,c,g,b),c.child)}function SS(l,c,p,g,b){if(l===null){var $=p.type;return typeof $=="function"&&!gg($)&&$.defaultProps===void 0&&p.compare===null?(c.tag=15,c.type=$,CS(l,c,$,g,b)):(l=Jd(p.type,null,g,c,c.mode,b),l.ref=c.ref,l.return=c,c.child=l)}if($=l.child,!oy(l,b)){var I=$.memoizedProps;if(p=p.compare,p=p!==null?p:Ec,p(I,g)&&l.ref===c.ref)return zi(l,c,b)}return c.flags|=1,l=Ai($,g),l.ref=c.ref,l.return=c,c.child=l}function CS(l,c,p,g,b){if(l!==null){var $=l.memoizedProps;if(Ec($,g)&&l.ref===c.ref)if(Pn=!1,c.pendingProps=g=$,oy(l,b))(l.flags&131072)!==0&&(Pn=!0);else return c.lanes=l.lanes,zi(l,c,b)}return ty(l,c,p,g,b)}function $S(l,c,p){var g=c.pendingProps,b=g.children,$=l!==null?l.memoizedState:null;if(g.mode==="hidden"){if((c.flags&128)!==0){if(g=$!==null?$.baseLanes|p:p,l!==null){for(b=c.child=l.child,$=0;b!==null;)$=$|b.lanes|b.childLanes,b=b.sibling;c.childLanes=$&~g}else c.childLanes=0,c.child=null;return TS(l,c,g,p)}if((p&536870912)!==0)c.memoizedState={baseLanes:0,cachePool:null},l!==null&&rf(c,$!==null?$.cachePool:null),$!==null?C2(c,$):Dg(),hS(c);else return c.lanes=c.childLanes=536870912,TS(l,c,$!==null?$.baseLanes|p:p,p)}else $!==null?(rf(c,$.cachePool),C2(c,$),ka(),c.memoizedState=null):(l!==null&&rf(c,null),Dg(),ka());return Kn(l,c,b,p),c.child}function TS(l,c,p,g){var b=_g();return b=b===null?null:{parent:_n._currentValue,pool:b},c.memoizedState={baseLanes:p,cachePool:b},l!==null&&rf(c,null),Dg(),hS(c),l!==null&&Oc(l,c,g,!0),null}function Sf(l,c){var p=c.ref;if(p===null)l!==null&&l.ref!==null&&(c.flags|=4194816);else{if(typeof p!="function"&&typeof p!="object")throw Error(s(284));(l===null||l.ref!==p)&&(c.flags|=4194816)}}function ty(l,c,p,g,b){return Fo(c),p=Fg(l,c,p,g,void 0,b),g=Lg(),l!==null&&!Pn?(Mg(l,c,b),zi(l,c,b)):($e&&g&&bg(c),c.flags|=1,Kn(l,c,p,b),c.child)}function kS(l,c,p,g,b,$){return Fo(c),c.updateQueue=null,p=T2(c,g,p,b),$2(l),g=Lg(),l!==null&&!Pn?(Mg(l,c,$),zi(l,c,$)):($e&&g&&bg(c),c.flags|=1,Kn(l,c,p,$),c.child)}function _S(l,c,p,g,b){if(Fo(c),c.stateNode===null){var $=eu,I=p.contextType;typeof I=="object"&&I!==null&&($=as(I)),$=new p(g,$),c.memoizedState=$.state!==null&&$.state!==void 0?$.state:null,$.updater=Zg,c.stateNode=$,$._reactInternals=c,$=c.stateNode,$.props=g,$.state=c.memoizedState,$.refs={},Eg(c),I=p.contextType,$.context=typeof I=="object"&&I!==null?as(I):eu,$.state=c.memoizedState,I=p.getDerivedStateFromProps,typeof I=="function"&&(Qg(c,p,I,g),$.state=c.memoizedState),typeof p.getDerivedStateFromProps=="function"||typeof $.getSnapshotBeforeUpdate=="function"||typeof $.UNSAFE_componentWillMount!="function"&&typeof $.componentWillMount!="function"||(I=$.state,typeof $.componentWillMount=="function"&&$.componentWillMount(),typeof $.UNSAFE_componentWillMount=="function"&&$.UNSAFE_componentWillMount(),I!==$.state&&Zg.enqueueReplaceState($,$.state,null),Vc(c,g,$,b),Bc(),$.state=c.memoizedState),typeof $.componentDidMount=="function"&&(c.flags|=4194308),g=!0}else if(l===null){$=c.stateNode;var P=c.memoizedProps,X=zo(p,P);$.props=X;var rt=$.context,pt=p.contextType;I=eu,typeof pt=="object"&&pt!==null&&(I=as(pt));var gt=p.getDerivedStateFromProps;pt=typeof gt=="function"||typeof $.getSnapshotBeforeUpdate=="function",P=c.pendingProps!==P,pt||typeof $.UNSAFE_componentWillReceiveProps!="function"&&typeof $.componentWillReceiveProps!="function"||(P||rt!==I)&&fS(c,$,g,I),wa=!1;var it=c.memoizedState;$.state=it,Vc(c,g,$,b),Bc(),rt=c.memoizedState,P||it!==rt||wa?(typeof gt=="function"&&(Qg(c,p,gt,g),rt=c.memoizedState),(X=wa||dS(c,p,X,g,it,rt,I))?(pt||typeof $.UNSAFE_componentWillMount!="function"&&typeof $.componentWillMount!="function"||(typeof $.componentWillMount=="function"&&$.componentWillMount(),typeof $.UNSAFE_componentWillMount=="function"&&$.UNSAFE_componentWillMount()),typeof $.componentDidMount=="function"&&(c.flags|=4194308)):(typeof $.componentDidMount=="function"&&(c.flags|=4194308),c.memoizedProps=g,c.memoizedState=rt),$.props=g,$.state=rt,$.context=I,g=X):(typeof $.componentDidMount=="function"&&(c.flags|=4194308),g=!1)}else{$=c.stateNode,Rg(l,c),I=c.memoizedProps,pt=zo(p,I),$.props=pt,gt=c.pendingProps,it=$.context,rt=p.contextType,X=eu,typeof rt=="object"&&rt!==null&&(X=as(rt)),P=p.getDerivedStateFromProps,(rt=typeof P=="function"||typeof $.getSnapshotBeforeUpdate=="function")||typeof $.UNSAFE_componentWillReceiveProps!="function"&&typeof $.componentWillReceiveProps!="function"||(I!==gt||it!==X)&&fS(c,$,g,X),wa=!1,it=c.memoizedState,$.state=it,Vc(c,g,$,b),Bc();var lt=c.memoizedState;I!==gt||it!==lt||wa||l!==null&&l.dependencies!==null&&nf(l.dependencies)?(typeof P=="function"&&(Qg(c,p,P,g),lt=c.memoizedState),(pt=wa||dS(c,p,pt,g,it,lt,X)||l!==null&&l.dependencies!==null&&nf(l.dependencies))?(rt||typeof $.UNSAFE_componentWillUpdate!="function"&&typeof $.componentWillUpdate!="function"||(typeof $.componentWillUpdate=="function"&&$.componentWillUpdate(g,lt,X),typeof $.UNSAFE_componentWillUpdate=="function"&&$.UNSAFE_componentWillUpdate(g,lt,X)),typeof $.componentDidUpdate=="function"&&(c.flags|=4),typeof $.getSnapshotBeforeUpdate=="function"&&(c.flags|=1024)):(typeof $.componentDidUpdate!="function"||I===l.memoizedProps&&it===l.memoizedState||(c.flags|=4),typeof $.getSnapshotBeforeUpdate!="function"||I===l.memoizedProps&&it===l.memoizedState||(c.flags|=1024),c.memoizedProps=g,c.memoizedState=lt),$.props=g,$.state=lt,$.context=X,g=pt):(typeof $.componentDidUpdate!="function"||I===l.memoizedProps&&it===l.memoizedState||(c.flags|=4),typeof $.getSnapshotBeforeUpdate!="function"||I===l.memoizedProps&&it===l.memoizedState||(c.flags|=1024),g=!1)}return $=g,Sf(l,c),g=(c.flags&128)!==0,$||g?($=c.stateNode,p=g&&typeof p.getDerivedStateFromError!="function"?null:$.render(),c.flags|=1,l!==null&&g?(c.child=hu(c,l.child,null,b),c.child=hu(c,null,p,b)):Kn(l,c,p,b),c.memoizedState=$.state,l=c.child):l=zi(l,c,b),l}function NS(l,c,p,g){return Ac(),c.flags|=256,Kn(l,c,p,g),c.child}var ey={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function ny(l){return{baseLanes:l,cachePool:m2()}}function sy(l,c,p){return l=l!==null?l.childLanes&~p:0,c&&(l|=kr),l}function ES(l,c,p){var g=c.pendingProps,b=!1,$=(c.flags&128)!==0,I;if((I=$)||(I=l!==null&&l.memoizedState===null?!1:(Nn.current&2)!==0),I&&(b=!0,c.flags&=-129),I=(c.flags&32)!==0,c.flags&=-33,l===null){if($e){if(b?Ta(c):ka(),$e){var P=fn,X;if(X=P){t:{for(X=P,P=oi;X.nodeType!==8;){if(!P){P=null;break t}if(X=qr(X.nextSibling),X===null){P=null;break t}}P=X}P!==null?(c.memoizedState={dehydrated:P,treeContext:Io!==null?{id:Di,overflow:Oi}:null,retryLane:536870912,hydrationErrors:null},X=nr(18,null,null,0),X.stateNode=P,X.return=c,c.child=X,Ts=c,fn=null,X=!0):X=!1}X||Oo(c)}if(P=c.memoizedState,P!==null&&(P=P.dehydrated,P!==null))return By(P)?c.lanes=32:c.lanes=536870912,null;Mi(c)}return P=g.children,g=g.fallback,b?(ka(),b=c.mode,P=Cf({mode:"hidden",children:P},b),g=Ro(g,b,p,null),P.return=c,g.return=c,P.sibling=g,c.child=P,b=c.child,b.memoizedState=ny(p),b.childLanes=sy(l,I,p),c.memoizedState=ey,g):(Ta(c),ry(c,P))}if(X=l.memoizedState,X!==null&&(P=X.dehydrated,P!==null)){if($)c.flags&256?(Ta(c),c.flags&=-257,c=iy(l,c,p)):c.memoizedState!==null?(ka(),c.child=l.child,c.flags|=128,c=null):(ka(),b=g.fallback,P=c.mode,g=Cf({mode:"visible",children:g.children},P),b=Ro(b,P,p,null),b.flags|=2,g.return=c,b.return=c,g.sibling=b,c.child=g,hu(c,l.child,null,p),g=c.child,g.memoizedState=ny(p),g.childLanes=sy(l,I,p),c.memoizedState=ey,c=b);else if(Ta(c),By(P)){if(I=P.nextSibling&&P.nextSibling.dataset,I)var rt=I.dgst;I=rt,g=Error(s(419)),g.stack="",g.digest=I,Dc({value:g,source:null,stack:null}),c=iy(l,c,p)}else if(Pn||Oc(l,c,p,!1),I=(p&l.childLanes)!==0,Pn||I){if(I=qe,I!==null&&(g=p&-p,g=(g&42)!==0?1:Is(g),g=(g&(I.suspendedLanes|p))!==0?0:g,g!==0&&g!==X.retryLane))throw X.retryLane=g,tu(l,g),or(I,l,g),vS;P.data==="$?"||Cy(),c=iy(l,c,p)}else P.data==="$?"?(c.flags|=192,c.child=l.child,c=null):(l=X.treeContext,fn=qr(P.nextSibling),Ts=c,$e=!0,Do=null,oi=!1,l!==null&&(Cr[$r++]=Di,Cr[$r++]=Oi,Cr[$r++]=Io,Di=l.id,Oi=l.overflow,Io=c),c=ry(c,g.children),c.flags|=4096);return c}return b?(ka(),b=g.fallback,P=c.mode,X=l.child,rt=X.sibling,g=Ai(X,{mode:"hidden",children:g.children}),g.subtreeFlags=X.subtreeFlags&65011712,rt!==null?b=Ai(rt,b):(b=Ro(b,P,p,null),b.flags|=2),b.return=c,g.return=c,g.sibling=b,c.child=g,g=b,b=c.child,P=l.child.memoizedState,P===null?P=ny(p):(X=P.cachePool,X!==null?(rt=_n._currentValue,X=X.parent!==rt?{parent:rt,pool:rt}:X):X=m2(),P={baseLanes:P.baseLanes|p,cachePool:X}),b.memoizedState=P,b.childLanes=sy(l,I,p),c.memoizedState=ey,g):(Ta(c),p=l.child,l=p.sibling,p=Ai(p,{mode:"visible",children:g.children}),p.return=c,p.sibling=null,l!==null&&(I=c.deletions,I===null?(c.deletions=[l],c.flags|=16):I.push(l)),c.child=p,c.memoizedState=null,p)}function ry(l,c){return c=Cf({mode:"visible",children:c},l.mode),c.return=l,l.child=c}function Cf(l,c){return l=nr(22,l,null,c),l.lanes=0,l.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null},l}function iy(l,c,p){return hu(c,l.child,null,p),l=ry(c,c.pendingProps.children),l.flags|=2,c.memoizedState=null,l}function RS(l,c,p){l.lanes|=c;var g=l.alternate;g!==null&&(g.lanes|=c),Cg(l.return,c,p)}function ay(l,c,p,g,b){var $=l.memoizedState;$===null?l.memoizedState={isBackwards:c,rendering:null,renderingStartTime:0,last:g,tail:p,tailMode:b}:($.isBackwards=c,$.rendering=null,$.renderingStartTime=0,$.last=g,$.tail=p,$.tailMode=b)}function IS(l,c,p){var g=c.pendingProps,b=g.revealOrder,$=g.tail;if(Kn(l,c,g.children,p),g=Nn.current,(g&2)!==0)g=g&1|2,c.flags|=128;else{if(l!==null&&(l.flags&128)!==0)t:for(l=c.child;l!==null;){if(l.tag===13)l.memoizedState!==null&&RS(l,p,c);else if(l.tag===19)RS(l,p,c);else if(l.child!==null){l.child.return=l,l=l.child;continue}if(l===c)break t;for(;l.sibling===null;){if(l.return===null||l.return===c)break t;l=l.return}l.sibling.return=l.return,l=l.sibling}g&=1}switch(bt(Nn,g),b){case"forwards":for(p=c.child,b=null;p!==null;)l=p.alternate,l!==null&&bf(l)===null&&(b=p),p=p.sibling;p=b,p===null?(b=c.child,c.child=null):(b=p.sibling,p.sibling=null),ay(c,!1,b,p,$);break;case"backwards":for(p=null,b=c.child,c.child=null;b!==null;){if(l=b.alternate,l!==null&&bf(l)===null){c.child=b;break}l=b.sibling,b.sibling=p,p=b,b=l}ay(c,!0,p,null,$);break;case"together":ay(c,!1,null,null,void 0);break;default:c.memoizedState=null}return c.child}function zi(l,c,p){if(l!==null&&(c.dependencies=l.dependencies),Ia|=c.lanes,(p&c.childLanes)===0)if(l!==null){if(Oc(l,c,p,!1),(p&c.childLanes)===0)return null}else return null;if(l!==null&&c.child!==l.child)throw Error(s(153));if(c.child!==null){for(l=c.child,p=Ai(l,l.pendingProps),c.child=p,p.return=c;l.sibling!==null;)l=l.sibling,p=p.sibling=Ai(l,l.pendingProps),p.return=c;p.sibling=null}return c.child}function oy(l,c){return(l.lanes&c)!==0?!0:(l=l.dependencies,!!(l!==null&&nf(l)))}function UA(l,c,p){switch(c.tag){case 3:ve(c,c.stateNode.containerInfo),va(c,_n,l.memoizedState.cache),Ac();break;case 27:case 5:Vr(c);break;case 4:ve(c,c.stateNode.containerInfo);break;case 10:va(c,c.type,c.memoizedProps.value);break;case 13:var g=c.memoizedState;if(g!==null)return g.dehydrated!==null?(Ta(c),c.flags|=128,null):(p&c.child.childLanes)!==0?ES(l,c,p):(Ta(c),l=zi(l,c,p),l!==null?l.sibling:null);Ta(c);break;case 19:var b=(l.flags&128)!==0;if(g=(p&c.childLanes)!==0,g||(Oc(l,c,p,!1),g=(p&c.childLanes)!==0),b){if(g)return IS(l,c,p);c.flags|=128}if(b=c.memoizedState,b!==null&&(b.rendering=null,b.tail=null,b.lastEffect=null),bt(Nn,Nn.current),g)break;return null;case 22:case 23:return c.lanes=0,$S(l,c,p);case 24:va(c,_n,l.memoizedState.cache)}return zi(l,c,p)}function AS(l,c,p){if(l!==null)if(l.memoizedProps!==c.pendingProps)Pn=!0;else{if(!oy(l,p)&&(c.flags&128)===0)return Pn=!1,UA(l,c,p);Pn=(l.flags&131072)!==0}else Pn=!1,$e&&(c.flags&1048576)!==0&&l2(c,ef,c.index);switch(c.lanes=0,c.tag){case 16:t:{l=c.pendingProps;var g=c.elementType,b=g._init;if(g=b(g._payload),c.type=g,typeof g=="function")gg(g)?(l=zo(g,l),c.tag=1,c=_S(null,c,g,l,p)):(c.tag=0,c=ty(null,c,g,l,p));else{if(g!=null){if(b=g.$$typeof,b===R){c.tag=11,c=wS(null,c,g,l,p);break t}else if(b===V){c.tag=14,c=SS(null,c,g,l,p);break t}}throw c=dt(g)||g,Error(s(306,c,""))}}return c;case 0:return ty(l,c,c.type,c.pendingProps,p);case 1:return g=c.type,b=zo(g,c.pendingProps),_S(l,c,g,b,p);case 3:t:{if(ve(c,c.stateNode.containerInfo),l===null)throw Error(s(387));g=c.pendingProps;var $=c.memoizedState;b=$.element,Rg(l,c),Vc(c,g,null,p);var I=c.memoizedState;if(g=I.cache,va(c,_n,g),g!==$.cache&&$g(c,[_n],p,!0),Bc(),g=I.element,$.isDehydrated)if($={element:g,isDehydrated:!1,cache:I.cache},c.updateQueue.baseState=$,c.memoizedState=$,c.flags&256){c=NS(l,c,g,p);break t}else if(g!==b){b=wr(Error(s(424)),c),Dc(b),c=NS(l,c,g,p);break t}else{switch(l=c.stateNode.containerInfo,l.nodeType){case 9:l=l.body;break;default:l=l.nodeName==="HTML"?l.ownerDocument.body:l}for(fn=qr(l.firstChild),Ts=c,$e=!0,Do=null,oi=!0,p=cS(c,null,g,p),c.child=p;p;)p.flags=p.flags&-3|4096,p=p.sibling}else{if(Ac(),g===b){c=zi(l,c,p);break t}Kn(l,c,g,p)}c=c.child}return c;case 26:return Sf(l,c),l===null?(p=FC(c.type,null,c.pendingProps,null))?c.memoizedState=p:$e||(p=c.type,l=c.pendingProps,g=Lf(Mt.current).createElement(p),g[_e]=c,g[Je]=l,Qn(g,p,l),sn(g),c.stateNode=g):c.memoizedState=FC(c.type,l.memoizedProps,c.pendingProps,l.memoizedState),null;case 27:return Vr(c),l===null&&$e&&(g=c.stateNode=DC(c.type,c.pendingProps,Mt.current),Ts=c,oi=!0,b=fn,Pa(c.type)?(Vy=b,fn=qr(g.firstChild)):fn=b),Kn(l,c,c.pendingProps.children,p),Sf(l,c),l===null&&(c.flags|=4194304),c.child;case 5:return l===null&&$e&&((b=g=fn)&&(g=gD(g,c.type,c.pendingProps,oi),g!==null?(c.stateNode=g,Ts=c,fn=qr(g.firstChild),oi=!1,b=!0):b=!1),b||Oo(c)),Vr(c),b=c.type,$=c.pendingProps,I=l!==null?l.memoizedProps:null,g=$.children,Ly(b,$)?g=null:I!==null&&Ly(b,I)&&(c.flags|=32),c.memoizedState!==null&&(b=Fg(l,c,OA,null,null,p),uh._currentValue=b),Sf(l,c),Kn(l,c,g,p),c.child;case 6:return l===null&&$e&&((l=p=fn)&&(p=yD(p,c.pendingProps,oi),p!==null?(c.stateNode=p,Ts=c,fn=null,l=!0):l=!1),l||Oo(c)),null;case 13:return ES(l,c,p);case 4:return ve(c,c.stateNode.containerInfo),g=c.pendingProps,l===null?c.child=hu(c,null,g,p):Kn(l,c,g,p),c.child;case 11:return wS(l,c,c.type,c.pendingProps,p);case 7:return Kn(l,c,c.pendingProps,p),c.child;case 8:return Kn(l,c,c.pendingProps.children,p),c.child;case 12:return Kn(l,c,c.pendingProps.children,p),c.child;case 10:return g=c.pendingProps,va(c,c.type,g.value),Kn(l,c,g.children,p),c.child;case 9:return b=c.type._context,g=c.pendingProps.children,Fo(c),b=as(b),g=g(b),c.flags|=1,Kn(l,c,g,p),c.child;case 14:return SS(l,c,c.type,c.pendingProps,p);case 15:return CS(l,c,c.type,c.pendingProps,p);case 19:return IS(l,c,p);case 31:return g=c.pendingProps,p=c.mode,g={mode:g.mode,children:g.children},l===null?(p=Cf(g,p),p.ref=c.ref,c.child=p,p.return=c,c=p):(p=Ai(l.child,g),p.ref=c.ref,c.child=p,p.return=c,c=p),c;case 22:return $S(l,c,p);case 24:return Fo(c),g=as(_n),l===null?(b=_g(),b===null&&(b=qe,$=Tg(),b.pooledCache=$,$.refCount++,$!==null&&(b.pooledCacheLanes|=p),b=$),c.memoizedState={parent:g,cache:b},Eg(c),va(c,_n,b)):((l.lanes&p)!==0&&(Rg(l,c),Vc(c,null,null,p),Bc()),b=l.memoizedState,$=c.memoizedState,b.parent!==g?(b={parent:g,cache:g},c.memoizedState=b,c.lanes===0&&(c.memoizedState=c.updateQueue.baseState=b),va(c,_n,g)):(g=$.cache,va(c,_n,g),g!==b.cache&&$g(c,[_n],p,!0))),Kn(l,c,c.pendingProps.children,p),c.child;case 29:throw c.pendingProps}throw Error(s(156,c.tag))}function Bi(l){l.flags|=4}function DS(l,c){if(c.type!=="stylesheet"||(c.state.loading&4)!==0)l.flags&=-16777217;else if(l.flags|=16777216,!VC(c)){if(c=Tr.current,c!==null&&((ye&4194048)===ye?li!==null:(ye&62914560)!==ye&&(ye&536870912)===0||c!==li))throw Mc=Ng,g2;l.flags|=8192}}function $f(l,c){c!==null&&(l.flags|=4),l.flags&16384&&(c=l.tag!==22?Wn():536870912,l.lanes|=c,mu|=c)}function qc(l,c){if(!$e)switch(l.tailMode){case"hidden":c=l.tail;for(var p=null;c!==null;)c.alternate!==null&&(p=c),c=c.sibling;p===null?l.tail=null:p.sibling=null;break;case"collapsed":p=l.tail;for(var g=null;p!==null;)p.alternate!==null&&(g=p),p=p.sibling;g===null?c||l.tail===null?l.tail=null:l.tail.sibling=null:g.sibling=null}}function ln(l){var c=l.alternate!==null&&l.alternate.child===l.child,p=0,g=0;if(c)for(var b=l.child;b!==null;)p|=b.lanes|b.childLanes,g|=b.subtreeFlags&65011712,g|=b.flags&65011712,b.return=l,b=b.sibling;else for(b=l.child;b!==null;)p|=b.lanes|b.childLanes,g|=b.subtreeFlags,g|=b.flags,b.return=l,b=b.sibling;return l.subtreeFlags|=g,l.childLanes=p,c}function WA(l,c,p){var g=c.pendingProps;switch(vg(c),c.tag){case 31:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return ln(c),null;case 1:return ln(c),null;case 3:return p=c.stateNode,g=null,l!==null&&(g=l.memoizedState.cache),c.memoizedState.cache!==g&&(c.flags|=2048),Fi(_n),Zs(),p.pendingContext&&(p.context=p.pendingContext,p.pendingContext=null),(l===null||l.child===null)&&(Ic(c)?Bi(c):l===null||l.memoizedState.isDehydrated&&(c.flags&256)===0||(c.flags|=1024,h2())),ln(c),null;case 26:return p=c.memoizedState,l===null?(Bi(c),p!==null?(ln(c),DS(c,p)):(ln(c),c.flags&=-16777217)):p?p!==l.memoizedState?(Bi(c),ln(c),DS(c,p)):(ln(c),c.flags&=-16777217):(l.memoizedProps!==g&&Bi(c),ln(c),c.flags&=-16777217),null;case 27:yr(c),p=Mt.current;var b=c.type;if(l!==null&&c.stateNode!=null)l.memoizedProps!==g&&Bi(c);else{if(!g){if(c.stateNode===null)throw Error(s(166));return ln(c),null}l=_t.current,Ic(c)?u2(c):(l=DC(b,g,p),c.stateNode=l,Bi(c))}return ln(c),null;case 5:if(yr(c),p=c.type,l!==null&&c.stateNode!=null)l.memoizedProps!==g&&Bi(c);else{if(!g){if(c.stateNode===null)throw Error(s(166));return ln(c),null}if(l=_t.current,Ic(c))u2(c);else{switch(b=Lf(Mt.current),l){case 1:l=b.createElementNS("http://www.w3.org/2000/svg",p);break;case 2:l=b.createElementNS("http://www.w3.org/1998/Math/MathML",p);break;default:switch(p){case"svg":l=b.createElementNS("http://www.w3.org/2000/svg",p);break;case"math":l=b.createElementNS("http://www.w3.org/1998/Math/MathML",p);break;case"script":l=b.createElement("div"),l.innerHTML="<script><\/script>",l=l.removeChild(l.firstChild);break;case"select":l=typeof g.is=="string"?b.createElement("select",{is:g.is}):b.createElement("select"),g.multiple?l.multiple=!0:g.size&&(l.size=g.size);break;default:l=typeof g.is=="string"?b.createElement(p,{is:g.is}):b.createElement(p)}}l[_e]=c,l[Je]=g;t:for(b=c.child;b!==null;){if(b.tag===5||b.tag===6)l.appendChild(b.stateNode);else if(b.tag!==4&&b.tag!==27&&b.child!==null){b.child.return=b,b=b.child;continue}if(b===c)break t;for(;b.sibling===null;){if(b.return===null||b.return===c)break t;b=b.return}b.sibling.return=b.return,b=b.sibling}c.stateNode=l;t:switch(Qn(l,p,g),p){case"button":case"input":case"select":case"textarea":l=!!g.autoFocus;break t;case"img":l=!0;break t;default:l=!1}l&&Bi(c)}}return ln(c),c.flags&=-16777217,null;case 6:if(l&&c.stateNode!=null)l.memoizedProps!==g&&Bi(c);else{if(typeof g!="string"&&c.stateNode===null)throw Error(s(166));if(l=Mt.current,Ic(c)){if(l=c.stateNode,p=c.memoizedProps,g=null,b=Ts,b!==null)switch(b.tag){case 27:case 5:g=b.memoizedProps}l[_e]=c,l=!!(l.nodeValue===p||g!==null&&g.suppressHydrationWarning===!0||kC(l.nodeValue,p)),l||Oo(c)}else l=Lf(l).createTextNode(g),l[_e]=c,c.stateNode=l}return ln(c),null;case 13:if(g=c.memoizedState,l===null||l.memoizedState!==null&&l.memoizedState.dehydrated!==null){if(b=Ic(c),g!==null&&g.dehydrated!==null){if(l===null){if(!b)throw Error(s(318));if(b=c.memoizedState,b=b!==null?b.dehydrated:null,!b)throw Error(s(317));b[_e]=c}else Ac(),(c.flags&128)===0&&(c.memoizedState=null),c.flags|=4;ln(c),b=!1}else b=h2(),l!==null&&l.memoizedState!==null&&(l.memoizedState.hydrationErrors=b),b=!0;if(!b)return c.flags&256?(Mi(c),c):(Mi(c),null)}if(Mi(c),(c.flags&128)!==0)return c.lanes=p,c;if(p=g!==null,l=l!==null&&l.memoizedState!==null,p){g=c.child,b=null,g.alternate!==null&&g.alternate.memoizedState!==null&&g.alternate.memoizedState.cachePool!==null&&(b=g.alternate.memoizedState.cachePool.pool);var $=null;g.memoizedState!==null&&g.memoizedState.cachePool!==null&&($=g.memoizedState.cachePool.pool),$!==b&&(g.flags|=2048)}return p!==l&&p&&(c.child.flags|=8192),$f(c,c.updateQueue),ln(c),null;case 4:return Zs(),l===null&&Ay(c.stateNode.containerInfo),ln(c),null;case 10:return Fi(c.type),ln(c),null;case 19:if(xt(Nn),b=c.memoizedState,b===null)return ln(c),null;if(g=(c.flags&128)!==0,$=b.rendering,$===null)if(g)qc(b,!1);else{if(pn!==0||l!==null&&(l.flags&128)!==0)for(l=c.child;l!==null;){if($=bf(l),$!==null){for(c.flags|=128,qc(b,!1),l=$.updateQueue,c.updateQueue=l,$f(c,l),c.subtreeFlags=0,l=p,p=c.child;p!==null;)o2(p,l),p=p.sibling;return bt(Nn,Nn.current&1|2),c.child}l=l.sibling}b.tail!==null&&gs()>_f&&(c.flags|=128,g=!0,qc(b,!1),c.lanes=4194304)}else{if(!g)if(l=bf($),l!==null){if(c.flags|=128,g=!0,l=l.updateQueue,c.updateQueue=l,$f(c,l),qc(b,!0),b.tail===null&&b.tailMode==="hidden"&&!$.alternate&&!$e)return ln(c),null}else 2*gs()-b.renderingStartTime>_f&&p!==536870912&&(c.flags|=128,g=!0,qc(b,!1),c.lanes=4194304);b.isBackwards?($.sibling=c.child,c.child=$):(l=b.last,l!==null?l.sibling=$:c.child=$,b.last=$)}return b.tail!==null?(c=b.tail,b.rendering=c,b.tail=c.sibling,b.renderingStartTime=gs(),c.sibling=null,l=Nn.current,bt(Nn,g?l&1|2:l&1),c):(ln(c),null);case 22:case 23:return Mi(c),Og(),g=c.memoizedState!==null,l!==null?l.memoizedState!==null!==g&&(c.flags|=8192):g&&(c.flags|=8192),g?(p&536870912)!==0&&(c.flags&128)===0&&(ln(c),c.subtreeFlags&6&&(c.flags|=8192)):ln(c),p=c.updateQueue,p!==null&&$f(c,p.retryQueue),p=null,l!==null&&l.memoizedState!==null&&l.memoizedState.cachePool!==null&&(p=l.memoizedState.cachePool.pool),g=null,c.memoizedState!==null&&c.memoizedState.cachePool!==null&&(g=c.memoizedState.cachePool.pool),g!==p&&(c.flags|=2048),l!==null&&xt(Lo),null;case 24:return p=null,l!==null&&(p=l.memoizedState.cache),c.memoizedState.cache!==p&&(c.flags|=2048),Fi(_n),ln(c),null;case 25:return null;case 30:return null}throw Error(s(156,c.tag))}function GA(l,c){switch(vg(c),c.tag){case 1:return l=c.flags,l&65536?(c.flags=l&-65537|128,c):null;case 3:return Fi(_n),Zs(),l=c.flags,(l&65536)!==0&&(l&128)===0?(c.flags=l&-65537|128,c):null;case 26:case 27:case 5:return yr(c),null;case 13:if(Mi(c),l=c.memoizedState,l!==null&&l.dehydrated!==null){if(c.alternate===null)throw Error(s(340));Ac()}return l=c.flags,l&65536?(c.flags=l&-65537|128,c):null;case 19:return xt(Nn),null;case 4:return Zs(),null;case 10:return Fi(c.type),null;case 22:case 23:return Mi(c),Og(),l!==null&&xt(Lo),l=c.flags,l&65536?(c.flags=l&-65537|128,c):null;case 24:return Fi(_n),null;case 25:return null;default:return null}}function OS(l,c){switch(vg(c),c.tag){case 3:Fi(_n),Zs();break;case 26:case 27:case 5:yr(c);break;case 4:Zs();break;case 13:Mi(c);break;case 19:xt(Nn);break;case 10:Fi(c.type);break;case 22:case 23:Mi(c),Og(),l!==null&&xt(Lo);break;case 24:Fi(_n)}}function Kc(l,c){try{var p=c.updateQueue,g=p!==null?p.lastEffect:null;if(g!==null){var b=g.next;p=b;do{if((p.tag&l)===l){g=void 0;var $=p.create,I=p.inst;g=$(),I.destroy=g}p=p.next}while(p!==b)}}catch(P){Ge(c,c.return,P)}}function _a(l,c,p){try{var g=c.updateQueue,b=g!==null?g.lastEffect:null;if(b!==null){var $=b.next;g=$;do{if((g.tag&l)===l){var I=g.inst,P=I.destroy;if(P!==void 0){I.destroy=void 0,b=c;var X=p,rt=P;try{rt()}catch(pt){Ge(b,X,pt)}}}g=g.next}while(g!==$)}}catch(pt){Ge(c,c.return,pt)}}function PS(l){var c=l.updateQueue;if(c!==null){var p=l.stateNode;try{S2(c,p)}catch(g){Ge(l,l.return,g)}}}function FS(l,c,p){p.props=zo(l.type,l.memoizedProps),p.state=l.memoizedState;try{p.componentWillUnmount()}catch(g){Ge(l,c,g)}}function Yc(l,c){try{var p=l.ref;if(p!==null){switch(l.tag){case 26:case 27:case 5:var g=l.stateNode;break;case 30:g=l.stateNode;break;default:g=l.stateNode}typeof p=="function"?l.refCleanup=p(g):p.current=g}}catch(b){Ge(l,c,b)}}function ui(l,c){var p=l.ref,g=l.refCleanup;if(p!==null)if(typeof g=="function")try{g()}catch(b){Ge(l,c,b)}finally{l.refCleanup=null,l=l.alternate,l!=null&&(l.refCleanup=null)}else if(typeof p=="function")try{p(null)}catch(b){Ge(l,c,b)}else p.current=null}function LS(l){var c=l.type,p=l.memoizedProps,g=l.stateNode;try{t:switch(c){case"button":case"input":case"select":case"textarea":p.autoFocus&&g.focus();break t;case"img":p.src?g.src=p.src:p.srcSet&&(g.srcset=p.srcSet)}}catch(b){Ge(l,l.return,b)}}function ly(l,c,p){try{var g=l.stateNode;hD(g,l.type,p,c),g[Je]=c}catch(b){Ge(l,l.return,b)}}function MS(l){return l.tag===5||l.tag===3||l.tag===26||l.tag===27&&Pa(l.type)||l.tag===4}function uy(l){t:for(;;){for(;l.sibling===null;){if(l.return===null||MS(l.return))return null;l=l.return}for(l.sibling.return=l.return,l=l.sibling;l.tag!==5&&l.tag!==6&&l.tag!==18;){if(l.tag===27&&Pa(l.type)||l.flags&2||l.child===null||l.tag===4)continue t;l.child.return=l,l=l.child}if(!(l.flags&2))return l.stateNode}}function cy(l,c,p){var g=l.tag;if(g===5||g===6)l=l.stateNode,c?(p.nodeType===9?p.body:p.nodeName==="HTML"?p.ownerDocument.body:p).insertBefore(l,c):(c=p.nodeType===9?p.body:p.nodeName==="HTML"?p.ownerDocument.body:p,c.appendChild(l),p=p._reactRootContainer,p!=null||c.onclick!==null||(c.onclick=Ff));else if(g!==4&&(g===27&&Pa(l.type)&&(p=l.stateNode,c=null),l=l.child,l!==null))for(cy(l,c,p),l=l.sibling;l!==null;)cy(l,c,p),l=l.sibling}function Tf(l,c,p){var g=l.tag;if(g===5||g===6)l=l.stateNode,c?p.insertBefore(l,c):p.appendChild(l);else if(g!==4&&(g===27&&Pa(l.type)&&(p=l.stateNode),l=l.child,l!==null))for(Tf(l,c,p),l=l.sibling;l!==null;)Tf(l,c,p),l=l.sibling}function zS(l){var c=l.stateNode,p=l.memoizedProps;try{for(var g=l.type,b=c.attributes;b.length;)c.removeAttributeNode(b[0]);Qn(c,g,p),c[_e]=l,c[Je]=p}catch($){Ge(l,l.return,$)}}var Vi=!1,xn=!1,hy=!1,BS=typeof WeakSet=="function"?WeakSet:Set,Fn=null;function HA(l,c){if(l=l.containerInfo,Py=Wf,l=Qw(l),ug(l)){if("selectionStart"in l)var p={start:l.selectionStart,end:l.selectionEnd};else t:{p=(p=l.ownerDocument)&&p.defaultView||window;var g=p.getSelection&&p.getSelection();if(g&&g.rangeCount!==0){p=g.anchorNode;var b=g.anchorOffset,$=g.focusNode;g=g.focusOffset;try{p.nodeType,$.nodeType}catch{p=null;break t}var I=0,P=-1,X=-1,rt=0,pt=0,gt=l,it=null;e:for(;;){for(var lt;gt!==p||b!==0&&gt.nodeType!==3||(P=I+b),gt!==$||g!==0&&gt.nodeType!==3||(X=I+g),gt.nodeType===3&&(I+=gt.nodeValue.length),(lt=gt.firstChild)!==null;)it=gt,gt=lt;for(;;){if(gt===l)break e;if(it===p&&++rt===b&&(P=I),it===$&&++pt===g&&(X=I),(lt=gt.nextSibling)!==null)break;gt=it,it=gt.parentNode}gt=lt}p=P===-1||X===-1?null:{start:P,end:X}}else p=null}p=p||{start:0,end:0}}else p=null;for(Fy={focusedElem:l,selectionRange:p},Wf=!1,Fn=c;Fn!==null;)if(c=Fn,l=c.child,(c.subtreeFlags&1024)!==0&&l!==null)l.return=c,Fn=l;else for(;Fn!==null;){switch(c=Fn,$=c.alternate,l=c.flags,c.tag){case 0:break;case 11:case 15:break;case 1:if((l&1024)!==0&&$!==null){l=void 0,p=c,b=$.memoizedProps,$=$.memoizedState,g=p.stateNode;try{var Qt=zo(p.type,b,p.elementType===p.type);l=g.getSnapshotBeforeUpdate(Qt,$),g.__reactInternalSnapshotBeforeUpdate=l}catch(Ht){Ge(p,p.return,Ht)}}break;case 3:if((l&1024)!==0){if(l=c.stateNode.containerInfo,p=l.nodeType,p===9)zy(l);else if(p===1)switch(l.nodeName){case"HEAD":case"HTML":case"BODY":zy(l);break;default:l.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((l&1024)!==0)throw Error(s(163))}if(l=c.sibling,l!==null){l.return=c.return,Fn=l;break}Fn=c.return}}function VS(l,c,p){var g=p.flags;switch(p.tag){case 0:case 11:case 15:Na(l,p),g&4&&Kc(5,p);break;case 1:if(Na(l,p),g&4)if(l=p.stateNode,c===null)try{l.componentDidMount()}catch(I){Ge(p,p.return,I)}else{var b=zo(p.type,c.memoizedProps);c=c.memoizedState;try{l.componentDidUpdate(b,c,l.__reactInternalSnapshotBeforeUpdate)}catch(I){Ge(p,p.return,I)}}g&64&&PS(p),g&512&&Yc(p,p.return);break;case 3:if(Na(l,p),g&64&&(l=p.updateQueue,l!==null)){if(c=null,p.child!==null)switch(p.child.tag){case 27:case 5:c=p.child.stateNode;break;case 1:c=p.child.stateNode}try{S2(l,c)}catch(I){Ge(p,p.return,I)}}break;case 27:c===null&&g&4&&zS(p);case 26:case 5:Na(l,p),c===null&&g&4&&LS(p),g&512&&Yc(p,p.return);break;case 12:Na(l,p);break;case 13:Na(l,p),g&4&&GS(l,p),g&64&&(l=p.memoizedState,l!==null&&(l=l.dehydrated,l!==null&&(p=tD.bind(null,p),xD(l,p))));break;case 22:if(g=p.memoizedState!==null||Vi,!g){c=c!==null&&c.memoizedState!==null||xn,b=Vi;var $=xn;Vi=g,(xn=c)&&!$?Ea(l,p,(p.subtreeFlags&8772)!==0):Na(l,p),Vi=b,xn=$}break;case 30:break;default:Na(l,p)}}function US(l){var c=l.alternate;c!==null&&(l.alternate=null,US(c)),l.child=null,l.deletions=null,l.sibling=null,l.tag===5&&(c=l.stateNode,c!==null&&ii(c)),l.stateNode=null,l.return=null,l.dependencies=null,l.memoizedProps=null,l.memoizedState=null,l.pendingProps=null,l.stateNode=null,l.updateQueue=null}var rn=null,Ms=!1;function Ui(l,c,p){for(p=p.child;p!==null;)WS(l,c,p),p=p.sibling}function WS(l,c,p){if(Ze&&typeof Ze.onCommitFiberUnmount=="function")try{Ze.onCommitFiberUnmount(xr,p)}catch{}switch(p.tag){case 26:xn||ui(p,c),Ui(l,c,p),p.memoizedState?p.memoizedState.count--:p.stateNode&&(p=p.stateNode,p.parentNode.removeChild(p));break;case 27:xn||ui(p,c);var g=rn,b=Ms;Pa(p.type)&&(rn=p.stateNode,Ms=!1),Ui(l,c,p),ih(p.stateNode),rn=g,Ms=b;break;case 5:xn||ui(p,c);case 6:if(g=rn,b=Ms,rn=null,Ui(l,c,p),rn=g,Ms=b,rn!==null)if(Ms)try{(rn.nodeType===9?rn.body:rn.nodeName==="HTML"?rn.ownerDocument.body:rn).removeChild(p.stateNode)}catch($){Ge(p,c,$)}else try{rn.removeChild(p.stateNode)}catch($){Ge(p,c,$)}break;case 18:rn!==null&&(Ms?(l=rn,IC(l.nodeType===9?l.body:l.nodeName==="HTML"?l.ownerDocument.body:l,p.stateNode),fh(l)):IC(rn,p.stateNode));break;case 4:g=rn,b=Ms,rn=p.stateNode.containerInfo,Ms=!0,Ui(l,c,p),rn=g,Ms=b;break;case 0:case 11:case 14:case 15:xn||_a(2,p,c),xn||_a(4,p,c),Ui(l,c,p);break;case 1:xn||(ui(p,c),g=p.stateNode,typeof g.componentWillUnmount=="function"&&FS(p,c,g)),Ui(l,c,p);break;case 21:Ui(l,c,p);break;case 22:xn=(g=xn)||p.memoizedState!==null,Ui(l,c,p),xn=g;break;default:Ui(l,c,p)}}function GS(l,c){if(c.memoizedState===null&&(l=c.alternate,l!==null&&(l=l.memoizedState,l!==null&&(l=l.dehydrated,l!==null))))try{fh(l)}catch(p){Ge(c,c.return,p)}}function jA(l){switch(l.tag){case 13:case 19:var c=l.stateNode;return c===null&&(c=l.stateNode=new BS),c;case 22:return l=l.stateNode,c=l._retryCache,c===null&&(c=l._retryCache=new BS),c;default:throw Error(s(435,l.tag))}}function dy(l,c){var p=jA(l);c.forEach(function(g){var b=eD.bind(null,l,g);p.has(g)||(p.add(g),g.then(b,b))})}function sr(l,c){var p=c.deletions;if(p!==null)for(var g=0;g<p.length;g++){var b=p[g],$=l,I=c,P=I;t:for(;P!==null;){switch(P.tag){case 27:if(Pa(P.type)){rn=P.stateNode,Ms=!1;break t}break;case 5:rn=P.stateNode,Ms=!1;break t;case 3:case 4:rn=P.stateNode.containerInfo,Ms=!0;break t}P=P.return}if(rn===null)throw Error(s(160));WS($,I,b),rn=null,Ms=!1,$=b.alternate,$!==null&&($.return=null),b.return=null}if(c.subtreeFlags&13878)for(c=c.child;c!==null;)HS(c,l),c=c.sibling}var Xr=null;function HS(l,c){var p=l.alternate,g=l.flags;switch(l.tag){case 0:case 11:case 14:case 15:sr(c,l),rr(l),g&4&&(_a(3,l,l.return),Kc(3,l),_a(5,l,l.return));break;case 1:sr(c,l),rr(l),g&512&&(xn||p===null||ui(p,p.return)),g&64&&Vi&&(l=l.updateQueue,l!==null&&(g=l.callbacks,g!==null&&(p=l.shared.hiddenCallbacks,l.shared.hiddenCallbacks=p===null?g:p.concat(g))));break;case 26:var b=Xr;if(sr(c,l),rr(l),g&512&&(xn||p===null||ui(p,p.return)),g&4){var $=p!==null?p.memoizedState:null;if(g=l.memoizedState,p===null)if(g===null)if(l.stateNode===null){t:{g=l.type,p=l.memoizedProps,b=b.ownerDocument||b;e:switch(g){case"title":$=b.getElementsByTagName("title")[0],(!$||$[Gr]||$[_e]||$.namespaceURI==="http://www.w3.org/2000/svg"||$.hasAttribute("itemprop"))&&($=b.createElement(g),b.head.insertBefore($,b.querySelector("head > title"))),Qn($,g,p),$[_e]=l,sn($),g=$;break t;case"link":var I=zC("link","href",b).get(g+(p.href||""));if(I){for(var P=0;P<I.length;P++)if($=I[P],$.getAttribute("href")===(p.href==null||p.href===""?null:p.href)&&$.getAttribute("rel")===(p.rel==null?null:p.rel)&&$.getAttribute("title")===(p.title==null?null:p.title)&&$.getAttribute("crossorigin")===(p.crossOrigin==null?null:p.crossOrigin)){I.splice(P,1);break e}}$=b.createElement(g),Qn($,g,p),b.head.appendChild($);break;case"meta":if(I=zC("meta","content",b).get(g+(p.content||""))){for(P=0;P<I.length;P++)if($=I[P],$.getAttribute("content")===(p.content==null?null:""+p.content)&&$.getAttribute("name")===(p.name==null?null:p.name)&&$.getAttribute("property")===(p.property==null?null:p.property)&&$.getAttribute("http-equiv")===(p.httpEquiv==null?null:p.httpEquiv)&&$.getAttribute("charset")===(p.charSet==null?null:p.charSet)){I.splice(P,1);break e}}$=b.createElement(g),Qn($,g,p),b.head.appendChild($);break;default:throw Error(s(468,g))}$[_e]=l,sn($),g=$}l.stateNode=g}else BC(b,l.type,l.stateNode);else l.stateNode=MC(b,g,l.memoizedProps);else $!==g?($===null?p.stateNode!==null&&(p=p.stateNode,p.parentNode.removeChild(p)):$.count--,g===null?BC(b,l.type,l.stateNode):MC(b,g,l.memoizedProps)):g===null&&l.stateNode!==null&&ly(l,l.memoizedProps,p.memoizedProps)}break;case 27:sr(c,l),rr(l),g&512&&(xn||p===null||ui(p,p.return)),p!==null&&g&4&&ly(l,l.memoizedProps,p.memoizedProps);break;case 5:if(sr(c,l),rr(l),g&512&&(xn||p===null||ui(p,p.return)),l.flags&32){b=l.stateNode;try{Ei(b,"")}catch(lt){Ge(l,l.return,lt)}}g&4&&l.stateNode!=null&&(b=l.memoizedProps,ly(l,b,p!==null?p.memoizedProps:b)),g&1024&&(hy=!0);break;case 6:if(sr(c,l),rr(l),g&4){if(l.stateNode===null)throw Error(s(162));g=l.memoizedProps,p=l.stateNode;try{p.nodeValue=g}catch(lt){Ge(l,l.return,lt)}}break;case 3:if(Bf=null,b=Xr,Xr=Mf(c.containerInfo),sr(c,l),Xr=b,rr(l),g&4&&p!==null&&p.memoizedState.isDehydrated)try{fh(c.containerInfo)}catch(lt){Ge(l,l.return,lt)}hy&&(hy=!1,jS(l));break;case 4:g=Xr,Xr=Mf(l.stateNode.containerInfo),sr(c,l),rr(l),Xr=g;break;case 12:sr(c,l),rr(l);break;case 13:sr(c,l),rr(l),l.child.flags&8192&&l.memoizedState!==null!=(p!==null&&p.memoizedState!==null)&&(xy=gs()),g&4&&(g=l.updateQueue,g!==null&&(l.updateQueue=null,dy(l,g)));break;case 22:b=l.memoizedState!==null;var X=p!==null&&p.memoizedState!==null,rt=Vi,pt=xn;if(Vi=rt||b,xn=pt||X,sr(c,l),xn=pt,Vi=rt,rr(l),g&8192)t:for(c=l.stateNode,c._visibility=b?c._visibility&-2:c._visibility|1,b&&(p===null||X||Vi||xn||Bo(l)),p=null,c=l;;){if(c.tag===5||c.tag===26){if(p===null){X=p=c;try{if($=X.stateNode,b)I=$.style,typeof I.setProperty=="function"?I.setProperty("display","none","important"):I.display="none";else{P=X.stateNode;var gt=X.memoizedProps.style,it=gt!=null&&gt.hasOwnProperty("display")?gt.display:null;P.style.display=it==null||typeof it=="boolean"?"":(""+it).trim()}}catch(lt){Ge(X,X.return,lt)}}}else if(c.tag===6){if(p===null){X=c;try{X.stateNode.nodeValue=b?"":X.memoizedProps}catch(lt){Ge(X,X.return,lt)}}}else if((c.tag!==22&&c.tag!==23||c.memoizedState===null||c===l)&&c.child!==null){c.child.return=c,c=c.child;continue}if(c===l)break t;for(;c.sibling===null;){if(c.return===null||c.return===l)break t;p===c&&(p=null),c=c.return}p===c&&(p=null),c.sibling.return=c.return,c=c.sibling}g&4&&(g=l.updateQueue,g!==null&&(p=g.retryQueue,p!==null&&(g.retryQueue=null,dy(l,p))));break;case 19:sr(c,l),rr(l),g&4&&(g=l.updateQueue,g!==null&&(l.updateQueue=null,dy(l,g)));break;case 30:break;case 21:break;default:sr(c,l),rr(l)}}function rr(l){var c=l.flags;if(c&2){try{for(var p,g=l.return;g!==null;){if(MS(g)){p=g;break}g=g.return}if(p==null)throw Error(s(160));switch(p.tag){case 27:var b=p.stateNode,$=uy(l);Tf(l,$,b);break;case 5:var I=p.stateNode;p.flags&32&&(Ei(I,""),p.flags&=-33);var P=uy(l);Tf(l,P,I);break;case 3:case 4:var X=p.stateNode.containerInfo,rt=uy(l);cy(l,rt,X);break;default:throw Error(s(161))}}catch(pt){Ge(l,l.return,pt)}l.flags&=-3}c&4096&&(l.flags&=-4097)}function jS(l){if(l.subtreeFlags&1024)for(l=l.child;l!==null;){var c=l;jS(c),c.tag===5&&c.flags&1024&&c.stateNode.reset(),l=l.sibling}}function Na(l,c){if(c.subtreeFlags&8772)for(c=c.child;c!==null;)VS(l,c.alternate,c),c=c.sibling}function Bo(l){for(l=l.child;l!==null;){var c=l;switch(c.tag){case 0:case 11:case 14:case 15:_a(4,c,c.return),Bo(c);break;case 1:ui(c,c.return);var p=c.stateNode;typeof p.componentWillUnmount=="function"&&FS(c,c.return,p),Bo(c);break;case 27:ih(c.stateNode);case 26:case 5:ui(c,c.return),Bo(c);break;case 22:c.memoizedState===null&&Bo(c);break;case 30:Bo(c);break;default:Bo(c)}l=l.sibling}}function Ea(l,c,p){for(p=p&&(c.subtreeFlags&8772)!==0,c=c.child;c!==null;){var g=c.alternate,b=l,$=c,I=$.flags;switch($.tag){case 0:case 11:case 15:Ea(b,$,p),Kc(4,$);break;case 1:if(Ea(b,$,p),g=$,b=g.stateNode,typeof b.componentDidMount=="function")try{b.componentDidMount()}catch(rt){Ge(g,g.return,rt)}if(g=$,b=g.updateQueue,b!==null){var P=g.stateNode;try{var X=b.shared.hiddenCallbacks;if(X!==null)for(b.shared.hiddenCallbacks=null,b=0;b<X.length;b++)w2(X[b],P)}catch(rt){Ge(g,g.return,rt)}}p&&I&64&&PS($),Yc($,$.return);break;case 27:zS($);case 26:case 5:Ea(b,$,p),p&&g===null&&I&4&&LS($),Yc($,$.return);break;case 12:Ea(b,$,p);break;case 13:Ea(b,$,p),p&&I&4&&GS(b,$);break;case 22:$.memoizedState===null&&Ea(b,$,p),Yc($,$.return);break;case 30:break;default:Ea(b,$,p)}c=c.sibling}}function fy(l,c){var p=null;l!==null&&l.memoizedState!==null&&l.memoizedState.cachePool!==null&&(p=l.memoizedState.cachePool.pool),l=null,c.memoizedState!==null&&c.memoizedState.cachePool!==null&&(l=c.memoizedState.cachePool.pool),l!==p&&(l!=null&&l.refCount++,p!=null&&Pc(p))}function py(l,c){l=null,c.alternate!==null&&(l=c.alternate.memoizedState.cache),c=c.memoizedState.cache,c!==l&&(c.refCount++,l!=null&&Pc(l))}function ci(l,c,p,g){if(c.subtreeFlags&10256)for(c=c.child;c!==null;)XS(l,c,p,g),c=c.sibling}function XS(l,c,p,g){var b=c.flags;switch(c.tag){case 0:case 11:case 15:ci(l,c,p,g),b&2048&&Kc(9,c);break;case 1:ci(l,c,p,g);break;case 3:ci(l,c,p,g),b&2048&&(l=null,c.alternate!==null&&(l=c.alternate.memoizedState.cache),c=c.memoizedState.cache,c!==l&&(c.refCount++,l!=null&&Pc(l)));break;case 12:if(b&2048){ci(l,c,p,g),l=c.stateNode;try{var $=c.memoizedProps,I=$.id,P=$.onPostCommit;typeof P=="function"&&P(I,c.alternate===null?"mount":"update",l.passiveEffectDuration,-0)}catch(X){Ge(c,c.return,X)}}else ci(l,c,p,g);break;case 13:ci(l,c,p,g);break;case 23:break;case 22:$=c.stateNode,I=c.alternate,c.memoizedState!==null?$._visibility&2?ci(l,c,p,g):Qc(l,c):$._visibility&2?ci(l,c,p,g):($._visibility|=2,du(l,c,p,g,(c.subtreeFlags&10256)!==0)),b&2048&&fy(I,c);break;case 24:ci(l,c,p,g),b&2048&&py(c.alternate,c);break;default:ci(l,c,p,g)}}function du(l,c,p,g,b){for(b=b&&(c.subtreeFlags&10256)!==0,c=c.child;c!==null;){var $=l,I=c,P=p,X=g,rt=I.flags;switch(I.tag){case 0:case 11:case 15:du($,I,P,X,b),Kc(8,I);break;case 23:break;case 22:var pt=I.stateNode;I.memoizedState!==null?pt._visibility&2?du($,I,P,X,b):Qc($,I):(pt._visibility|=2,du($,I,P,X,b)),b&&rt&2048&&fy(I.alternate,I);break;case 24:du($,I,P,X,b),b&&rt&2048&&py(I.alternate,I);break;default:du($,I,P,X,b)}c=c.sibling}}function Qc(l,c){if(c.subtreeFlags&10256)for(c=c.child;c!==null;){var p=l,g=c,b=g.flags;switch(g.tag){case 22:Qc(p,g),b&2048&&fy(g.alternate,g);break;case 24:Qc(p,g),b&2048&&py(g.alternate,g);break;default:Qc(p,g)}c=c.sibling}}var Zc=8192;function fu(l){if(l.subtreeFlags&Zc)for(l=l.child;l!==null;)qS(l),l=l.sibling}function qS(l){switch(l.tag){case 26:fu(l),l.flags&Zc&&l.memoizedState!==null&&ID(Xr,l.memoizedState,l.memoizedProps);break;case 5:fu(l);break;case 3:case 4:var c=Xr;Xr=Mf(l.stateNode.containerInfo),fu(l),Xr=c;break;case 22:l.memoizedState===null&&(c=l.alternate,c!==null&&c.memoizedState!==null?(c=Zc,Zc=16777216,fu(l),Zc=c):fu(l));break;default:fu(l)}}function KS(l){var c=l.alternate;if(c!==null&&(l=c.child,l!==null)){c.child=null;do c=l.sibling,l.sibling=null,l=c;while(l!==null)}}function Jc(l){var c=l.deletions;if((l.flags&16)!==0){if(c!==null)for(var p=0;p<c.length;p++){var g=c[p];Fn=g,QS(g,l)}KS(l)}if(l.subtreeFlags&10256)for(l=l.child;l!==null;)YS(l),l=l.sibling}function YS(l){switch(l.tag){case 0:case 11:case 15:Jc(l),l.flags&2048&&_a(9,l,l.return);break;case 3:Jc(l);break;case 12:Jc(l);break;case 22:var c=l.stateNode;l.memoizedState!==null&&c._visibility&2&&(l.return===null||l.return.tag!==13)?(c._visibility&=-3,kf(l)):Jc(l);break;default:Jc(l)}}function kf(l){var c=l.deletions;if((l.flags&16)!==0){if(c!==null)for(var p=0;p<c.length;p++){var g=c[p];Fn=g,QS(g,l)}KS(l)}for(l=l.child;l!==null;){switch(c=l,c.tag){case 0:case 11:case 15:_a(8,c,c.return),kf(c);break;case 22:p=c.stateNode,p._visibility&2&&(p._visibility&=-3,kf(c));break;default:kf(c)}l=l.sibling}}function QS(l,c){for(;Fn!==null;){var p=Fn;switch(p.tag){case 0:case 11:case 15:_a(8,p,c);break;case 23:case 22:if(p.memoizedState!==null&&p.memoizedState.cachePool!==null){var g=p.memoizedState.cachePool.pool;g!=null&&g.refCount++}break;case 24:Pc(p.memoizedState.cache)}if(g=p.child,g!==null)g.return=p,Fn=g;else t:for(p=l;Fn!==null;){g=Fn;var b=g.sibling,$=g.return;if(US(g),g===p){Fn=null;break t}if(b!==null){b.return=$,Fn=b;break t}Fn=$}}}var XA={getCacheForType:function(l){var c=as(_n),p=c.data.get(l);return p===void 0&&(p=l(),c.data.set(l,p)),p}},qA=typeof WeakMap=="function"?WeakMap:Map,Ie=0,qe=null,ue=null,ye=0,Ae=0,ir=null,Ra=!1,pu=!1,my=!1,Wi=0,pn=0,Ia=0,Vo=0,gy=0,kr=0,mu=0,th=null,zs=null,yy=!1,xy=0,_f=1/0,Nf=null,Aa=null,Yn=0,Da=null,gu=null,yu=0,by=0,vy=null,ZS=null,eh=0,wy=null;function ar(){if((Ie&2)!==0&&ye!==0)return ye&-ye;if(K.T!==null){var l=ru;return l!==0?l:Ny()}return ss()}function JS(){kr===0&&(kr=(ye&536870912)===0||$e?nn():536870912);var l=Tr.current;return l!==null&&(l.flags|=32),kr}function or(l,c,p){(l===qe&&(Ae===2||Ae===9)||l.cancelPendingCommit!==null)&&(xu(l,0),Oa(l,ye,kr,!1)),Dn(l,p),((Ie&2)===0||l!==qe)&&(l===qe&&((Ie&2)===0&&(Vo|=p),pn===4&&Oa(l,ye,kr,!1)),hi(l))}function tC(l,c,p){if((Ie&6)!==0)throw Error(s(327));var g=!p&&(c&124)===0&&(c&l.expiredLanes)===0||We(l,c),b=g?QA(l,c):$y(l,c,!0),$=g;do{if(b===0){pu&&!g&&Oa(l,c,0,!1);break}else{if(p=l.current.alternate,$&&!KA(p)){b=$y(l,c,!1),$=!1;continue}if(b===2){if($=c,l.errorRecoveryDisabledLanes&$)var I=0;else I=l.pendingLanes&-536870913,I=I!==0?I:I&536870912?536870912:0;if(I!==0){c=I;t:{var P=l;b=th;var X=P.current.memoizedState.isDehydrated;if(X&&(xu(P,I).flags|=256),I=$y(P,I,!1),I!==2){if(my&&!X){P.errorRecoveryDisabledLanes|=$,Vo|=$,b=4;break t}$=zs,zs=b,$!==null&&(zs===null?zs=$:zs.push.apply(zs,$))}b=I}if($=!1,b!==2)continue}}if(b===1){xu(l,0),Oa(l,c,0,!0);break}t:{switch(g=l,$=b,$){case 0:case 1:throw Error(s(345));case 4:if((c&4194048)!==c)break;case 6:Oa(g,c,kr,!Ra);break t;case 2:zs=null;break;case 3:case 5:break;default:throw Error(s(329))}if((c&62914560)===c&&(b=xy+300-gs(),10<b)){if(Oa(g,c,kr,!Ra),ge(g,0,!0)!==0)break t;g.timeoutHandle=EC(eC.bind(null,g,p,zs,Nf,yy,c,kr,Vo,mu,Ra,$,2,-0,0),b);break t}eC(g,p,zs,Nf,yy,c,kr,Vo,mu,Ra,$,0,-0,0)}}break}while(!0);hi(l)}function eC(l,c,p,g,b,$,I,P,X,rt,pt,gt,it,lt){if(l.timeoutHandle=-1,gt=c.subtreeFlags,(gt&8192||(gt&16785408)===16785408)&&(lh={stylesheets:null,count:0,unsuspend:RD},qS(c),gt=AD(),gt!==null)){l.cancelPendingCommit=gt(lC.bind(null,l,c,$,p,g,b,I,P,X,pt,1,it,lt)),Oa(l,$,I,!rt);return}lC(l,c,$,p,g,b,I,P,X)}function KA(l){for(var c=l;;){var p=c.tag;if((p===0||p===11||p===15)&&c.flags&16384&&(p=c.updateQueue,p!==null&&(p=p.stores,p!==null)))for(var g=0;g<p.length;g++){var b=p[g],$=b.getSnapshot;b=b.value;try{if(!er($(),b))return!1}catch{return!1}}if(p=c.child,c.subtreeFlags&16384&&p!==null)p.return=c,c=p;else{if(c===l)break;for(;c.sibling===null;){if(c.return===null||c.return===l)return!0;c=c.return}c.sibling.return=c.return,c=c.sibling}}return!0}function Oa(l,c,p,g){c&=~gy,c&=~Vo,l.suspendedLanes|=c,l.pingedLanes&=~c,g&&(l.warmLanes|=c),g=l.expirationTimes;for(var b=c;0<b;){var $=31-An(b),I=1<<$;g[$]=-1,b&=~I}p!==0&&ke(l,p,c)}function Ef(){return(Ie&6)===0?(nh(0),!1):!0}function Sy(){if(ue!==null){if(Ae===0)var l=ue.return;else l=ue,Pi=Po=null,zg(l),cu=null,jc=0,l=ue;for(;l!==null;)OS(l.alternate,l),l=l.return;ue=null}}function xu(l,c){var p=l.timeoutHandle;p!==-1&&(l.timeoutHandle=-1,fD(p)),p=l.cancelPendingCommit,p!==null&&(l.cancelPendingCommit=null,p()),Sy(),qe=l,ue=p=Ai(l.current,null),ye=c,Ae=0,ir=null,Ra=!1,pu=We(l,c),my=!1,mu=kr=gy=Vo=Ia=pn=0,zs=th=null,yy=!1,(c&8)!==0&&(c|=c&32);var g=l.entangledLanes;if(g!==0)for(l=l.entanglements,g&=c;0<g;){var b=31-An(g),$=1<<b;c|=l[b],g&=~$}return Wi=c,Yd(),p}function nC(l,c){oe=null,K.H=gf,c===Lc||c===af?(c=b2(),Ae=3):c===g2?(c=b2(),Ae=4):Ae=c===vS?8:c!==null&&typeof c=="object"&&typeof c.then=="function"?6:1,ir=c,ue===null&&(pn=1,wf(l,wr(c,l.current)))}function sC(){var l=K.H;return K.H=gf,l===null?gf:l}function rC(){var l=K.A;return K.A=XA,l}function Cy(){pn=4,Ra||(ye&4194048)!==ye&&Tr.current!==null||(pu=!0),(Ia&134217727)===0&&(Vo&134217727)===0||qe===null||Oa(qe,ye,kr,!1)}function $y(l,c,p){var g=Ie;Ie|=2;var b=sC(),$=rC();(qe!==l||ye!==c)&&(Nf=null,xu(l,c)),c=!1;var I=pn;t:do try{if(Ae!==0&&ue!==null){var P=ue,X=ir;switch(Ae){case 8:Sy(),I=6;break t;case 3:case 2:case 9:case 6:Tr.current===null&&(c=!0);var rt=Ae;if(Ae=0,ir=null,bu(l,P,X,rt),p&&pu){I=0;break t}break;default:rt=Ae,Ae=0,ir=null,bu(l,P,X,rt)}}YA(),I=pn;break}catch(pt){nC(l,pt)}while(!0);return c&&l.shellSuspendCounter++,Pi=Po=null,Ie=g,K.H=b,K.A=$,ue===null&&(qe=null,ye=0,Yd()),I}function YA(){for(;ue!==null;)iC(ue)}function QA(l,c){var p=Ie;Ie|=2;var g=sC(),b=rC();qe!==l||ye!==c?(Nf=null,_f=gs()+500,xu(l,c)):pu=We(l,c);t:do try{if(Ae!==0&&ue!==null){c=ue;var $=ir;e:switch(Ae){case 1:Ae=0,ir=null,bu(l,c,$,1);break;case 2:case 9:if(y2($)){Ae=0,ir=null,aC(c);break}c=function(){Ae!==2&&Ae!==9||qe!==l||(Ae=7),hi(l)},$.then(c,c);break t;case 3:Ae=7;break t;case 4:Ae=5;break t;case 7:y2($)?(Ae=0,ir=null,aC(c)):(Ae=0,ir=null,bu(l,c,$,7));break;case 5:var I=null;switch(ue.tag){case 26:I=ue.memoizedState;case 5:case 27:var P=ue;if(!I||VC(I)){Ae=0,ir=null;var X=P.sibling;if(X!==null)ue=X;else{var rt=P.return;rt!==null?(ue=rt,Rf(rt)):ue=null}break e}}Ae=0,ir=null,bu(l,c,$,5);break;case 6:Ae=0,ir=null,bu(l,c,$,6);break;case 8:Sy(),pn=6;break t;default:throw Error(s(462))}}ZA();break}catch(pt){nC(l,pt)}while(!0);return Pi=Po=null,K.H=g,K.A=b,Ie=p,ue!==null?0:(qe=null,ye=0,Yd(),pn)}function ZA(){for(;ue!==null&&!co();)iC(ue)}function iC(l){var c=AS(l.alternate,l,Wi);l.memoizedProps=l.pendingProps,c===null?Rf(l):ue=c}function aC(l){var c=l,p=c.alternate;switch(c.tag){case 15:case 0:c=kS(p,c,c.pendingProps,c.type,void 0,ye);break;case 11:c=kS(p,c,c.pendingProps,c.type.render,c.ref,ye);break;case 5:zg(c);default:OS(p,c),c=ue=o2(c,Wi),c=AS(p,c,Wi)}l.memoizedProps=l.pendingProps,c===null?Rf(l):ue=c}function bu(l,c,p,g){Pi=Po=null,zg(c),cu=null,jc=0;var b=c.return;try{if(VA(l,b,c,p,ye)){pn=1,wf(l,wr(p,l.current)),ue=null;return}}catch($){if(b!==null)throw ue=b,$;pn=1,wf(l,wr(p,l.current)),ue=null;return}c.flags&32768?($e||g===1?l=!0:pu||(ye&536870912)!==0?l=!1:(Ra=l=!0,(g===2||g===9||g===3||g===6)&&(g=Tr.current,g!==null&&g.tag===13&&(g.flags|=16384))),oC(c,l)):Rf(c)}function Rf(l){var c=l;do{if((c.flags&32768)!==0){oC(c,Ra);return}l=c.return;var p=WA(c.alternate,c,Wi);if(p!==null){ue=p;return}if(c=c.sibling,c!==null){ue=c;return}ue=c=l}while(c!==null);pn===0&&(pn=5)}function oC(l,c){do{var p=GA(l.alternate,l);if(p!==null){p.flags&=32767,ue=p;return}if(p=l.return,p!==null&&(p.flags|=32768,p.subtreeFlags=0,p.deletions=null),!c&&(l=l.sibling,l!==null)){ue=l;return}ue=l=p}while(l!==null);pn=6,ue=null}function lC(l,c,p,g,b,$,I,P,X){l.cancelPendingCommit=null;do If();while(Yn!==0);if((Ie&6)!==0)throw Error(s(327));if(c!==null){if(c===l.current)throw Error(s(177));if($=c.lanes|c.childLanes,$|=pg,Se(l,p,$,I,P,X),l===qe&&(ue=qe=null,ye=0),gu=c,Da=l,yu=p,by=$,vy=b,ZS=g,(c.subtreeFlags&10256)!==0||(c.flags&10256)!==0?(l.callbackNode=null,l.callbackPriority=0,nD(ki,function(){return fC(),null})):(l.callbackNode=null,l.callbackPriority=0),g=(c.flags&13878)!==0,(c.subtreeFlags&13878)!==0||g){g=K.T,K.T=null,b=ct.p,ct.p=2,I=Ie,Ie|=4;try{HA(l,c,p)}finally{Ie=I,ct.p=b,K.T=g}}Yn=1,uC(),cC(),hC()}}function uC(){if(Yn===1){Yn=0;var l=Da,c=gu,p=(c.flags&13878)!==0;if((c.subtreeFlags&13878)!==0||p){p=K.T,K.T=null;var g=ct.p;ct.p=2;var b=Ie;Ie|=4;try{HS(c,l);var $=Fy,I=Qw(l.containerInfo),P=$.focusedElem,X=$.selectionRange;if(I!==P&&P&&P.ownerDocument&&Yw(P.ownerDocument.documentElement,P)){if(X!==null&&ug(P)){var rt=X.start,pt=X.end;if(pt===void 0&&(pt=rt),"selectionStart"in P)P.selectionStart=rt,P.selectionEnd=Math.min(pt,P.value.length);else{var gt=P.ownerDocument||document,it=gt&&gt.defaultView||window;if(it.getSelection){var lt=it.getSelection(),Qt=P.textContent.length,Ht=Math.min(X.start,Qt),Be=X.end===void 0?Ht:Math.min(X.end,Qt);!lt.extend&&Ht>Be&&(I=Be,Be=Ht,Ht=I);var et=Kw(P,Ht),J=Kw(P,Be);if(et&&J&&(lt.rangeCount!==1||lt.anchorNode!==et.node||lt.anchorOffset!==et.offset||lt.focusNode!==J.node||lt.focusOffset!==J.offset)){var st=gt.createRange();st.setStart(et.node,et.offset),lt.removeAllRanges(),Ht>Be?(lt.addRange(st),lt.extend(J.node,J.offset)):(st.setEnd(J.node,J.offset),lt.addRange(st))}}}}for(gt=[],lt=P;lt=lt.parentNode;)lt.nodeType===1&&gt.push({element:lt,left:lt.scrollLeft,top:lt.scrollTop});for(typeof P.focus=="function"&&P.focus(),P=0;P<gt.length;P++){var mt=gt[P];mt.element.scrollLeft=mt.left,mt.element.scrollTop=mt.top}}Wf=!!Py,Fy=Py=null}finally{Ie=b,ct.p=g,K.T=p}}l.current=c,Yn=2}}function cC(){if(Yn===2){Yn=0;var l=Da,c=gu,p=(c.flags&8772)!==0;if((c.subtreeFlags&8772)!==0||p){p=K.T,K.T=null;var g=ct.p;ct.p=2;var b=Ie;Ie|=4;try{VS(l,c.alternate,c)}finally{Ie=b,ct.p=g,K.T=p}}Yn=3}}function hC(){if(Yn===4||Yn===3){Yn=0,pc();var l=Da,c=gu,p=yu,g=ZS;(c.subtreeFlags&10256)!==0||(c.flags&10256)!==0?Yn=5:(Yn=0,gu=Da=null,dC(l,l.pendingLanes));var b=l.pendingLanes;if(b===0&&(Aa=null),ys(p),c=c.stateNode,Ze&&typeof Ze.onCommitFiberRoot=="function")try{Ze.onCommitFiberRoot(xr,c,void 0,(c.current.flags&128)===128)}catch{}if(g!==null){c=K.T,b=ct.p,ct.p=2,K.T=null;try{for(var $=l.onRecoverableError,I=0;I<g.length;I++){var P=g[I];$(P.value,{componentStack:P.stack})}}finally{K.T=c,ct.p=b}}(yu&3)!==0&&If(),hi(l),b=l.pendingLanes,(p&4194090)!==0&&(b&42)!==0?l===wy?eh++:(eh=0,wy=l):eh=0,nh(0)}}function dC(l,c){(l.pooledCacheLanes&=c)===0&&(c=l.pooledCache,c!=null&&(l.pooledCache=null,Pc(c)))}function If(l){return uC(),cC(),hC(),fC()}function fC(){if(Yn!==5)return!1;var l=Da,c=by;by=0;var p=ys(yu),g=K.T,b=ct.p;try{ct.p=32>p?32:p,K.T=null,p=vy,vy=null;var $=Da,I=yu;if(Yn=0,gu=Da=null,yu=0,(Ie&6)!==0)throw Error(s(331));var P=Ie;if(Ie|=4,YS($.current),XS($,$.current,I,p),Ie=P,nh(0,!1),Ze&&typeof Ze.onPostCommitFiberRoot=="function")try{Ze.onPostCommitFiberRoot(xr,$)}catch{}return!0}finally{ct.p=b,K.T=g,dC(l,c)}}function pC(l,c,p){c=wr(p,c),c=Jg(l.stateNode,c,2),l=Ca(l,c,2),l!==null&&(Dn(l,2),hi(l))}function Ge(l,c,p){if(l.tag===3)pC(l,l,p);else for(;c!==null;){if(c.tag===3){pC(c,l,p);break}else if(c.tag===1){var g=c.stateNode;if(typeof c.type.getDerivedStateFromError=="function"||typeof g.componentDidCatch=="function"&&(Aa===null||!Aa.has(g))){l=wr(p,l),p=xS(2),g=Ca(c,p,2),g!==null&&(bS(p,g,c,l),Dn(g,2),hi(g));break}}c=c.return}}function Ty(l,c,p){var g=l.pingCache;if(g===null){g=l.pingCache=new qA;var b=new Set;g.set(c,b)}else b=g.get(c),b===void 0&&(b=new Set,g.set(c,b));b.has(p)||(my=!0,b.add(p),l=JA.bind(null,l,c,p),c.then(l,l))}function JA(l,c,p){var g=l.pingCache;g!==null&&g.delete(c),l.pingedLanes|=l.suspendedLanes&p,l.warmLanes&=~p,qe===l&&(ye&p)===p&&(pn===4||pn===3&&(ye&62914560)===ye&&300>gs()-xy?(Ie&2)===0&&xu(l,0):gy|=p,mu===ye&&(mu=0)),hi(l)}function mC(l,c){c===0&&(c=Wn()),l=tu(l,c),l!==null&&(Dn(l,c),hi(l))}function tD(l){var c=l.memoizedState,p=0;c!==null&&(p=c.retryLane),mC(l,p)}function eD(l,c){var p=0;switch(l.tag){case 13:var g=l.stateNode,b=l.memoizedState;b!==null&&(p=b.retryLane);break;case 19:g=l.stateNode;break;case 22:g=l.stateNode._retryCache;break;default:throw Error(s(314))}g!==null&&g.delete(c),mC(l,p)}function nD(l,c){return je(l,c)}var Af=null,vu=null,ky=!1,Df=!1,_y=!1,Uo=0;function hi(l){l!==vu&&l.next===null&&(vu===null?Af=vu=l:vu=vu.next=l),Df=!0,ky||(ky=!0,rD())}function nh(l,c){if(!_y&&Df){_y=!0;do for(var p=!1,g=Af;g!==null;){if(l!==0){var b=g.pendingLanes;if(b===0)var $=0;else{var I=g.suspendedLanes,P=g.pingedLanes;$=(1<<31-An(42|l)+1)-1,$&=b&~(I&~P),$=$&201326741?$&201326741|1:$?$|2:0}$!==0&&(p=!0,bC(g,$))}else $=ye,$=ge(g,g===qe?$:0,g.cancelPendingCommit!==null||g.timeoutHandle!==-1),($&3)===0||We(g,$)||(p=!0,bC(g,$));g=g.next}while(p);_y=!1}}function sD(){gC()}function gC(){Df=ky=!1;var l=0;Uo!==0&&(dD()&&(l=Uo),Uo=0);for(var c=gs(),p=null,g=Af;g!==null;){var b=g.next,$=yC(g,c);$===0?(g.next=null,p===null?Af=b:p.next=b,b===null&&(vu=p)):(p=g,(l!==0||($&3)!==0)&&(Df=!0)),g=b}nh(l)}function yC(l,c){for(var p=l.suspendedLanes,g=l.pingedLanes,b=l.expirationTimes,$=l.pendingLanes&-62914561;0<$;){var I=31-An($),P=1<<I,X=b[I];X===-1?((P&p)===0||(P&g)!==0)&&(b[I]=we(P,c)):X<=c&&(l.expiredLanes|=P),$&=~P}if(c=qe,p=ye,p=ge(l,l===c?p:0,l.cancelPendingCommit!==null||l.timeoutHandle!==-1),g=l.callbackNode,p===0||l===c&&(Ae===2||Ae===9)||l.cancelPendingCommit!==null)return g!==null&&g!==null&&on(g),l.callbackNode=null,l.callbackPriority=0;if((p&3)===0||We(l,p)){if(c=p&-p,c===l.callbackPriority)return c;switch(g!==null&&on(g),ys(p)){case 2:case 8:p=fo;break;case 32:p=ki;break;case 268435456:p=pa;break;default:p=ki}return g=xC.bind(null,l),p=je(p,g),l.callbackPriority=c,l.callbackNode=p,c}return g!==null&&g!==null&&on(g),l.callbackPriority=2,l.callbackNode=null,2}function xC(l,c){if(Yn!==0&&Yn!==5)return l.callbackNode=null,l.callbackPriority=0,null;var p=l.callbackNode;if(If()&&l.callbackNode!==p)return null;var g=ye;return g=ge(l,l===qe?g:0,l.cancelPendingCommit!==null||l.timeoutHandle!==-1),g===0?null:(tC(l,g,c),yC(l,gs()),l.callbackNode!=null&&l.callbackNode===p?xC.bind(null,l):null)}function bC(l,c){if(If())return null;tC(l,c,!0)}function rD(){pD(function(){(Ie&6)!==0?je(Ti,sD):gC()})}function Ny(){return Uo===0&&(Uo=nn()),Uo}function vC(l){return l==null||typeof l=="symbol"||typeof l=="boolean"?null:typeof l=="function"?l:Wl(""+l)}function wC(l,c){var p=c.ownerDocument.createElement("input");return p.name=c.name,p.value=c.value,l.id&&p.setAttribute("form",l.id),c.parentNode.insertBefore(p,c),l=new FormData(l),p.parentNode.removeChild(p),l}function iD(l,c,p,g,b){if(c==="submit"&&p&&p.stateNode===b){var $=vC((b[Je]||null).action),I=g.submitter;I&&(c=(c=I[Je]||null)?vC(c.formAction):I.getAttribute("formAction"),c!==null&&($=c,I=null));var P=new ko("action","action",null,g,b);l.push({event:P,listeners:[{instance:null,listener:function(){if(g.defaultPrevented){if(Uo!==0){var X=I?wC(b,I):new FormData(b);qg(p,{pending:!0,data:X,method:b.method,action:$},null,X)}}else typeof $=="function"&&(P.preventDefault(),X=I?wC(b,I):new FormData(b),qg(p,{pending:!0,data:X,method:b.method,action:$},$,X))},currentTarget:b}]})}}for(var Ey=0;Ey<fg.length;Ey++){var Ry=fg[Ey],aD=Ry.toLowerCase(),oD=Ry[0].toUpperCase()+Ry.slice(1);jr(aD,"on"+oD)}jr(t2,"onAnimationEnd"),jr(e2,"onAnimationIteration"),jr(n2,"onAnimationStart"),jr("dblclick","onDoubleClick"),jr("focusin","onFocus"),jr("focusout","onBlur"),jr($A,"onTransitionRun"),jr(TA,"onTransitionStart"),jr(kA,"onTransitionCancel"),jr(s2,"onTransitionEnd"),Sn("onMouseEnter",["mouseout","mouseover"]),Sn("onMouseLeave",["mouseout","mouseover"]),Sn("onPointerEnter",["pointerout","pointerover"]),Sn("onPointerLeave",["pointerout","pointerover"]),jn("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),jn("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),jn("onBeforeInput",["compositionend","keypress","textInput","paste"]),jn("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),jn("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),jn("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var sh="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),lD=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(sh));function SC(l,c){c=(c&4)!==0;for(var p=0;p<l.length;p++){var g=l[p],b=g.event;g=g.listeners;t:{var $=void 0;if(c)for(var I=g.length-1;0<=I;I--){var P=g[I],X=P.instance,rt=P.currentTarget;if(P=P.listener,X!==$&&b.isPropagationStopped())break t;$=P,b.currentTarget=rt;try{$(b)}catch(pt){vf(pt)}b.currentTarget=null,$=X}else for(I=0;I<g.length;I++){if(P=g[I],X=P.instance,rt=P.currentTarget,P=P.listener,X!==$&&b.isPropagationStopped())break t;$=P,b.currentTarget=rt;try{$(b)}catch(pt){vf(pt)}b.currentTarget=null,$=X}}}}function ce(l,c){var p=c[Js];p===void 0&&(p=c[Js]=new Set);var g=l+"__bubble";p.has(g)||(CC(c,l,2,!1),p.add(g))}function Iy(l,c,p){var g=0;c&&(g|=4),CC(p,l,g,c)}var Of="_reactListening"+Math.random().toString(36).slice(2);function Ay(l){if(!l[Of]){l[Of]=!0,_i.forEach(function(p){p!=="selectionchange"&&(lD.has(p)||Iy(p,!1,l),Iy(p,!0,l))});var c=l.nodeType===9?l:l.ownerDocument;c===null||c[Of]||(c[Of]=!0,Iy("selectionchange",!1,c))}}function CC(l,c,p,g){switch(XC(c)){case 2:var b=PD;break;case 8:b=FD;break;default:b=jy}p=b.bind(null,c,p,l),b=void 0,!Gl||c!=="touchstart"&&c!=="touchmove"&&c!=="wheel"||(b=!0),g?b!==void 0?l.addEventListener(c,p,{capture:!0,passive:b}):l.addEventListener(c,p,!0):b!==void 0?l.addEventListener(c,p,{passive:b}):l.addEventListener(c,p,!1)}function Dy(l,c,p,g,b){var $=g;if((c&1)===0&&(c&2)===0&&g!==null)t:for(;;){if(g===null)return;var I=g.tag;if(I===3||I===4){var P=g.stateNode.containerInfo;if(P===b)break;if(I===4)for(I=g.return;I!==null;){var X=I.tag;if((X===3||X===4)&&I.stateNode.containerInfo===b)return;I=I.return}for(;P!==null;){if(I=rs(P),I===null)return;if(X=I.tag,X===5||X===6||X===26||X===27){g=$=I;continue t}P=P.parentNode}}g=g.return}Bd(function(){var rt=$,pt=wc(p),gt=[];t:{var it=r2.get(l);if(it!==void 0){var lt=ko,Qt=l;switch(l){case"keypress":if($o(p)===0)break t;case"keydown":case"keyup":lt=tg;break;case"focusin":Qt="focus",lt=$c;break;case"focusout":Qt="blur",lt=$c;break;case"beforeblur":case"afterblur":lt=$c;break;case"click":if(p.button===2)break t;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":lt=Ud;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":lt=Xl;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":lt=ng;break;case t2:case e2:case n2:lt=Xm;break;case s2:lt=sg;break;case"scroll":case"scrollend":lt=Hm;break;case"wheel":lt=ig;break;case"copy":case"cut":case"paste":lt=Tc;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":lt=Hd;break;case"toggle":case"beforetoggle":lt=Xd}var Ht=(c&4)!==0,Be=!Ht&&(l==="scroll"||l==="scrollend"),et=Ht?it!==null?it+"Capture":null:it;Ht=[];for(var J=rt,st;J!==null;){var mt=J;if(st=mt.stateNode,mt=mt.tag,mt!==5&&mt!==26&&mt!==27||st===null||et===null||(mt=Co(J,et),mt!=null&&Ht.push(rh(J,mt,st))),Be)break;J=J.return}0<Ht.length&&(it=new lt(it,Qt,null,p,pt),gt.push({event:it,listeners:Ht}))}}if((c&7)===0){t:{if(it=l==="mouseover"||l==="pointerover",lt=l==="mouseout"||l==="pointerout",it&&p!==vc&&(Qt=p.relatedTarget||p.fromElement)&&(rs(Qt)||Qt[wn]))break t;if((lt||it)&&(it=pt.window===pt?pt:(it=pt.ownerDocument)?it.defaultView||it.parentWindow:window,lt?(Qt=p.relatedTarget||p.toElement,lt=rt,Qt=Qt?rs(Qt):null,Qt!==null&&(Be=i(Qt),Ht=Qt.tag,Qt!==Be||Ht!==5&&Ht!==27&&Ht!==6)&&(Qt=null)):(lt=null,Qt=rt),lt!==Qt)){if(Ht=Ud,mt="onMouseLeave",et="onMouseEnter",J="mouse",(l==="pointerout"||l==="pointerover")&&(Ht=Hd,mt="onPointerLeave",et="onPointerEnter",J="pointer"),Be=lt==null?it:vs(lt),st=Qt==null?it:vs(Qt),it=new Ht(mt,J+"leave",lt,p,pt),it.target=Be,it.relatedTarget=st,mt=null,rs(pt)===rt&&(Ht=new Ht(et,J+"enter",Qt,p,pt),Ht.target=st,Ht.relatedTarget=Be,mt=Ht),Be=mt,lt&&Qt)e:{for(Ht=lt,et=Qt,J=0,st=Ht;st;st=wu(st))J++;for(st=0,mt=et;mt;mt=wu(mt))st++;for(;0<J-st;)Ht=wu(Ht),J--;for(;0<st-J;)et=wu(et),st--;for(;J--;){if(Ht===et||et!==null&&Ht===et.alternate)break e;Ht=wu(Ht),et=wu(et)}Ht=null}else Ht=null;lt!==null&&$C(gt,it,lt,Ht,!1),Qt!==null&&Be!==null&&$C(gt,Be,Qt,Ht,!0)}}t:{if(it=rt?vs(rt):window,lt=it.nodeName&&it.nodeName.toLowerCase(),lt==="select"||lt==="input"&&it.type==="file")var Ft=$s;else if(Dt(it))if(qn)Ft=Yl;else{Ft=og;var le=ag}else lt=it.nodeName,!lt||lt.toLowerCase()!=="input"||it.type!=="checkbox"&&it.type!=="radio"?rt&&Ul(rt.elementType)&&(Ft=$s):Ft=lg;if(Ft&&(Ft=Ft(l,rt))){Gt(gt,Ft,p,pt);break t}le&&le(l,it,rt),l==="focusout"&&rt&&it.type==="number"&&rt.memoizedProps.value!=null&&Vl(it,"number",it.value)}switch(le=rt?vs(rt):window,l){case"focusin":(Dt(le)||le.contentEditable==="true")&&(Ql=le,cg=rt,Rc=null);break;case"focusout":Rc=cg=Ql=null;break;case"mousedown":hg=!0;break;case"contextmenu":case"mouseup":case"dragend":hg=!1,Zw(gt,p,pt);break;case"selectionchange":if(CA)break;case"keydown":case"keyup":Zw(gt,p,pt)}var Vt;if(T)t:{switch(l){case"compositionstart":var Xt="onCompositionStart";break t;case"compositionend":Xt="onCompositionEnd";break t;case"compositionupdate":Xt="onCompositionUpdate";break t}Xt=void 0}else vt?Z(l,p)&&(Xt="onCompositionEnd"):l==="keydown"&&p.keyCode===229&&(Xt="onCompositionStart");Xt&&(W&&p.locale!=="ko"&&(vt||Xt!=="onCompositionStart"?Xt==="onCompositionEnd"&&vt&&(Vt=Vd()):(Ps=pt,Cs="value"in Ps?Ps.value:Ps.textContent,vt=!0)),le=Pf(rt,Xt),0<le.length&&(Xt=new _c(Xt,l,null,p,pt),gt.push({event:Xt,listeners:le}),Vt?Xt.data=Vt:(Vt=ot(p),Vt!==null&&(Xt.data=Vt)))),(Vt=O?Nt(l,p):jt(l,p))&&(Xt=Pf(rt,"onBeforeInput"),0<Xt.length&&(le=new _c("onBeforeInput","beforeinput",null,p,pt),gt.push({event:le,listeners:Xt}),le.data=Vt)),iD(gt,l,rt,p,pt)}SC(gt,c)})}function rh(l,c,p){return{instance:l,listener:c,currentTarget:p}}function Pf(l,c){for(var p=c+"Capture",g=[];l!==null;){var b=l,$=b.stateNode;if(b=b.tag,b!==5&&b!==26&&b!==27||$===null||(b=Co(l,p),b!=null&&g.unshift(rh(l,b,$)),b=Co(l,c),b!=null&&g.push(rh(l,b,$))),l.tag===3)return g;l=l.return}return[]}function wu(l){if(l===null)return null;do l=l.return;while(l&&l.tag!==5&&l.tag!==27);return l||null}function $C(l,c,p,g,b){for(var $=c._reactName,I=[];p!==null&&p!==g;){var P=p,X=P.alternate,rt=P.stateNode;if(P=P.tag,X!==null&&X===g)break;P!==5&&P!==26&&P!==27||rt===null||(X=rt,b?(rt=Co(p,$),rt!=null&&I.unshift(rh(p,rt,X))):b||(rt=Co(p,$),rt!=null&&I.push(rh(p,rt,X)))),p=p.return}I.length!==0&&l.push({event:c,listeners:I})}var uD=/\r\n?/g,cD=/\u0000|\uFFFD/g;function TC(l){return(typeof l=="string"?l:""+l).replace(uD,`
`).replace(cD,"")}function kC(l,c){return c=TC(c),TC(l)===c}function Ff(){}function ze(l,c,p,g,b,$){switch(p){case"children":typeof g=="string"?c==="body"||c==="textarea"&&g===""||Ei(l,g):(typeof g=="number"||typeof g=="bigint")&&c!=="body"&&Ei(l,""+g);break;case"className":ga(l,"class",g);break;case"tabIndex":ga(l,"tabindex",g);break;case"dir":case"role":case"viewBox":case"width":case"height":ga(l,p,g);break;case"style":bc(l,g,$);break;case"data":if(c!=="object"){ga(l,"data",g);break}case"src":case"href":if(g===""&&(c!=="a"||p!=="href")){l.removeAttribute(p);break}if(g==null||typeof g=="function"||typeof g=="symbol"||typeof g=="boolean"){l.removeAttribute(p);break}g=Wl(""+g),l.setAttribute(p,g);break;case"action":case"formAction":if(typeof g=="function"){l.setAttribute(p,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof $=="function"&&(p==="formAction"?(c!=="input"&&ze(l,c,"name",b.name,b,null),ze(l,c,"formEncType",b.formEncType,b,null),ze(l,c,"formMethod",b.formMethod,b,null),ze(l,c,"formTarget",b.formTarget,b,null)):(ze(l,c,"encType",b.encType,b,null),ze(l,c,"method",b.method,b,null),ze(l,c,"target",b.target,b,null)));if(g==null||typeof g=="symbol"||typeof g=="boolean"){l.removeAttribute(p);break}g=Wl(""+g),l.setAttribute(p,g);break;case"onClick":g!=null&&(l.onclick=Ff);break;case"onScroll":g!=null&&ce("scroll",l);break;case"onScrollEnd":g!=null&&ce("scrollend",l);break;case"dangerouslySetInnerHTML":if(g!=null){if(typeof g!="object"||!("__html"in g))throw Error(s(61));if(p=g.__html,p!=null){if(b.children!=null)throw Error(s(60));l.innerHTML=p}}break;case"multiple":l.multiple=g&&typeof g!="function"&&typeof g!="symbol";break;case"muted":l.muted=g&&typeof g!="function"&&typeof g!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(g==null||typeof g=="function"||typeof g=="boolean"||typeof g=="symbol"){l.removeAttribute("xlink:href");break}p=Wl(""+g),l.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",p);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":g!=null&&typeof g!="function"&&typeof g!="symbol"?l.setAttribute(p,""+g):l.removeAttribute(p);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":g&&typeof g!="function"&&typeof g!="symbol"?l.setAttribute(p,""):l.removeAttribute(p);break;case"capture":case"download":g===!0?l.setAttribute(p,""):g!==!1&&g!=null&&typeof g!="function"&&typeof g!="symbol"?l.setAttribute(p,g):l.removeAttribute(p);break;case"cols":case"rows":case"size":case"span":g!=null&&typeof g!="function"&&typeof g!="symbol"&&!isNaN(g)&&1<=g?l.setAttribute(p,g):l.removeAttribute(p);break;case"rowSpan":case"start":g==null||typeof g=="function"||typeof g=="symbol"||isNaN(g)?l.removeAttribute(p):l.setAttribute(p,g);break;case"popover":ce("beforetoggle",l),ce("toggle",l),go(l,"popover",g);break;case"xlinkActuate":Cn(l,"http://www.w3.org/1999/xlink","xlink:actuate",g);break;case"xlinkArcrole":Cn(l,"http://www.w3.org/1999/xlink","xlink:arcrole",g);break;case"xlinkRole":Cn(l,"http://www.w3.org/1999/xlink","xlink:role",g);break;case"xlinkShow":Cn(l,"http://www.w3.org/1999/xlink","xlink:show",g);break;case"xlinkTitle":Cn(l,"http://www.w3.org/1999/xlink","xlink:title",g);break;case"xlinkType":Cn(l,"http://www.w3.org/1999/xlink","xlink:type",g);break;case"xmlBase":Cn(l,"http://www.w3.org/XML/1998/namespace","xml:base",g);break;case"xmlLang":Cn(l,"http://www.w3.org/XML/1998/namespace","xml:lang",g);break;case"xmlSpace":Cn(l,"http://www.w3.org/XML/1998/namespace","xml:space",g);break;case"is":go(l,"is",g);break;case"innerText":case"textContent":break;default:(!(2<p.length)||p[0]!=="o"&&p[0]!=="O"||p[1]!=="n"&&p[1]!=="N")&&(p=So.get(p)||p,go(l,p,g))}}function Oy(l,c,p,g,b,$){switch(p){case"style":bc(l,g,$);break;case"dangerouslySetInnerHTML":if(g!=null){if(typeof g!="object"||!("__html"in g))throw Error(s(61));if(p=g.__html,p!=null){if(b.children!=null)throw Error(s(60));l.innerHTML=p}}break;case"children":typeof g=="string"?Ei(l,g):(typeof g=="number"||typeof g=="bigint")&&Ei(l,""+g);break;case"onScroll":g!=null&&ce("scroll",l);break;case"onScrollEnd":g!=null&&ce("scrollend",l);break;case"onClick":g!=null&&(l.onclick=Ff);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!As.hasOwnProperty(p))t:{if(p[0]==="o"&&p[1]==="n"&&(b=p.endsWith("Capture"),c=p.slice(2,b?p.length-7:void 0),$=l[Je]||null,$=$!=null?$[p]:null,typeof $=="function"&&l.removeEventListener(c,$,b),typeof g=="function")){typeof $!="function"&&$!==null&&(p in l?l[p]=null:l.hasAttribute(p)&&l.removeAttribute(p)),l.addEventListener(c,g,b);break t}p in l?l[p]=g:g===!0?l.setAttribute(p,""):go(l,p,g)}}}function Qn(l,c,p){switch(c){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":ce("error",l),ce("load",l);var g=!1,b=!1,$;for($ in p)if(p.hasOwnProperty($)){var I=p[$];if(I!=null)switch($){case"src":g=!0;break;case"srcSet":b=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(s(137,c));default:ze(l,c,$,I,p,null)}}b&&ze(l,c,"srcSet",p.srcSet,p,null),g&&ze(l,c,"src",p.src,p,null);return;case"input":ce("invalid",l);var P=$=I=b=null,X=null,rt=null;for(g in p)if(p.hasOwnProperty(g)){var pt=p[g];if(pt!=null)switch(g){case"name":b=pt;break;case"type":I=pt;break;case"checked":X=pt;break;case"defaultChecked":rt=pt;break;case"value":$=pt;break;case"defaultValue":P=pt;break;case"children":case"dangerouslySetInnerHTML":if(pt!=null)throw Error(s(137,c));break;default:ze(l,c,g,pt,p,null)}}vo(l,$,P,X,rt,I,b,!1),xo(l);return;case"select":ce("invalid",l),g=I=$=null;for(b in p)if(p.hasOwnProperty(b)&&(P=p[b],P!=null))switch(b){case"value":$=P;break;case"defaultValue":I=P;break;case"multiple":g=P;default:ze(l,c,b,P,p,null)}c=$,p=I,l.multiple=!!g,c!=null?Ni(l,!!g,c,!1):p!=null&&Ni(l,!!g,p,!0);return;case"textarea":ce("invalid",l),$=b=g=null;for(I in p)if(p.hasOwnProperty(I)&&(P=p[I],P!=null))switch(I){case"value":g=P;break;case"defaultValue":b=P;break;case"children":$=P;break;case"dangerouslySetInnerHTML":if(P!=null)throw Error(s(91));break;default:ze(l,c,I,P,p,null)}Ld(l,g,b,$),xo(l);return;case"option":for(X in p)if(p.hasOwnProperty(X)&&(g=p[X],g!=null))switch(X){case"selected":l.selected=g&&typeof g!="function"&&typeof g!="symbol";break;default:ze(l,c,X,g,p,null)}return;case"dialog":ce("beforetoggle",l),ce("toggle",l),ce("cancel",l),ce("close",l);break;case"iframe":case"object":ce("load",l);break;case"video":case"audio":for(g=0;g<sh.length;g++)ce(sh[g],l);break;case"image":ce("error",l),ce("load",l);break;case"details":ce("toggle",l);break;case"embed":case"source":case"link":ce("error",l),ce("load",l);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(rt in p)if(p.hasOwnProperty(rt)&&(g=p[rt],g!=null))switch(rt){case"children":case"dangerouslySetInnerHTML":throw Error(s(137,c));default:ze(l,c,rt,g,p,null)}return;default:if(Ul(c)){for(pt in p)p.hasOwnProperty(pt)&&(g=p[pt],g!==void 0&&Oy(l,c,pt,g,p,void 0));return}}for(P in p)p.hasOwnProperty(P)&&(g=p[P],g!=null&&ze(l,c,P,g,p,null))}function hD(l,c,p,g){switch(c){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var b=null,$=null,I=null,P=null,X=null,rt=null,pt=null;for(lt in p){var gt=p[lt];if(p.hasOwnProperty(lt)&&gt!=null)switch(lt){case"checked":break;case"value":break;case"defaultValue":X=gt;default:g.hasOwnProperty(lt)||ze(l,c,lt,null,g,gt)}}for(var it in g){var lt=g[it];if(gt=p[it],g.hasOwnProperty(it)&&(lt!=null||gt!=null))switch(it){case"type":$=lt;break;case"name":b=lt;break;case"checked":rt=lt;break;case"defaultChecked":pt=lt;break;case"value":I=lt;break;case"defaultValue":P=lt;break;case"children":case"dangerouslySetInnerHTML":if(lt!=null)throw Error(s(137,c));break;default:lt!==gt&&ze(l,c,it,lt,g,gt)}}Bl(l,I,P,X,rt,pt,$,b);return;case"select":lt=I=P=it=null;for($ in p)if(X=p[$],p.hasOwnProperty($)&&X!=null)switch($){case"value":break;case"multiple":lt=X;default:g.hasOwnProperty($)||ze(l,c,$,null,g,X)}for(b in g)if($=g[b],X=p[b],g.hasOwnProperty(b)&&($!=null||X!=null))switch(b){case"value":it=$;break;case"defaultValue":P=$;break;case"multiple":I=$;default:$!==X&&ze(l,c,b,$,g,X)}c=P,p=I,g=lt,it!=null?Ni(l,!!p,it,!1):!!g!=!!p&&(c!=null?Ni(l,!!p,c,!0):Ni(l,!!p,p?[]:"",!1));return;case"textarea":lt=it=null;for(P in p)if(b=p[P],p.hasOwnProperty(P)&&b!=null&&!g.hasOwnProperty(P))switch(P){case"value":break;case"children":break;default:ze(l,c,P,null,g,b)}for(I in g)if(b=g[I],$=p[I],g.hasOwnProperty(I)&&(b!=null||$!=null))switch(I){case"value":it=b;break;case"defaultValue":lt=b;break;case"children":break;case"dangerouslySetInnerHTML":if(b!=null)throw Error(s(91));break;default:b!==$&&ze(l,c,I,b,g,$)}Fd(l,it,lt);return;case"option":for(var Qt in p)if(it=p[Qt],p.hasOwnProperty(Qt)&&it!=null&&!g.hasOwnProperty(Qt))switch(Qt){case"selected":l.selected=!1;break;default:ze(l,c,Qt,null,g,it)}for(X in g)if(it=g[X],lt=p[X],g.hasOwnProperty(X)&&it!==lt&&(it!=null||lt!=null))switch(X){case"selected":l.selected=it&&typeof it!="function"&&typeof it!="symbol";break;default:ze(l,c,X,it,g,lt)}return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var Ht in p)it=p[Ht],p.hasOwnProperty(Ht)&&it!=null&&!g.hasOwnProperty(Ht)&&ze(l,c,Ht,null,g,it);for(rt in g)if(it=g[rt],lt=p[rt],g.hasOwnProperty(rt)&&it!==lt&&(it!=null||lt!=null))switch(rt){case"children":case"dangerouslySetInnerHTML":if(it!=null)throw Error(s(137,c));break;default:ze(l,c,rt,it,g,lt)}return;default:if(Ul(c)){for(var Be in p)it=p[Be],p.hasOwnProperty(Be)&&it!==void 0&&!g.hasOwnProperty(Be)&&Oy(l,c,Be,void 0,g,it);for(pt in g)it=g[pt],lt=p[pt],!g.hasOwnProperty(pt)||it===lt||it===void 0&&lt===void 0||Oy(l,c,pt,it,g,lt);return}}for(var et in p)it=p[et],p.hasOwnProperty(et)&&it!=null&&!g.hasOwnProperty(et)&&ze(l,c,et,null,g,it);for(gt in g)it=g[gt],lt=p[gt],!g.hasOwnProperty(gt)||it===lt||it==null&&lt==null||ze(l,c,gt,it,g,lt)}var Py=null,Fy=null;function Lf(l){return l.nodeType===9?l:l.ownerDocument}function _C(l){switch(l){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function NC(l,c){if(l===0)switch(c){case"svg":return 1;case"math":return 2;default:return 0}return l===1&&c==="foreignObject"?0:l}function Ly(l,c){return l==="textarea"||l==="noscript"||typeof c.children=="string"||typeof c.children=="number"||typeof c.children=="bigint"||typeof c.dangerouslySetInnerHTML=="object"&&c.dangerouslySetInnerHTML!==null&&c.dangerouslySetInnerHTML.__html!=null}var My=null;function dD(){var l=window.event;return l&&l.type==="popstate"?l===My?!1:(My=l,!0):(My=null,!1)}var EC=typeof setTimeout=="function"?setTimeout:void 0,fD=typeof clearTimeout=="function"?clearTimeout:void 0,RC=typeof Promise=="function"?Promise:void 0,pD=typeof queueMicrotask=="function"?queueMicrotask:typeof RC<"u"?function(l){return RC.resolve(null).then(l).catch(mD)}:EC;function mD(l){setTimeout(function(){throw l})}function Pa(l){return l==="head"}function IC(l,c){var p=c,g=0,b=0;do{var $=p.nextSibling;if(l.removeChild(p),$&&$.nodeType===8)if(p=$.data,p==="/$"){if(0<g&&8>g){p=g;var I=l.ownerDocument;if(p&1&&ih(I.documentElement),p&2&&ih(I.body),p&4)for(p=I.head,ih(p),I=p.firstChild;I;){var P=I.nextSibling,X=I.nodeName;I[Gr]||X==="SCRIPT"||X==="STYLE"||X==="LINK"&&I.rel.toLowerCase()==="stylesheet"||p.removeChild(I),I=P}}if(b===0){l.removeChild($),fh(c);return}b--}else p==="$"||p==="$?"||p==="$!"?b++:g=p.charCodeAt(0)-48;else g=0;p=$}while(p);fh(c)}function zy(l){var c=l.firstChild;for(c&&c.nodeType===10&&(c=c.nextSibling);c;){var p=c;switch(c=c.nextSibling,p.nodeName){case"HTML":case"HEAD":case"BODY":zy(p),ii(p);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(p.rel.toLowerCase()==="stylesheet")continue}l.removeChild(p)}}function gD(l,c,p,g){for(;l.nodeType===1;){var b=p;if(l.nodeName.toLowerCase()!==c.toLowerCase()){if(!g&&(l.nodeName!=="INPUT"||l.type!=="hidden"))break}else if(g){if(!l[Gr])switch(c){case"meta":if(!l.hasAttribute("itemprop"))break;return l;case"link":if($=l.getAttribute("rel"),$==="stylesheet"&&l.hasAttribute("data-precedence"))break;if($!==b.rel||l.getAttribute("href")!==(b.href==null||b.href===""?null:b.href)||l.getAttribute("crossorigin")!==(b.crossOrigin==null?null:b.crossOrigin)||l.getAttribute("title")!==(b.title==null?null:b.title))break;return l;case"style":if(l.hasAttribute("data-precedence"))break;return l;case"script":if($=l.getAttribute("src"),($!==(b.src==null?null:b.src)||l.getAttribute("type")!==(b.type==null?null:b.type)||l.getAttribute("crossorigin")!==(b.crossOrigin==null?null:b.crossOrigin))&&$&&l.hasAttribute("async")&&!l.hasAttribute("itemprop"))break;return l;default:return l}}else if(c==="input"&&l.type==="hidden"){var $=b.name==null?null:""+b.name;if(b.type==="hidden"&&l.getAttribute("name")===$)return l}else return l;if(l=qr(l.nextSibling),l===null)break}return null}function yD(l,c,p){if(c==="")return null;for(;l.nodeType!==3;)if((l.nodeType!==1||l.nodeName!=="INPUT"||l.type!=="hidden")&&!p||(l=qr(l.nextSibling),l===null))return null;return l}function By(l){return l.data==="$!"||l.data==="$?"&&l.ownerDocument.readyState==="complete"}function xD(l,c){var p=l.ownerDocument;if(l.data!=="$?"||p.readyState==="complete")c();else{var g=function(){c(),p.removeEventListener("DOMContentLoaded",g)};p.addEventListener("DOMContentLoaded",g),l._reactRetry=g}}function qr(l){for(;l!=null;l=l.nextSibling){var c=l.nodeType;if(c===1||c===3)break;if(c===8){if(c=l.data,c==="$"||c==="$!"||c==="$?"||c==="F!"||c==="F")break;if(c==="/$")return null}}return l}var Vy=null;function AC(l){l=l.previousSibling;for(var c=0;l;){if(l.nodeType===8){var p=l.data;if(p==="$"||p==="$!"||p==="$?"){if(c===0)return l;c--}else p==="/$"&&c++}l=l.previousSibling}return null}function DC(l,c,p){switch(c=Lf(p),l){case"html":if(l=c.documentElement,!l)throw Error(s(452));return l;case"head":if(l=c.head,!l)throw Error(s(453));return l;case"body":if(l=c.body,!l)throw Error(s(454));return l;default:throw Error(s(451))}}function ih(l){for(var c=l.attributes;c.length;)l.removeAttributeNode(c[0]);ii(l)}var _r=new Map,OC=new Set;function Mf(l){return typeof l.getRootNode=="function"?l.getRootNode():l.nodeType===9?l:l.ownerDocument}var Gi=ct.d;ct.d={f:bD,r:vD,D:wD,C:SD,L:CD,m:$D,X:kD,S:TD,M:_D};function bD(){var l=Gi.f(),c=Ef();return l||c}function vD(l){var c=bs(l);c!==null&&c.tag===5&&c.type==="form"?tS(c):Gi.r(l)}var Su=typeof document>"u"?null:document;function PC(l,c,p){var g=Su;if(g&&typeof c=="string"&&c){var b=Ss(c);b='link[rel="'+l+'"][href="'+b+'"]',typeof p=="string"&&(b+='[crossorigin="'+p+'"]'),OC.has(b)||(OC.add(b),l={rel:l,crossOrigin:p,href:c},g.querySelector(b)===null&&(c=g.createElement("link"),Qn(c,"link",l),sn(c),g.head.appendChild(c)))}}function wD(l){Gi.D(l),PC("dns-prefetch",l,null)}function SD(l,c){Gi.C(l,c),PC("preconnect",l,c)}function CD(l,c,p){Gi.L(l,c,p);var g=Su;if(g&&l&&c){var b='link[rel="preload"][as="'+Ss(c)+'"]';c==="image"&&p&&p.imageSrcSet?(b+='[imagesrcset="'+Ss(p.imageSrcSet)+'"]',typeof p.imageSizes=="string"&&(b+='[imagesizes="'+Ss(p.imageSizes)+'"]')):b+='[href="'+Ss(l)+'"]';var $=b;switch(c){case"style":$=Cu(l);break;case"script":$=$u(l)}_r.has($)||(l=d({rel:"preload",href:c==="image"&&p&&p.imageSrcSet?void 0:l,as:c},p),_r.set($,l),g.querySelector(b)!==null||c==="style"&&g.querySelector(ah($))||c==="script"&&g.querySelector(oh($))||(c=g.createElement("link"),Qn(c,"link",l),sn(c),g.head.appendChild(c)))}}function $D(l,c){Gi.m(l,c);var p=Su;if(p&&l){var g=c&&typeof c.as=="string"?c.as:"script",b='link[rel="modulepreload"][as="'+Ss(g)+'"][href="'+Ss(l)+'"]',$=b;switch(g){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":$=$u(l)}if(!_r.has($)&&(l=d({rel:"modulepreload",href:l},c),_r.set($,l),p.querySelector(b)===null)){switch(g){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(p.querySelector(oh($)))return}g=p.createElement("link"),Qn(g,"link",l),sn(g),p.head.appendChild(g)}}}function TD(l,c,p){Gi.S(l,c,p);var g=Su;if(g&&l){var b=ws(g).hoistableStyles,$=Cu(l);c=c||"default";var I=b.get($);if(!I){var P={loading:0,preload:null};if(I=g.querySelector(ah($)))P.loading=5;else{l=d({rel:"stylesheet",href:l,"data-precedence":c},p),(p=_r.get($))&&Uy(l,p);var X=I=g.createElement("link");sn(X),Qn(X,"link",l),X._p=new Promise(function(rt,pt){X.onload=rt,X.onerror=pt}),X.addEventListener("load",function(){P.loading|=1}),X.addEventListener("error",function(){P.loading|=2}),P.loading|=4,zf(I,c,g)}I={type:"stylesheet",instance:I,count:1,state:P},b.set($,I)}}}function kD(l,c){Gi.X(l,c);var p=Su;if(p&&l){var g=ws(p).hoistableScripts,b=$u(l),$=g.get(b);$||($=p.querySelector(oh(b)),$||(l=d({src:l,async:!0},c),(c=_r.get(b))&&Wy(l,c),$=p.createElement("script"),sn($),Qn($,"link",l),p.head.appendChild($)),$={type:"script",instance:$,count:1,state:null},g.set(b,$))}}function _D(l,c){Gi.M(l,c);var p=Su;if(p&&l){var g=ws(p).hoistableScripts,b=$u(l),$=g.get(b);$||($=p.querySelector(oh(b)),$||(l=d({src:l,async:!0,type:"module"},c),(c=_r.get(b))&&Wy(l,c),$=p.createElement("script"),sn($),Qn($,"link",l),p.head.appendChild($)),$={type:"script",instance:$,count:1,state:null},g.set(b,$))}}function FC(l,c,p,g){var b=(b=Mt.current)?Mf(b):null;if(!b)throw Error(s(446));switch(l){case"meta":case"title":return null;case"style":return typeof p.precedence=="string"&&typeof p.href=="string"?(c=Cu(p.href),p=ws(b).hoistableStyles,g=p.get(c),g||(g={type:"style",instance:null,count:0,state:null},p.set(c,g)),g):{type:"void",instance:null,count:0,state:null};case"link":if(p.rel==="stylesheet"&&typeof p.href=="string"&&typeof p.precedence=="string"){l=Cu(p.href);var $=ws(b).hoistableStyles,I=$.get(l);if(I||(b=b.ownerDocument||b,I={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},$.set(l,I),($=b.querySelector(ah(l)))&&!$._p&&(I.instance=$,I.state.loading=5),_r.has(l)||(p={rel:"preload",as:"style",href:p.href,crossOrigin:p.crossOrigin,integrity:p.integrity,media:p.media,hrefLang:p.hrefLang,referrerPolicy:p.referrerPolicy},_r.set(l,p),$||ND(b,l,p,I.state))),c&&g===null)throw Error(s(528,""));return I}if(c&&g!==null)throw Error(s(529,""));return null;case"script":return c=p.async,p=p.src,typeof p=="string"&&c&&typeof c!="function"&&typeof c!="symbol"?(c=$u(p),p=ws(b).hoistableScripts,g=p.get(c),g||(g={type:"script",instance:null,count:0,state:null},p.set(c,g)),g):{type:"void",instance:null,count:0,state:null};default:throw Error(s(444,l))}}function Cu(l){return'href="'+Ss(l)+'"'}function ah(l){return'link[rel="stylesheet"]['+l+"]"}function LC(l){return d({},l,{"data-precedence":l.precedence,precedence:null})}function ND(l,c,p,g){l.querySelector('link[rel="preload"][as="style"]['+c+"]")?g.loading=1:(c=l.createElement("link"),g.preload=c,c.addEventListener("load",function(){return g.loading|=1}),c.addEventListener("error",function(){return g.loading|=2}),Qn(c,"link",p),sn(c),l.head.appendChild(c))}function $u(l){return'[src="'+Ss(l)+'"]'}function oh(l){return"script[async]"+l}function MC(l,c,p){if(c.count++,c.instance===null)switch(c.type){case"style":var g=l.querySelector('style[data-href~="'+Ss(p.href)+'"]');if(g)return c.instance=g,sn(g),g;var b=d({},p,{"data-href":p.href,"data-precedence":p.precedence,href:null,precedence:null});return g=(l.ownerDocument||l).createElement("style"),sn(g),Qn(g,"style",b),zf(g,p.precedence,l),c.instance=g;case"stylesheet":b=Cu(p.href);var $=l.querySelector(ah(b));if($)return c.state.loading|=4,c.instance=$,sn($),$;g=LC(p),(b=_r.get(b))&&Uy(g,b),$=(l.ownerDocument||l).createElement("link"),sn($);var I=$;return I._p=new Promise(function(P,X){I.onload=P,I.onerror=X}),Qn($,"link",g),c.state.loading|=4,zf($,p.precedence,l),c.instance=$;case"script":return $=$u(p.src),(b=l.querySelector(oh($)))?(c.instance=b,sn(b),b):(g=p,(b=_r.get($))&&(g=d({},p),Wy(g,b)),l=l.ownerDocument||l,b=l.createElement("script"),sn(b),Qn(b,"link",g),l.head.appendChild(b),c.instance=b);case"void":return null;default:throw Error(s(443,c.type))}else c.type==="stylesheet"&&(c.state.loading&4)===0&&(g=c.instance,c.state.loading|=4,zf(g,p.precedence,l));return c.instance}function zf(l,c,p){for(var g=p.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),b=g.length?g[g.length-1]:null,$=b,I=0;I<g.length;I++){var P=g[I];if(P.dataset.precedence===c)$=P;else if($!==b)break}$?$.parentNode.insertBefore(l,$.nextSibling):(c=p.nodeType===9?p.head:p,c.insertBefore(l,c.firstChild))}function Uy(l,c){l.crossOrigin==null&&(l.crossOrigin=c.crossOrigin),l.referrerPolicy==null&&(l.referrerPolicy=c.referrerPolicy),l.title==null&&(l.title=c.title)}function Wy(l,c){l.crossOrigin==null&&(l.crossOrigin=c.crossOrigin),l.referrerPolicy==null&&(l.referrerPolicy=c.referrerPolicy),l.integrity==null&&(l.integrity=c.integrity)}var Bf=null;function zC(l,c,p){if(Bf===null){var g=new Map,b=Bf=new Map;b.set(p,g)}else b=Bf,g=b.get(p),g||(g=new Map,b.set(p,g));if(g.has(l))return g;for(g.set(l,null),p=p.getElementsByTagName(l),b=0;b<p.length;b++){var $=p[b];if(!($[Gr]||$[_e]||l==="link"&&$.getAttribute("rel")==="stylesheet")&&$.namespaceURI!=="http://www.w3.org/2000/svg"){var I=$.getAttribute(c)||"";I=l+I;var P=g.get(I);P?P.push($):g.set(I,[$])}}return g}function BC(l,c,p){l=l.ownerDocument||l,l.head.insertBefore(p,c==="title"?l.querySelector("head > title"):null)}function ED(l,c,p){if(p===1||c.itemProp!=null)return!1;switch(l){case"meta":case"title":return!0;case"style":if(typeof c.precedence!="string"||typeof c.href!="string"||c.href==="")break;return!0;case"link":if(typeof c.rel!="string"||typeof c.href!="string"||c.href===""||c.onLoad||c.onError)break;switch(c.rel){case"stylesheet":return l=c.disabled,typeof c.precedence=="string"&&l==null;default:return!0}case"script":if(c.async&&typeof c.async!="function"&&typeof c.async!="symbol"&&!c.onLoad&&!c.onError&&c.src&&typeof c.src=="string")return!0}return!1}function VC(l){return!(l.type==="stylesheet"&&(l.state.loading&3)===0)}var lh=null;function RD(){}function ID(l,c,p){if(lh===null)throw Error(s(475));var g=lh;if(c.type==="stylesheet"&&(typeof p.media!="string"||matchMedia(p.media).matches!==!1)&&(c.state.loading&4)===0){if(c.instance===null){var b=Cu(p.href),$=l.querySelector(ah(b));if($){l=$._p,l!==null&&typeof l=="object"&&typeof l.then=="function"&&(g.count++,g=Vf.bind(g),l.then(g,g)),c.state.loading|=4,c.instance=$,sn($);return}$=l.ownerDocument||l,p=LC(p),(b=_r.get(b))&&Uy(p,b),$=$.createElement("link"),sn($);var I=$;I._p=new Promise(function(P,X){I.onload=P,I.onerror=X}),Qn($,"link",p),c.instance=$}g.stylesheets===null&&(g.stylesheets=new Map),g.stylesheets.set(c,l),(l=c.state.preload)&&(c.state.loading&3)===0&&(g.count++,c=Vf.bind(g),l.addEventListener("load",c),l.addEventListener("error",c))}}function AD(){if(lh===null)throw Error(s(475));var l=lh;return l.stylesheets&&l.count===0&&Gy(l,l.stylesheets),0<l.count?function(c){var p=setTimeout(function(){if(l.stylesheets&&Gy(l,l.stylesheets),l.unsuspend){var g=l.unsuspend;l.unsuspend=null,g()}},6e4);return l.unsuspend=c,function(){l.unsuspend=null,clearTimeout(p)}}:null}function Vf(){if(this.count--,this.count===0){if(this.stylesheets)Gy(this,this.stylesheets);else if(this.unsuspend){var l=this.unsuspend;this.unsuspend=null,l()}}}var Uf=null;function Gy(l,c){l.stylesheets=null,l.unsuspend!==null&&(l.count++,Uf=new Map,c.forEach(DD,l),Uf=null,Vf.call(l))}function DD(l,c){if(!(c.state.loading&4)){var p=Uf.get(l);if(p)var g=p.get(null);else{p=new Map,Uf.set(l,p);for(var b=l.querySelectorAll("link[data-precedence],style[data-precedence]"),$=0;$<b.length;$++){var I=b[$];(I.nodeName==="LINK"||I.getAttribute("media")!=="not all")&&(p.set(I.dataset.precedence,I),g=I)}g&&p.set(null,g)}b=c.instance,I=b.getAttribute("data-precedence"),$=p.get(I)||g,$===g&&p.set(null,b),p.set(I,b),this.count++,g=Vf.bind(this),b.addEventListener("load",g),b.addEventListener("error",g),$?$.parentNode.insertBefore(b,$.nextSibling):(l=l.nodeType===9?l.head:l,l.insertBefore(b,l.firstChild)),c.state.loading|=4}}var uh={$$typeof:E,Provider:null,Consumer:null,_currentValue:yt,_currentValue2:yt,_threadCount:0};function OD(l,c,p,g,b,$,I,P){this.tag=1,this.containerInfo=l,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=Wr(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Wr(0),this.hiddenUpdates=Wr(null),this.identifierPrefix=g,this.onUncaughtError=b,this.onCaughtError=$,this.onRecoverableError=I,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=P,this.incompleteTransitions=new Map}function UC(l,c,p,g,b,$,I,P,X,rt,pt,gt){return l=new OD(l,c,p,I,P,X,rt,gt),c=1,$===!0&&(c|=24),$=nr(3,null,null,c),l.current=$,$.stateNode=l,c=Tg(),c.refCount++,l.pooledCache=c,c.refCount++,$.memoizedState={element:g,isDehydrated:p,cache:c},Eg($),l}function WC(l){return l?(l=eu,l):eu}function GC(l,c,p,g,b,$){b=WC(b),g.context===null?g.context=b:g.pendingContext=b,g=Sa(c),g.payload={element:p},$=$===void 0?null:$,$!==null&&(g.callback=$),p=Ca(l,g,c),p!==null&&(or(p,l,c),zc(p,l,c))}function HC(l,c){if(l=l.memoizedState,l!==null&&l.dehydrated!==null){var p=l.retryLane;l.retryLane=p!==0&&p<c?p:c}}function Hy(l,c){HC(l,c),(l=l.alternate)&&HC(l,c)}function jC(l){if(l.tag===13){var c=tu(l,67108864);c!==null&&or(c,l,67108864),Hy(l,67108864)}}var Wf=!0;function PD(l,c,p,g){var b=K.T;K.T=null;var $=ct.p;try{ct.p=2,jy(l,c,p,g)}finally{ct.p=$,K.T=b}}function FD(l,c,p,g){var b=K.T;K.T=null;var $=ct.p;try{ct.p=8,jy(l,c,p,g)}finally{ct.p=$,K.T=b}}function jy(l,c,p,g){if(Wf){var b=Xy(g);if(b===null)Dy(l,c,g,Gf,p),qC(l,g);else if(MD(b,l,c,p,g))g.stopPropagation();else if(qC(l,g),c&4&&-1<LD.indexOf(l)){for(;b!==null;){var $=bs(b);if($!==null)switch($.tag){case 3:if($=$.stateNode,$.current.memoizedState.isDehydrated){var I=Xe($.pendingLanes);if(I!==0){var P=$;for(P.pendingLanes|=2,P.entangledLanes|=2;I;){var X=1<<31-An(I);P.entanglements[1]|=X,I&=~X}hi($),(Ie&6)===0&&(_f=gs()+500,nh(0))}}break;case 13:P=tu($,2),P!==null&&or(P,$,2),Ef(),Hy($,2)}if($=Xy(g),$===null&&Dy(l,c,g,Gf,p),$===b)break;b=$}b!==null&&g.stopPropagation()}else Dy(l,c,g,null,p)}}function Xy(l){return l=wc(l),qy(l)}var Gf=null;function qy(l){if(Gf=null,l=rs(l),l!==null){var c=i(l);if(c===null)l=null;else{var p=c.tag;if(p===13){if(l=a(c),l!==null)return l;l=null}else if(p===3){if(c.stateNode.current.memoizedState.isDehydrated)return c.tag===3?c.stateNode.containerInfo:null;l=null}else c!==l&&(l=null)}}return Gf=l,null}function XC(l){switch(l){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(ho()){case Ti:return 2;case fo:return 8;case ki:case po:return 32;case pa:return 268435456;default:return 32}default:return 32}}var Ky=!1,Fa=null,La=null,Ma=null,ch=new Map,hh=new Map,za=[],LD="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function qC(l,c){switch(l){case"focusin":case"focusout":Fa=null;break;case"dragenter":case"dragleave":La=null;break;case"mouseover":case"mouseout":Ma=null;break;case"pointerover":case"pointerout":ch.delete(c.pointerId);break;case"gotpointercapture":case"lostpointercapture":hh.delete(c.pointerId)}}function dh(l,c,p,g,b,$){return l===null||l.nativeEvent!==$?(l={blockedOn:c,domEventName:p,eventSystemFlags:g,nativeEvent:$,targetContainers:[b]},c!==null&&(c=bs(c),c!==null&&jC(c)),l):(l.eventSystemFlags|=g,c=l.targetContainers,b!==null&&c.indexOf(b)===-1&&c.push(b),l)}function MD(l,c,p,g,b){switch(c){case"focusin":return Fa=dh(Fa,l,c,p,g,b),!0;case"dragenter":return La=dh(La,l,c,p,g,b),!0;case"mouseover":return Ma=dh(Ma,l,c,p,g,b),!0;case"pointerover":var $=b.pointerId;return ch.set($,dh(ch.get($)||null,l,c,p,g,b)),!0;case"gotpointercapture":return $=b.pointerId,hh.set($,dh(hh.get($)||null,l,c,p,g,b)),!0}return!1}function KC(l){var c=rs(l.target);if(c!==null){var p=i(c);if(p!==null){if(c=p.tag,c===13){if(c=a(p),c!==null){l.blockedOn=c,te(l.priority,function(){if(p.tag===13){var g=ar();g=Is(g);var b=tu(p,g);b!==null&&or(b,p,g),Hy(p,g)}});return}}else if(c===3&&p.stateNode.current.memoizedState.isDehydrated){l.blockedOn=p.tag===3?p.stateNode.containerInfo:null;return}}}l.blockedOn=null}function Hf(l){if(l.blockedOn!==null)return!1;for(var c=l.targetContainers;0<c.length;){var p=Xy(l.nativeEvent);if(p===null){p=l.nativeEvent;var g=new p.constructor(p.type,p);vc=g,p.target.dispatchEvent(g),vc=null}else return c=bs(p),c!==null&&jC(c),l.blockedOn=p,!1;c.shift()}return!0}function YC(l,c,p){Hf(l)&&p.delete(c)}function zD(){Ky=!1,Fa!==null&&Hf(Fa)&&(Fa=null),La!==null&&Hf(La)&&(La=null),Ma!==null&&Hf(Ma)&&(Ma=null),ch.forEach(YC),hh.forEach(YC)}function jf(l,c){l.blockedOn===c&&(l.blockedOn=null,Ky||(Ky=!0,n.unstable_scheduleCallback(n.unstable_NormalPriority,zD)))}var Xf=null;function QC(l){Xf!==l&&(Xf=l,n.unstable_scheduleCallback(n.unstable_NormalPriority,function(){Xf===l&&(Xf=null);for(var c=0;c<l.length;c+=3){var p=l[c],g=l[c+1],b=l[c+2];if(typeof g!="function"){if(qy(g||p)===null)continue;break}var $=bs(p);$!==null&&(l.splice(c,3),c-=3,qg($,{pending:!0,data:b,method:p.method,action:g},g,b))}}))}function fh(l){function c(X){return jf(X,l)}Fa!==null&&jf(Fa,l),La!==null&&jf(La,l),Ma!==null&&jf(Ma,l),ch.forEach(c),hh.forEach(c);for(var p=0;p<za.length;p++){var g=za[p];g.blockedOn===l&&(g.blockedOn=null)}for(;0<za.length&&(p=za[0],p.blockedOn===null);)KC(p),p.blockedOn===null&&za.shift();if(p=(l.ownerDocument||l).$$reactFormReplay,p!=null)for(g=0;g<p.length;g+=3){var b=p[g],$=p[g+1],I=b[Je]||null;if(typeof $=="function")I||QC(p);else if(I){var P=null;if($&&$.hasAttribute("formAction")){if(b=$,I=$[Je]||null)P=I.formAction;else if(qy(b)!==null)continue}else P=I.action;typeof P=="function"?p[g+1]=P:(p.splice(g,3),g-=3),QC(p)}}}function Yy(l){this._internalRoot=l}qf.prototype.render=Yy.prototype.render=function(l){var c=this._internalRoot;if(c===null)throw Error(s(409));var p=c.current,g=ar();GC(p,g,l,c,null,null)},qf.prototype.unmount=Yy.prototype.unmount=function(){var l=this._internalRoot;if(l!==null){this._internalRoot=null;var c=l.containerInfo;GC(l.current,2,null,l,null,null),Ef(),c[wn]=null}};function qf(l){this._internalRoot=l}qf.prototype.unstable_scheduleHydration=function(l){if(l){var c=ss();l={blockedOn:null,target:l,priority:c};for(var p=0;p<za.length&&c!==0&&c<za[p].priority;p++);za.splice(p,0,l),p===0&&KC(l)}};var ZC=t.version;if(ZC!=="19.1.1")throw Error(s(527,ZC,"19.1.1"));ct.findDOMNode=function(l){var c=l._reactInternals;if(c===void 0)throw typeof l.render=="function"?Error(s(188)):(l=Object.keys(l).join(","),Error(s(268,l)));return l=u(c),l=l!==null?h(l):null,l=l===null?null:l.stateNode,l};var BD={bundleType:0,version:"19.1.1",rendererPackageName:"react-dom",currentDispatcherRef:K,reconcilerVersion:"19.1.1"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Kf=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Kf.isDisabled&&Kf.supportsFiber)try{xr=Kf.inject(BD),Ze=Kf}catch{}}return mh.createRoot=function(l,c){if(!r(l))throw Error(s(299));var p=!1,g="",b=pS,$=mS,I=gS,P=null;return c!=null&&(c.unstable_strictMode===!0&&(p=!0),c.identifierPrefix!==void 0&&(g=c.identifierPrefix),c.onUncaughtError!==void 0&&(b=c.onUncaughtError),c.onCaughtError!==void 0&&($=c.onCaughtError),c.onRecoverableError!==void 0&&(I=c.onRecoverableError),c.unstable_transitionCallbacks!==void 0&&(P=c.unstable_transitionCallbacks)),c=UC(l,1,!1,null,null,p,g,b,$,I,P,null),l[wn]=c.current,Ay(l),new Yy(c)},mh.hydrateRoot=function(l,c,p){if(!r(l))throw Error(s(299));var g=!1,b="",$=pS,I=mS,P=gS,X=null,rt=null;return p!=null&&(p.unstable_strictMode===!0&&(g=!0),p.identifierPrefix!==void 0&&(b=p.identifierPrefix),p.onUncaughtError!==void 0&&($=p.onUncaughtError),p.onCaughtError!==void 0&&(I=p.onCaughtError),p.onRecoverableError!==void 0&&(P=p.onRecoverableError),p.unstable_transitionCallbacks!==void 0&&(X=p.unstable_transitionCallbacks),p.formState!==void 0&&(rt=p.formState)),c=UC(l,1,!0,c,p??null,g,b,$,I,P,X,rt),c.context=WC(null),p=c.current,g=ar(),g=Is(g),b=Sa(g),b.callback=null,Ca(p,b,g),p=g,c.current.lanes=p,Dn(c,p),hi(c),l[wn]=c.current,Ay(l),new qf(c)},mh.version="19.1.1",mh}var u$;function ZD(){if(u$)return Jy.exports;u$=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(t){console.error(t)}}return n(),Jy.exports=QD(),Jy.exports}var JD=ZD();const tO="modulepreload",eO=function(n){return"/running-form/"+n},c$={},nO=function(t,e,s){let r=Promise.resolve();if(e&&e.length>0){let u=function(h){return Promise.all(h.map(d=>Promise.resolve(d).then(f=>({status:"fulfilled",value:f}),f=>({status:"rejected",reason:f}))))};document.getElementsByTagName("link");const a=document.querySelector("meta[property=csp-nonce]"),o=a?.nonce||a?.getAttribute("nonce");r=u(e.map(h=>{if(h=eO(h),h in c$)return;c$[h]=!0;const d=h.endsWith(".css"),f=d?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${h}"]${f}`))return;const m=document.createElement("link");if(m.rel=d?"stylesheet":tO,d||(m.as="script"),m.crossOrigin="",m.href=h,o&&m.setAttribute("nonce",o),document.head.appendChild(m),d)return new Promise((y,x)=>{m.addEventListener("load",y),m.addEventListener("error",()=>x(new Error(`Unable to preload CSS for ${h}`)))})}))}function i(a){const o=new Event("vite:preloadError",{cancelable:!0});if(o.payload=a,window.dispatchEvent(o),!o.defaultPrevented)throw a}return r.then(a=>{for(const o of a||[])o.status==="rejected"&&i(o.reason);return t().catch(i)})};var sx={},h$;function sO(){return h$||(h$=1,(function(){var n;function t(v){var T=0;return function(){return T<v.length?{done:!1,value:v[T++]}:{done:!0}}}var e=typeof Object.defineProperties=="function"?Object.defineProperty:function(v,T,N){return v==Array.prototype||v==Object.prototype||(v[T]=N.value),v};function s(v){v=[typeof globalThis=="object"&&globalThis,v,typeof window=="object"&&window,typeof self=="object"&&self,typeof JC=="object"&&JC];for(var T=0;T<v.length;++T){var N=v[T];if(N&&N.Math==Math)return N}throw Error("Cannot find global object")}var r=s(this);function i(v,T){if(T)t:{var N=r;v=v.split(".");for(var O=0;O<v.length-1;O++){var W=v[O];if(!(W in N))break t;N=N[W]}v=v[v.length-1],O=N[v],T=T(O),T!=O&&T!=null&&e(N,v,{configurable:!0,writable:!0,value:T})}}i("Symbol",function(v){function T(j){if(this instanceof T)throw new TypeError("Symbol is not a constructor");return new N(O+(j||"")+"_"+W++,j)}function N(j,G){this.h=j,e(this,"description",{configurable:!0,writable:!0,value:G})}if(v)return v;N.prototype.toString=function(){return this.h};var O="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",W=0;return T}),i("Symbol.iterator",function(v){if(v)return v;v=Symbol("Symbol.iterator");for(var T="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),N=0;N<T.length;N++){var O=r[T[N]];typeof O=="function"&&typeof O.prototype[v]!="function"&&e(O.prototype,v,{configurable:!0,writable:!0,value:function(){return a(t(this))}})}return v});function a(v){return v={next:v},v[Symbol.iterator]=function(){return this},v}function o(v){var T=typeof Symbol<"u"&&Symbol.iterator&&v[Symbol.iterator];return T?T.call(v):{next:t(v)}}function u(v){if(!(v instanceof Array)){v=o(v);for(var T,N=[];!(T=v.next()).done;)N.push(T.value);v=N}return v}var h=typeof Object.assign=="function"?Object.assign:function(v,T){for(var N=1;N<arguments.length;N++){var O=arguments[N];if(O)for(var W in O)Object.prototype.hasOwnProperty.call(O,W)&&(v[W]=O[W])}return v};i("Object.assign",function(v){return v||h});var d=typeof Object.create=="function"?Object.create:function(v){function T(){}return T.prototype=v,new T},f;if(typeof Object.setPrototypeOf=="function")f=Object.setPrototypeOf;else{var m;t:{var y={a:!0},x={};try{x.__proto__=y,m=x.a;break t}catch{}m=!1}f=m?function(v,T){if(v.__proto__=T,v.__proto__!==T)throw new TypeError(v+" is not extensible");return v}:null}var w=f;function S(v,T){if(v.prototype=d(T.prototype),v.prototype.constructor=v,w)w(v,T);else for(var N in T)if(N!="prototype")if(Object.defineProperties){var O=Object.getOwnPropertyDescriptor(T,N);O&&Object.defineProperty(v,N,O)}else v[N]=T[N];v.za=T.prototype}function C(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function k(v){if(v.m)throw new TypeError("Generator is already running");v.m=!0}C.prototype.u=function(v){this.i=v};function E(v,T){v.l={ma:T,na:!0},v.h=v.s||v.v}C.prototype.return=function(v){this.l={return:v},this.h=this.v};function R(v,T,N){return v.h=N,{value:T}}function A(v){this.h=new C,this.i=v}function L(v,T){k(v.h);var N=v.h.j;return N?V(v,"return"in N?N.return:function(O){return{value:O,done:!0}},T,v.h.return):(v.h.return(T),B(v))}function V(v,T,N,O){try{var W=T.call(v.h.j,N);if(!(W instanceof Object))throw new TypeError("Iterator result "+W+" is not an object");if(!W.done)return v.h.m=!1,W;var j=W.value}catch(G){return v.h.j=null,E(v.h,G),B(v)}return v.h.j=null,O.call(v.h,j),B(v)}function B(v){for(;v.h.h;)try{var T=v.i(v.h);if(T)return v.h.m=!1,{value:T.value,done:!1}}catch(N){v.h.i=void 0,E(v.h,N)}if(v.h.m=!1,v.h.l){if(T=v.h.l,v.h.l=null,T.na)throw T.ma;return{value:T.return,done:!0}}return{value:void 0,done:!0}}function z(v){this.next=function(T){return k(v.h),v.h.j?T=V(v,v.h.j.next,T,v.h.u):(v.h.u(T),T=B(v)),T},this.throw=function(T){return k(v.h),v.h.j?T=V(v,v.h.j.throw,T,v.h.u):(E(v.h,T),T=B(v)),T},this.return=function(T){return L(v,T)},this[Symbol.iterator]=function(){return this}}function U(v){function T(O){return v.next(O)}function N(O){return v.throw(O)}return new Promise(function(O,W){function j(G){G.done?O(G.value):Promise.resolve(G.value).then(T,N).then(j,W)}j(v.next())})}function D(v){return U(new z(new A(v)))}i("Promise",function(v){function T(G){this.i=0,this.j=void 0,this.h=[],this.u=!1;var Z=this.l();try{G(Z.resolve,Z.reject)}catch(ot){Z.reject(ot)}}function N(){this.h=null}function O(G){return G instanceof T?G:new T(function(Z){Z(G)})}if(v)return v;N.prototype.i=function(G){if(this.h==null){this.h=[];var Z=this;this.j(function(){Z.m()})}this.h.push(G)};var W=r.setTimeout;N.prototype.j=function(G){W(G,0)},N.prototype.m=function(){for(;this.h&&this.h.length;){var G=this.h;this.h=[];for(var Z=0;Z<G.length;++Z){var ot=G[Z];G[Z]=null;try{ot()}catch(vt){this.l(vt)}}}this.h=null},N.prototype.l=function(G){this.j(function(){throw G})},T.prototype.l=function(){function G(vt){return function(Nt){ot||(ot=!0,vt.call(Z,Nt))}}var Z=this,ot=!1;return{resolve:G(this.I),reject:G(this.m)}},T.prototype.I=function(G){if(G===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(G instanceof T)this.L(G);else{t:switch(typeof G){case"object":var Z=G!=null;break t;case"function":Z=!0;break t;default:Z=!1}Z?this.F(G):this.s(G)}},T.prototype.F=function(G){var Z=void 0;try{Z=G.then}catch(ot){this.m(ot);return}typeof Z=="function"?this.M(Z,G):this.s(G)},T.prototype.m=function(G){this.v(2,G)},T.prototype.s=function(G){this.v(1,G)},T.prototype.v=function(G,Z){if(this.i!=0)throw Error("Cannot settle("+G+", "+Z+"): Promise already settled in state"+this.i);this.i=G,this.j=Z,this.i===2&&this.K(),this.H()},T.prototype.K=function(){var G=this;W(function(){if(G.D()){var Z=r.console;typeof Z<"u"&&Z.error(G.j)}},1)},T.prototype.D=function(){if(this.u)return!1;var G=r.CustomEvent,Z=r.Event,ot=r.dispatchEvent;return typeof ot>"u"?!0:(typeof G=="function"?G=new G("unhandledrejection",{cancelable:!0}):typeof Z=="function"?G=new Z("unhandledrejection",{cancelable:!0}):(G=r.document.createEvent("CustomEvent"),G.initCustomEvent("unhandledrejection",!1,!0,G)),G.promise=this,G.reason=this.j,ot(G))},T.prototype.H=function(){if(this.h!=null){for(var G=0;G<this.h.length;++G)j.i(this.h[G]);this.h=null}};var j=new N;return T.prototype.L=function(G){var Z=this.l();G.T(Z.resolve,Z.reject)},T.prototype.M=function(G,Z){var ot=this.l();try{G.call(Z,ot.resolve,ot.reject)}catch(vt){ot.reject(vt)}},T.prototype.then=function(G,Z){function ot(Bt,Dt){return typeof Bt=="function"?function(Gt){try{vt(Bt(Gt))}catch(Zt){Nt(Zt)}}:Dt}var vt,Nt,jt=new T(function(Bt,Dt){vt=Bt,Nt=Dt});return this.T(ot(G,vt),ot(Z,Nt)),jt},T.prototype.catch=function(G){return this.then(void 0,G)},T.prototype.T=function(G,Z){function ot(){switch(vt.i){case 1:G(vt.j);break;case 2:Z(vt.j);break;default:throw Error("Unexpected state: "+vt.i)}}var vt=this;this.h==null?j.i(ot):this.h.push(ot),this.u=!0},T.resolve=O,T.reject=function(G){return new T(function(Z,ot){ot(G)})},T.race=function(G){return new T(function(Z,ot){for(var vt=o(G),Nt=vt.next();!Nt.done;Nt=vt.next())O(Nt.value).T(Z,ot)})},T.all=function(G){var Z=o(G),ot=Z.next();return ot.done?O([]):new T(function(vt,Nt){function jt(Gt){return function(Zt){Bt[Gt]=Zt,Dt--,Dt==0&&vt(Bt)}}var Bt=[],Dt=0;do Bt.push(void 0),Dt++,O(ot.value).T(jt(Bt.length-1),Nt),ot=Z.next();while(!ot.done)})},T});function Y(v,T){v instanceof String&&(v+="");var N=0,O=!1,W={next:function(){if(!O&&N<v.length){var j=N++;return{value:T(j,v[j]),done:!1}}return O=!0,{done:!0,value:void 0}}};return W[Symbol.iterator]=function(){return W},W}i("Array.prototype.keys",function(v){return v||function(){return Y(this,function(T){return T})}}),i("Array.prototype.fill",function(v){return v||function(T,N,O){var W=this.length||0;for(0>N&&(N=Math.max(0,W+N)),(O==null||O>W)&&(O=W),O=Number(O),0>O&&(O=Math.max(0,W+O)),N=Number(N||0);N<O;N++)this[N]=T;return this}});function nt(v){return v||Array.prototype.fill}i("Int8Array.prototype.fill",nt),i("Uint8Array.prototype.fill",nt),i("Uint8ClampedArray.prototype.fill",nt),i("Int16Array.prototype.fill",nt),i("Uint16Array.prototype.fill",nt),i("Int32Array.prototype.fill",nt),i("Uint32Array.prototype.fill",nt),i("Float32Array.prototype.fill",nt),i("Float64Array.prototype.fill",nt),i("Object.is",function(v){return v||function(T,N){return T===N?T!==0||1/T===1/N:T!==T&&N!==N}}),i("Array.prototype.includes",function(v){return v||function(T,N){var O=this;O instanceof String&&(O=String(O));var W=O.length;for(N=N||0,0>N&&(N=Math.max(N+W,0));N<W;N++){var j=O[N];if(j===T||Object.is(j,T))return!0}return!1}}),i("String.prototype.includes",function(v){return v||function(T,N){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(T instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(T,N||0)!==-1}});var dt=this||self;function at(v,T){v=v.split(".");var N=dt;v[0]in N||typeof N.execScript>"u"||N.execScript("var "+v[0]);for(var O;v.length&&(O=v.shift());)v.length||T===void 0?N[O]&&N[O]!==Object.prototype[O]?N=N[O]:N=N[O]={}:N[O]=T}function K(v){var T;t:{if((T=dt.navigator)&&(T=T.userAgent))break t;T=""}return T.indexOf(v)!=-1}var ct=Array.prototype.map?function(v,T){return Array.prototype.map.call(v,T,void 0)}:function(v,T){for(var N=v.length,O=Array(N),W=typeof v=="string"?v.split(""):v,j=0;j<N;j++)j in W&&(O[j]=T.call(void 0,W[j],j,v));return O},yt={},$t=null;function H(v){var T=v.length,N=3*T/4;N%3?N=Math.floor(N):"=.".indexOf(v[T-1])!=-1&&(N="=.".indexOf(v[T-2])!=-1?N-2:N-1);var O=new Uint8Array(N),W=0;return ut(v,function(j){O[W++]=j}),W!==N?O.subarray(0,W):O}function ut(v,T){function N(ot){for(;O<v.length;){var vt=v.charAt(O++),Nt=$t[vt];if(Nt!=null)return Nt;if(!/^[\s\xa0]*$/.test(vt))throw Error("Unknown base64 encoding at char: "+vt)}return ot}xt();for(var O=0;;){var W=N(-1),j=N(0),G=N(64),Z=N(64);if(Z===64&&W===-1)break;T(W<<2|j>>4),G!=64&&(T(j<<4&240|G>>2),Z!=64&&T(G<<6&192|Z))}}function xt(){if(!$t){$t={};for(var v="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),T=["+/=","+/","-_=","-_.","-_"],N=0;5>N;N++){var O=v.concat(T[N].split(""));yt[N]=O;for(var W=0;W<O.length;W++){var j=O[W];$t[j]===void 0&&($t[j]=W)}}}}var bt=typeof Uint8Array<"u",_t=!(K("Trident")||K("MSIE"))&&typeof dt.btoa=="function";function Kt(v){if(!_t){var T;T===void 0&&(T=0),xt(),T=yt[T];for(var N=Array(Math.floor(v.length/3)),O=T[64]||"",W=0,j=0;W<v.length-2;W+=3){var G=v[W],Z=v[W+1],ot=v[W+2],vt=T[G>>2];G=T[(G&3)<<4|Z>>4],Z=T[(Z&15)<<2|ot>>6],ot=T[ot&63],N[j++]=vt+G+Z+ot}switch(vt=0,ot=O,v.length-W){case 2:vt=v[W+1],ot=T[(vt&15)<<2]||O;case 1:v=v[W],N[j]=T[v>>2]+T[(v&3)<<4|vt>>4]+ot+O}return N.join("")}for(T="";10240<v.length;)T+=String.fromCharCode.apply(null,v.subarray(0,10240)),v=v.subarray(10240);return T+=String.fromCharCode.apply(null,v),btoa(T)}var Mt=RegExp("[-_.]","g");function Un(v){switch(v){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function ve(v){if(!_t)return H(v);Mt.test(v)&&(v=v.replace(Mt,Un)),v=atob(v);for(var T=new Uint8Array(v.length),N=0;N<v.length;N++)T[N]=v.charCodeAt(N);return T}var Zs;function Vr(){return Zs||(Zs=new Uint8Array(0))}var yr={},fa=typeof Uint8Array.prototype.slice=="function",je=0,on=0;function co(v){var T=0>v;v=Math.abs(v);var N=v>>>0;v=Math.floor((v-N)/4294967296),T&&(N=o(gs(N,v)),T=N.next().value,v=N.next().value,N=T),je=N>>>0,on=v>>>0}var pc=typeof BigInt=="function";function gs(v,T){return T=~T,v?v=~v+1:T+=1,[v,T]}function ho(v,T){this.i=v>>>0,this.h=T>>>0}function Ti(v){if(!v)return fo||(fo=new ho(0,0));if(!/^-?\d+$/.test(v))return null;if(16>v.length)co(Number(v));else if(pc)v=BigInt(v),je=Number(v&BigInt(4294967295))>>>0,on=Number(v>>BigInt(32)&BigInt(4294967295));else{var T=+(v[0]==="-");on=je=0;for(var N=v.length,O=T,W=(N-T)%6+T;W<=N;O=W,W+=6)O=Number(v.slice(O,W)),on*=1e6,je=1e6*je+O,4294967296<=je&&(on+=je/4294967296|0,je%=4294967296);T&&(T=o(gs(je,on)),v=T.next().value,T=T.next().value,je=v,on=T)}return new ho(je,on)}var fo;function ki(v,T){return Error("Invalid wire type: "+v+" (at position "+T+")")}function po(){return Error("Failed to read varint, encoding is invalid.")}function pa(v,T){return Error("Tried to read past the end of the data "+T+" > "+v)}function Ur(){throw Error("Invalid UTF8")}function Pl(v,T){return T=String.fromCharCode.apply(null,T),v==null?T:v+T}var xr=void 0,Ze,br=typeof TextDecoder<"u",An,mc=typeof TextEncoder<"u",mo;function St(v){if(v!==yr)throw Error("illegal external caller")}function It(v,T){if(St(T),this.V=v,v!=null&&v.length===0)throw Error("ByteString should be constructed with non-empty values")}function Wt(){return mo||(mo=new It(null,yr))}function Xe(v){St(yr);var T=v.V;return T=T==null||bt&&T!=null&&T instanceof Uint8Array?T:typeof T=="string"?ve(T):null,T==null?T:v.V=T}function ge(v){if(typeof v=="string")return{buffer:ve(v),C:!1};if(Array.isArray(v))return{buffer:new Uint8Array(v),C:!1};if(v.constructor===Uint8Array)return{buffer:v,C:!1};if(v.constructor===ArrayBuffer)return{buffer:new Uint8Array(v),C:!1};if(v.constructor===It)return{buffer:Xe(v)||Vr(),C:!0};if(v instanceof Uint8Array)return{buffer:new Uint8Array(v.buffer,v.byteOffset,v.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function We(v,T){this.i=null,this.m=!1,this.h=this.j=this.l=0,we(this,v,T)}function we(v,T,N){N=N===void 0?{}:N,v.S=N.S===void 0?!1:N.S,T&&(T=ge(T),v.i=T.buffer,v.m=T.C,v.l=0,v.j=v.i.length,v.h=v.l)}We.prototype.reset=function(){this.h=this.l};function nn(v,T){if(v.h=T,T>v.j)throw pa(v.j,T)}function Wn(v){var T=v.i,N=v.h,O=T[N++],W=O&127;if(O&128&&(O=T[N++],W|=(O&127)<<7,O&128&&(O=T[N++],W|=(O&127)<<14,O&128&&(O=T[N++],W|=(O&127)<<21,O&128&&(O=T[N++],W|=O<<28,O&128&&T[N++]&128&&T[N++]&128&&T[N++]&128&&T[N++]&128&&T[N++]&128)))))throw po();return nn(v,N),W}function Wr(v,T){if(0>T)throw Error("Tried to read a negative byte length: "+T);var N=v.h,O=N+T;if(O>v.j)throw pa(T,v.j-N);return v.h=O,N}var Dn=[];function Se(){this.h=[]}Se.prototype.length=function(){return this.h.length},Se.prototype.end=function(){var v=this.h;return this.h=[],v};function ke(v,T,N){for(;0<N||127<T;)v.h.push(T&127|128),T=(T>>>7|N<<25)>>>0,N>>>=7;v.h.push(T)}function Gn(v,T){for(;127<T;)v.h.push(T&127|128),T>>>=7;v.h.push(T)}function Is(v,T){if(Dn.length){var N=Dn.pop();we(N,v,T),v=N}else v=new We(v,T);this.h=v,this.j=this.h.h,this.i=this.l=-1,this.setOptions(T)}Is.prototype.setOptions=function(v){v=v===void 0?{}:v,this.ca=v.ca===void 0?!1:v.ca},Is.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};function ys(v){var T=v.h;if(T.h==T.j)return!1;v.j=v.h.h;var N=Wn(v.h)>>>0;if(T=N>>>3,N&=7,!(0<=N&&5>=N))throw ki(N,v.j);if(1>T)throw Error("Invalid field number: "+T+" (at position "+v.j+")");return v.l=T,v.i=N,!0}function ss(v){switch(v.i){case 0:if(v.i!=0)ss(v);else t:{v=v.h;for(var T=v.h,N=T+10,O=v.i;T<N;)if((O[T++]&128)===0){nn(v,T);break t}throw po()}break;case 1:v=v.h,nn(v,v.h+8);break;case 2:v.i!=2?ss(v):(T=Wn(v.h)>>>0,v=v.h,nn(v,v.h+T));break;case 5:v=v.h,nn(v,v.h+4);break;case 3:T=v.l;do{if(!ys(v))throw Error("Unmatched start-group tag: stream EOF");if(v.i==4){if(v.l!=T)throw Error("Unmatched end-group tag");break}ss(v)}while(!0);break;default:throw ki(v.i,v.j)}}var te=[];function Hn(){this.j=[],this.i=0,this.h=new Se}function _e(v,T){T.length!==0&&(v.j.push(T),v.i+=T.length)}function Je(v,T){if(T=T.R){_e(v,v.h.end());for(var N=0;N<T.length;N++)_e(v,Xe(T[N])||Vr())}}var wn=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol():void 0;function Js(v,T){return wn?v[wn]|=T:v.A!==void 0?v.A|=T:(Object.defineProperties(v,{A:{value:T,configurable:!0,writable:!0,enumerable:!1}}),T)}function Fl(v,T){wn?v[wn]&&(v[wn]&=~T):v.A!==void 0&&(v.A&=~T)}function tn(v){var T;return wn?T=v[wn]:T=v.A,T??0}function xs(v,T){wn?v[wn]=T:v.A!==void 0?v.A=T:Object.defineProperties(v,{A:{value:T,configurable:!0,writable:!0,enumerable:!1}})}function Gr(v){return Js(v,1),v}function ii(v,T){xs(T,(v|0)&-51)}function rs(v,T){xs(T,(v|18)&-41)}var bs={};function vs(v){return v!==null&&typeof v=="object"&&!Array.isArray(v)&&v.constructor===Object}var ws,sn=[];xs(sn,23),ws=Object.freeze(sn);function _i(v){if(tn(v.o)&2)throw Error("Cannot mutate an immutable Message")}function As(v){var T=v.length;(T=T?v[T-1]:void 0)&&vs(T)?T.g=1:(T={},v.push((T.g=1,T)))}function jn(v){var T=v.i+v.G;return v.B||(v.B=v.o[T]={})}function Sn(v,T){return T===-1?null:T>=v.i?v.B?v.B[T]:void 0:v.o[T+v.G]}function Ds(v,T,N,O){_i(v),ma(v,T,N,O)}function ma(v,T,N,O){v.j&&(v.j=void 0),T>=v.i||O?jn(v)[T]=N:(v.o[T+v.G]=N,(v=v.B)&&T in v&&delete v[T])}function Ll(v,T,N,O){var W=Sn(v,T);Array.isArray(W)||(W=ws);var j=tn(W);if(j&1||Gr(W),O)j&2||Js(W,2),N&1||Object.freeze(W);else{O=!(N&2);var G=j&2;N&1||!G?O&&j&16&&!G&&Fl(W,16):(W=Gr(Array.prototype.slice.call(W)),ma(v,T,W))}return W}function gc(v,T){var N=Sn(v,T),O=N==null?N:typeof N=="number"||N==="NaN"||N==="Infinity"||N==="-Infinity"?Number(N):void 0;return O!=null&&O!==N&&ma(v,T,O),O}function go(v,T,N,O,W){v.h||(v.h={});var j=v.h[N],G=Ll(v,N,3,W);if(!j){var Z=G;j=[];var ot=!!(tn(v.o)&16);G=!!(tn(Z)&2);var vt=Z;!W&&G&&(Z=Array.prototype.slice.call(Z));for(var Nt=G,jt=0;jt<Z.length;jt++){var Bt=Z[jt],Dt=T,Gt=!1;if(Gt=Gt===void 0?!1:Gt,Bt=Array.isArray(Bt)?new Dt(Bt):Gt?new Dt:void 0,Bt!==void 0){Dt=Bt.o;var Zt=Gt=tn(Dt);G&&(Zt|=2),ot&&(Zt|=16),Zt!=Gt&&xs(Dt,Zt),Dt=Zt,Nt=Nt||!!(2&Dt),j.push(Bt)}}return v.h[N]=j,ot=tn(Z),T=ot|33,T=Nt?T&-9:T|8,ot!=T&&(Nt=Z,Object.isFrozen(Nt)&&(Nt=Array.prototype.slice.call(Nt)),xs(Nt,T),Z=Nt),vt!==Z&&ma(v,N,Z),(W||O&&G)&&Js(j,2),O&&Object.freeze(j),j}return W||(W=Object.isFrozen(j),O&&!W?Object.freeze(j):!O&&W&&(j=Array.prototype.slice.call(j),v.h[N]=j)),j}function ga(v,T,N){var O=!!(tn(v.o)&2);if(T=go(v,T,N,O,O),v=Ll(v,N,3,O),!(O||tn(v)&8)){for(O=0;O<T.length;O++){if(N=T[O],tn(N.o)&2){var W=bo(N,!1);W.j=N}else W=N;N!==W&&(T[O]=W,v[O]=W.o)}Js(v,8)}return T}function Cn(v,T,N){if(N!=null&&typeof N!="number")throw Error("Value of float/double field must be a number|null|undefined, found "+typeof N+": "+N);Ds(v,T,N)}function Ml(v,T,N,O,W){_i(v);var j=go(v,N,T,!1,!1);return N=O??new N,v=Ll(v,T,2,!1),W!=null?(j.splice(W,0,N),v.splice(W,0,N.o)):(j.push(N),v.push(N.o)),N.C()&&Fl(v,8),N}function yo(v,T){return v??T}function Xn(v,T,N){return N=N===void 0?0:N,yo(gc(v,T),N)}var ya;function yc(v){switch(typeof v){case"number":return isFinite(v)?v:String(v);case"object":if(v)if(Array.isArray(v)){if((tn(v)&128)!==0)return v=Array.prototype.slice.call(v),As(v),v}else{if(bt&&v!=null&&v instanceof Uint8Array)return Kt(v);if(v instanceof It){var T=v.V;return T==null?"":typeof T=="string"?T:v.V=Kt(T)}}}return v}function Dd(v,T,N,O){if(v!=null){if(Array.isArray(v))v=zl(v,T,N,O!==void 0);else if(vs(v)){var W={},j;for(j in v)W[j]=Dd(v[j],T,N,O);v=W}else v=T(v,O);return v}}function zl(v,T,N,O){var W=tn(v);O=O?!!(W&16):void 0,v=Array.prototype.slice.call(v);for(var j=0;j<v.length;j++)v[j]=Dd(v[j],T,N,O);return N(W,v),v}function Os(v){return v.ja===bs?v.toJSON():yc(v)}function Od(v,T){v&128&&As(T)}function Pd(v,T,N){if(N=N===void 0?rs:N,v!=null){if(bt&&v instanceof Uint8Array)return v.length?new It(new Uint8Array(v),yr):Wt();if(Array.isArray(v)){var O=tn(v);return O&2?v:T&&!(O&32)&&(O&16||O===0)?(xs(v,O|2),v):(v=zl(v,Pd,O&4?rs:N,!0),T=tn(v),T&4&&T&2&&Object.freeze(v),v)}return v.ja===bs?xc(v):v}}function xo(v,T,N,O,W,j,G){if(v=v.h&&v.h[N]){if(O=tn(v),O&2?O=v:(j=ct(v,xc),rs(O,j),Object.freeze(j),O=j),_i(T),G=O==null?ws:Gr([]),O!=null){for(j=!!O.length,v=0;v<O.length;v++){var Z=O[v];j=j&&!(tn(Z.o)&2),G[v]=Z.o}j=(j?8:0)|1,v=tn(G),(v&j)!==j&&(Object.isFrozen(G)&&(G=Array.prototype.slice.call(G)),xs(G,v|j)),T.h||(T.h={}),T.h[N]=O}else T.h&&(T.h[N]=void 0);ma(T,N,G,W)}else Ds(T,N,Pd(O,j,G),W)}function xc(v){return tn(v.o)&2||(v=bo(v,!0),Js(v.o,2)),v}function bo(v,T){var N=v.o,O=[];Js(O,16);var W=v.constructor.h;if(W&&O.push(W),W=v.B,W){O.length=N.length,O.fill(void 0,O.length,N.length);var j={};O[O.length-1]=j}(tn(N)&128)!==0&&As(O),T=T||v.C()?rs:ii,j=v.constructor,ya=O,O=new j(O),ya=void 0,v.R&&(O.R=v.R.slice()),j=!!(tn(N)&16);for(var G=W?N.length-1:N.length,Z=0;Z<G;Z++)xo(v,O,Z-v.G,N[Z],!1,j,T);if(W)for(var ot in W)xo(v,O,+ot,W[ot],!0,j,T);return O}function is(v,T,N){v==null&&(v=ya),ya=void 0;var O=this.constructor.i||0,W=0<O,j=this.constructor.h,G=!1;if(v==null){v=j?[j]:[];var Z=48,ot=!0;W&&(O=0,Z|=128),xs(v,Z)}else{if(!Array.isArray(v)||j&&j!==v[0])throw Error();var vt=Z=Js(v,0);if((ot=(16&vt)!==0)&&((G=(32&vt)!==0)||(vt|=32)),W){if(128&vt)O=0;else if(0<v.length){var Nt=v[v.length-1];if(vs(Nt)&&"g"in Nt){O=0,vt|=128,delete Nt.g;var jt=!0,Bt;for(Bt in Nt){jt=!1;break}jt&&v.pop()}}}else if(128&vt)throw Error();Z!==vt&&xs(v,vt)}this.G=(j?0:-1)-O,this.h=void 0,this.o=v;t:{if(j=this.o.length,O=j-1,j&&(j=this.o[O],vs(j))){this.B=j,this.i=O-this.G;break t}T!==void 0&&-1<T?(this.i=Math.max(T,O+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE}if(!W&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(N){T=ot&&!G&&!0,W=this.i;var Dt;for(ot=0;ot<N.length;ot++)G=N[ot],G<W?(G+=this.G,(O=v[G])?Ss(O,T):v[G]=ws):(Dt||(Dt=jn(this)),(O=Dt[G])?Ss(O,T):Dt[G]=ws)}}is.prototype.toJSON=function(){return zl(this.o,Os,Od)},is.prototype.C=function(){return!!(tn(this.o)&2)};function Ss(v,T){if(Array.isArray(v)){var N=tn(v),O=1;!T||N&2||(O|=16),(N&O)!==O&&xs(v,N|O)}}is.prototype.ja=bs,is.prototype.toString=function(){return this.o.toString()};function Bl(v,T,N){if(N){var O={},W;for(W in N){var j=N[W],G=j.ra;G||(O.J=j.xa||j.oa.W,j.ia?(O.aa=bc(j.ia),G=(function(Z){return function(ot,vt,Nt){return Z.J(ot,vt,Nt,Z.aa)}})(O)):j.ka?(O.Z=Ul(j.da.P,j.ka),G=(function(Z){return function(ot,vt,Nt){return Z.J(ot,vt,Nt,Z.Z)}})(O)):G=O.J,j.ra=G),G(T,v,j.da),O={J:O.J,aa:O.aa,Z:O.Z}}}Je(T,v)}var vo=Symbol();function Vl(v,T,N){return v[vo]||(v[vo]=function(O,W){return T(O,W,N)})}function Ni(v){var T=v[vo];if(!T){var N=tr(v);T=function(O,W){return Gl(O,W,N)},v[vo]=T}return T}function Fd(v){var T=v.ia;if(T)return Ni(T);if(T=v.wa)return Vl(v.da.P,T,v.ka)}function Ld(v){var T=Fd(v),N=v.da,O=v.oa.U;return T?function(W,j){return O(W,j,N,T)}:function(W,j){return O(W,j,N)}}function Ei(v,T){var N=v[T];return typeof N=="function"&&N.length===0&&(N=N(),v[T]=N),Array.isArray(N)&&(vr in N||So in N||0<N.length&&typeof N[0]=="function")?N:void 0}function Md(v,T,N,O,W,j){T.P=v[0];var G=1;if(v.length>G&&typeof v[G]!="number"){var Z=v[G++];N(T,Z)}for(;G<v.length;){N=v[G++];for(var ot=G+1;ot<v.length&&typeof v[ot]!="number";)ot++;switch(Z=v[G++],ot-=G,ot){case 0:O(T,N,Z);break;case 1:(ot=Ei(v,G))?(G++,W(T,N,Z,ot)):O(T,N,Z,v[G++]);break;case 2:ot=G++,ot=Ei(v,ot),W(T,N,Z,ot,v[G++]);break;case 3:j(T,N,Z,v[G++],v[G++],v[G++]);break;case 4:j(T,N,Z,v[G++],v[G++],v[G++],v[G++]);break;default:throw Error("unexpected number of binary field arguments: "+ot)}}return T}var wo=Symbol();function bc(v){var T=v[wo];if(!T){var N=ai(v);T=function(O,W){return xa(O,W,N)},v[wo]=T}return T}function Ul(v,T){var N=v[wo];return N||(N=function(O,W){return Bl(O,W,T)},v[wo]=N),N}var So=Symbol();function Gm(v,T){v.push(T)}function Wl(v,T,N){v.push(T,N.W)}function vc(v,T,N,O){var W=bc(O),j=ai(O).P,G=N.W;v.push(T,function(Z,ot,vt){return G(Z,ot,vt,j,W)})}function wc(v,T,N,O,W,j){var G=Ul(O,j),Z=N.W;v.push(T,function(ot,vt,Nt){return Z(ot,vt,Nt,O,G)})}function ai(v){var T=v[So];return T||(T=Md(v,v[So]=[],Gm,Wl,vc,wc),vr in v&&So in v&&(v.length=0),T)}var vr=Symbol();function zd(v,T){v[0]=T}function Sc(v,T,N,O){var W=N.U;v[T]=O?function(j,G,Z){return W(j,G,Z,O)}:W}function Bd(v,T,N,O,W){var j=N.U,G=Ni(O),Z=tr(O).P;v[T]=function(ot,vt,Nt){return j(ot,vt,Nt,Z,G,W)}}function Co(v,T,N,O,W,j,G){var Z=N.U,ot=Vl(O,W,j);v[T]=function(vt,Nt,jt){return Z(vt,Nt,jt,O,ot,G)}}function tr(v){var T=v[vr];return T||(T=Md(v,v[vr]={},zd,Sc,Bd,Co),vr in v&&So in v&&(v.length=0),T)}function Gl(v,T,N){for(;ys(T)&&T.i!=4;){var O=T.l,W=N[O];if(!W){var j=N[0];j&&(j=j[O])&&(W=N[O]=Ld(j))}if(!W||!W(T,v,O)){W=T,O=v,j=W.j,ss(W);var G=W;if(!G.ca){if(W=G.h.h-j,G.h.h=j,G=G.h,W==0)W=Wt();else{if(j=Wr(G,W),G.S&&G.m)W=G.i.subarray(j,j+W);else{G=G.i;var Z=j;W=j+W,W=Z===W?Vr():fa?G.slice(Z,W):new Uint8Array(G.subarray(Z,W))}W=W.length==0?Wt():new It(W,yr)}(j=O.R)?j.push(W):O.R=[W]}}}return v}function xa(v,T,N){for(var O=N.length,W=O%2==1,j=W?1:0;j<O;j+=2)(0,N[j+1])(T,v,N[j]);Bl(v,T,W?N[0]:void 0)}function Ps(v,T){return{U:v,W:T}}var Cs=Ps(function(v,T,N){if(v.i!==5)return!1;v=v.h;var O=v.i,W=v.h,j=O[W],G=O[W+1],Z=O[W+2];return O=O[W+3],nn(v,v.h+4),G=(j<<0|G<<8|Z<<16|O<<24)>>>0,v=2*(G>>31)+1,j=G>>>23&255,G&=8388607,Ds(T,N,j==255?G?NaN:1/0*v:j==0?v*Math.pow(2,-149)*G:v*Math.pow(2,j-150)*(G+Math.pow(2,23))),!0},function(v,T,N){if(T=gc(T,N),T!=null){Gn(v.h,8*N+5),v=v.h;var O=+T;O===0?0<1/O?je=on=0:(on=0,je=2147483648):isNaN(O)?(on=0,je=2147483647):(O=(N=0>O?-2147483648:0)?-O:O,34028234663852886e22<O?(on=0,je=(N|2139095040)>>>0):11754943508222875e-54>O?(O=Math.round(O/Math.pow(2,-149)),on=0,je=(N|O)>>>0):(T=Math.floor(Math.log(O)/Math.LN2),O*=Math.pow(2,-T),O=Math.round(8388608*O),16777216<=O&&++T,on=0,je=(N|T+127<<23|O&8388607)>>>0)),N=je,v.h.push(N>>>0&255),v.h.push(N>>>8&255),v.h.push(N>>>16&255),v.h.push(N>>>24&255)}}),Hl=Ps(function(v,T,N){if(v.i!==0)return!1;var O=v.h,W=0,j=v=0,G=O.i,Z=O.h;do{var ot=G[Z++];W|=(ot&127)<<j,j+=7}while(32>j&&ot&128);for(32<j&&(v|=(ot&127)>>4),j=3;32>j&&ot&128;j+=7)ot=G[Z++],v|=(ot&127)<<j;if(nn(O,Z),128>ot)O=W>>>0,ot=v>>>0,(v=ot&2147483648)&&(O=~O+1>>>0,ot=~ot>>>0,O==0&&(ot=ot+1>>>0)),O=4294967296*ot+(O>>>0);else throw po();return Ds(T,N,v?-O:O),!0},function(v,T,N){T=Sn(T,N),T!=null&&(typeof T=="string"&&Ti(T),T!=null&&(Gn(v.h,8*N),typeof T=="number"?(v=v.h,co(T),ke(v,je,on)):(N=Ti(T),ke(v.h,N.i,N.h))))}),Vd=Ps(function(v,T,N){return v.i!==0?!1:(Ds(T,N,Wn(v.h)),!0)},function(v,T,N){if(T=Sn(T,N),T!=null&&T!=null)if(Gn(v.h,8*N),v=v.h,N=T,0<=N)Gn(v,N);else{for(T=0;9>T;T++)v.h.push(N&127|128),N>>=7;v.h.push(1)}}),$o=Ps(function(v,T,N){if(v.i!==2)return!1;var O=Wn(v.h)>>>0;v=v.h;var W=Wr(v,O);if(v=v.i,br){var j=v,G;(G=Ze)||(G=Ze=new TextDecoder("utf-8",{fatal:!0})),v=W+O,j=W===0&&v===j.length?j:j.subarray(W,v);try{var Z=G.decode(j)}catch(jt){if(xr===void 0){try{G.decode(new Uint8Array([128]))}catch{}try{G.decode(new Uint8Array([97])),xr=!0}catch{xr=!1}}throw!xr&&(Ze=void 0),jt}}else{Z=W,O=Z+O,W=[];for(var ot=null,vt,Nt;Z<O;)vt=v[Z++],128>vt?W.push(vt):224>vt?Z>=O?Ur():(Nt=v[Z++],194>vt||(Nt&192)!==128?(Z--,Ur()):W.push((vt&31)<<6|Nt&63)):240>vt?Z>=O-1?Ur():(Nt=v[Z++],(Nt&192)!==128||vt===224&&160>Nt||vt===237&&160<=Nt||((j=v[Z++])&192)!==128?(Z--,Ur()):W.push((vt&15)<<12|(Nt&63)<<6|j&63)):244>=vt?Z>=O-2?Ur():(Nt=v[Z++],(Nt&192)!==128||(vt<<28)+(Nt-144)>>30!==0||((j=v[Z++])&192)!==128||((G=v[Z++])&192)!==128?(Z--,Ur()):(vt=(vt&7)<<18|(Nt&63)<<12|(j&63)<<6|G&63,vt-=65536,W.push((vt>>10&1023)+55296,(vt&1023)+56320))):Ur(),8192<=W.length&&(ot=Pl(ot,W),W.length=0);Z=Pl(ot,W)}return Ds(T,N,Z),!0},function(v,T,N){if(T=Sn(T,N),T!=null){var O=!1;if(O=O===void 0?!1:O,mc){if(O&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(T))throw Error("Found an unpaired surrogate");T=(An||(An=new TextEncoder)).encode(T)}else{for(var W=0,j=new Uint8Array(3*T.length),G=0;G<T.length;G++){var Z=T.charCodeAt(G);if(128>Z)j[W++]=Z;else{if(2048>Z)j[W++]=Z>>6|192;else{if(55296<=Z&&57343>=Z){if(56319>=Z&&G<T.length){var ot=T.charCodeAt(++G);if(56320<=ot&&57343>=ot){Z=1024*(Z-55296)+ot-56320+65536,j[W++]=Z>>18|240,j[W++]=Z>>12&63|128,j[W++]=Z>>6&63|128,j[W++]=Z&63|128;continue}else G--}if(O)throw Error("Found an unpaired surrogate");Z=65533}j[W++]=Z>>12|224,j[W++]=Z>>6&63|128}j[W++]=Z&63|128}}T=W===j.length?j:j.subarray(0,W)}Gn(v.h,8*N+2),Gn(v.h,T.length),_e(v,v.h.end()),_e(v,T)}}),To=Ps(function(v,T,N,O,W){if(v.i!==2)return!1;T=Ml(T,N,O),N=v.h.j,O=Wn(v.h)>>>0;var j=v.h.h+O,G=j-N;if(0>=G&&(v.h.j=j,W(T,v,void 0,void 0,void 0),G=j-v.h.h),G)throw Error("Message parsing ended unexpectedly. Expected to read "+(O+" bytes, instead read "+(O-G)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return v.h.h=j,v.h.j=N,!0},function(v,T,N,O,W){if(T=ga(T,O,N),T!=null)for(O=0;O<T.length;O++){var j=v;Gn(j.h,8*N+2);var G=j.h.end();_e(j,G),G.push(j.i),j=G,W(T[O],v),G=v;var Z=j.pop();for(Z=G.i+G.h.length()-Z;127<Z;)j.push(Z&127|128),Z>>>=7,G.i++;j.push(Z),G.i++}});function jl(v){return function(T,N){t:{if(te.length){var O=te.pop();O.setOptions(N),we(O.h,T,N),T=O}else T=new Is(T,N);try{var W=tr(v),j=Gl(new W.P,T,W);break t}finally{W=T.h,W.i=null,W.m=!1,W.l=0,W.j=0,W.h=0,W.S=!1,T.l=-1,T.i=-1,100>te.length&&te.push(T)}j=void 0}return j}}function On(v){return function(){var T=new Hn;xa(this,T,ai(v)),_e(T,T.h.end());for(var N=new Uint8Array(T.i),O=T.j,W=O.length,j=0,G=0;G<W;G++){var Z=O[G];N.set(Z,j),j+=Z.length}return T.j=[N],N}}function Fs(v){is.call(this,v)}S(Fs,is);var ko=[Fs,1,Vd,2,Cs,3,$o,4,$o];Fs.prototype.l=On(ko);function Ri(v){is.call(this,v,-1,Hm)}S(Ri,is),Ri.prototype.addClassification=function(v,T){return Ml(this,1,Fs,v,T),this};var Hm=[1],Cc=jl([Ri,1,To,ko]);function Ii(v){is.call(this,v)}S(Ii,is);var ba=[Ii,1,Cs,2,Cs,3,Cs,4,Cs,5,Cs];Ii.prototype.l=On(ba);function _o(v){is.call(this,v,-1,Ud)}S(_o,is);var Ud=[1],jm=jl([_o,1,To,ba]);function Xl(v){is.call(this,v)}S(Xl,is);var Wd=[Xl,1,Cs,2,Cs,3,Cs,4,Cs,5,Cs,6,Hl],$c=jl(Wd);Xl.prototype.l=On(Wd);function Gd(v,T,N){if(N=v.createShader(N===0?v.VERTEX_SHADER:v.FRAGMENT_SHADER),v.shaderSource(N,T),v.compileShader(N),!v.getShaderParameter(N,v.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+v.getShaderInfoLog(N));return N}function Xm(v){return ga(v,Fs,1).map(function(T){var N=Sn(T,1);return{index:N??0,qa:Xn(T,2),label:Sn(T,3)!=null?yo(Sn(T,3),""):void 0,displayName:Sn(T,4)!=null?yo(Sn(T,4),""):void 0}})}function qm(v){return{x:Xn(v,1),y:Xn(v,2),z:Xn(v,3),visibility:gc(v,4)!=null?Xn(v,4):void 0}}function Tc(v){return ga(jm(v),Ii,1).map(qm)}function kc(v,T){this.i=v,this.h=T,this.m=0}function _c(v,T,N){return Km(v,T),typeof v.h.canvas.transferToImageBitmap=="function"?Promise.resolve(v.h.canvas.transferToImageBitmap()):N?Promise.resolve(v.h.canvas):typeof createImageBitmap=="function"?createImageBitmap(v.h.canvas):(v.j===void 0&&(v.j=document.createElement("canvas")),new Promise(function(O){v.j.height=v.h.canvas.height,v.j.width=v.h.canvas.width,v.j.getContext("2d",{}).drawImage(v.h.canvas,0,0,v.h.canvas.width,v.h.canvas.height),O(v.j)}))}function Km(v,T){var N=v.h;if(v.s===void 0){var O=Gd(N,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),W=Gd(N,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),j=N.createProgram();if(N.attachShader(j,O),N.attachShader(j,W),N.linkProgram(j),!N.getProgramParameter(j,N.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+N.getProgramInfoLog(j));O=v.s=j,N.useProgram(O),W=N.getUniformLocation(O,"sampler0"),v.l={O:N.getAttribLocation(O,"aVertex"),N:N.getAttribLocation(O,"aTex"),ya:W},v.v=N.createBuffer(),N.bindBuffer(N.ARRAY_BUFFER,v.v),N.enableVertexAttribArray(v.l.O),N.vertexAttribPointer(v.l.O,2,N.FLOAT,!1,0,0),N.bufferData(N.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),N.STATIC_DRAW),N.bindBuffer(N.ARRAY_BUFFER,null),v.u=N.createBuffer(),N.bindBuffer(N.ARRAY_BUFFER,v.u),N.enableVertexAttribArray(v.l.N),N.vertexAttribPointer(v.l.N,2,N.FLOAT,!1,0,0),N.bufferData(N.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),N.STATIC_DRAW),N.bindBuffer(N.ARRAY_BUFFER,null),N.uniform1i(W,0)}O=v.l,N.useProgram(v.s),N.canvas.width=T.width,N.canvas.height=T.height,N.viewport(0,0,T.width,T.height),N.activeTexture(N.TEXTURE0),v.i.bindTexture2d(T.glName),N.enableVertexAttribArray(O.O),N.bindBuffer(N.ARRAY_BUFFER,v.v),N.vertexAttribPointer(O.O,2,N.FLOAT,!1,0,0),N.enableVertexAttribArray(O.N),N.bindBuffer(N.ARRAY_BUFFER,v.u),N.vertexAttribPointer(O.N,2,N.FLOAT,!1,0,0),N.bindFramebuffer(N.DRAW_FRAMEBUFFER?N.DRAW_FRAMEBUFFER:N.FRAMEBUFFER,null),N.clearColor(0,0,0,0),N.clear(N.COLOR_BUFFER_BIT),N.colorMask(!0,!0,!0,!0),N.drawArrays(N.TRIANGLE_FAN,0,4),N.disableVertexAttribArray(O.O),N.disableVertexAttribArray(O.N),N.bindBuffer(N.ARRAY_BUFFER,null),v.i.bindTexture2d(0)}function Ym(v){this.h=v}var Qm=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function Zm(v,T){return T+v}function ql(v,T){window[v]=T}function Jm(v){var T=document.createElement("script");return T.setAttribute("src",v),T.setAttribute("crossorigin","anonymous"),new Promise(function(N){T.addEventListener("load",function(){N()},!1),T.addEventListener("error",function(){N()},!1),document.body.appendChild(T)})}function tg(){return D(function(v){switch(v.h){case 1:return v.s=2,R(v,WebAssembly.instantiate(Qm),4);case 4:v.h=3,v.s=0;break;case 2:return v.s=0,v.l=null,v.return(!1);case 3:return v.return(!0)}})}function Nc(v){if(this.h=v,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=v&&v.locateFile||Zm,typeof window=="object")var T=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")T=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.ha=T,v.options){T=o(Object.keys(v.options));for(var N=T.next();!N.done;N=T.next()){N=N.value;var O=v.options[N].default;O!==void 0&&(this.l[N]=typeof O=="function"?O():O)}}}n=Nc.prototype,n.close=function(){return this.j&&this.j.delete(),Promise.resolve()};function Hd(v){var T,N,O,W,j,G,Z,ot,vt,Nt,jt;return D(function(Bt){switch(Bt.h){case 1:return v.ga?(T=v.h.files===void 0?[]:typeof v.h.files=="function"?v.h.files(v.l):v.h.files,R(Bt,tg(),2)):Bt.return();case 2:if(N=Bt.i,typeof window=="object")return ql("createMediapipeSolutionsWasm",{locateFile:v.locateFile}),ql("createMediapipeSolutionsPackedAssets",{locateFile:v.locateFile}),G=T.filter(function(Dt){return Dt.data!==void 0}),Z=T.filter(function(Dt){return Dt.data===void 0}),ot=Promise.all(G.map(function(Dt){var Gt=Kl(v,Dt.url);if(Dt.path!==void 0){var Zt=Dt.path;Gt=Gt.then(function(Ce){return v.overrideFile(Zt,Ce),Promise.resolve(Ce)})}return Gt})),vt=Promise.all(Z.map(function(Dt){return Dt.simd===void 0||Dt.simd&&N||!Dt.simd&&!N?Jm(v.locateFile(Dt.url,v.ha)):Promise.resolve()})).then(function(){var Dt,Gt,Zt;return D(function(Ce){if(Ce.h==1)return Dt=window.createMediapipeSolutionsWasm,Gt=window.createMediapipeSolutionsPackedAssets,Zt=v,R(Ce,Dt(Gt),2);Zt.i=Ce.i,Ce.h=0})}),Nt=(function(){return D(function(Dt){return v.h.graph&&v.h.graph.url?Dt=R(Dt,Kl(v,v.h.graph.url),0):(Dt.h=0,Dt=void 0),Dt})})(),R(Bt,Promise.all([vt,ot,Nt]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return O=T.filter(function(Dt){return Dt.simd===void 0||Dt.simd&&N||!Dt.simd&&!N}).map(function(Dt){return v.locateFile(Dt.url,v.ha)}),importScripts.apply(null,u(O)),W=v,R(Bt,createMediapipeSolutionsWasm(Module),6);case 6:W.i=Bt.i,v.m=new OffscreenCanvas(1,1),v.i.canvas=v.m,j=v.i.GL.createContext(v.m,{antialias:!1,alpha:!1,va:typeof WebGL2RenderingContext<"u"?2:1}),v.i.GL.makeContextCurrent(j),Bt.h=4;break;case 7:if(v.m=document.createElement("canvas"),jt=v.m.getContext("webgl2",{}),!jt&&(jt=v.m.getContext("webgl",{}),!jt))return alert("Failed to create WebGL canvas context when passing video frame."),Bt.return();v.K=jt,v.i.canvas=v.m,v.i.createContext(v.m,!0,!0,{});case 4:v.j=new v.i.SolutionWasm,v.ga=!1,Bt.h=0}})}function eg(v){var T,N,O,W,j,G,Z,ot;return D(function(vt){if(vt.h==1){if(v.h.graph&&v.h.graph.url&&v.fa===v.h.graph.url)return vt.return();if(v.u=!0,!v.h.graph||!v.h.graph.url){vt.h=2;return}return v.fa=v.h.graph.url,R(vt,Kl(v,v.h.graph.url),3)}for(vt.h!=2&&(T=vt.i,v.j.loadGraph(T)),N=o(Object.keys(v.D)),O=N.next();!O.done;O=N.next())W=O.value,v.j.overrideFile(W,v.D[W]);if(v.D={},v.h.listeners)for(j=o(v.h.listeners),G=j.next();!G.done;G=j.next())Z=G.value,ig(v,Z);ot=v.l,v.l={},v.setOptions(ot),vt.h=0})}n.reset=function(){var v=this;return D(function(T){v.j&&(v.j.reset(),v.s={},v.v={}),T.h=0})},n.setOptions=function(v,T){var N=this;if(T=T||this.h.options){for(var O=[],W=[],j={},G=o(Object.keys(v)),Z=G.next();!Z.done;j={X:j.X,Y:j.Y},Z=G.next())if(Z=Z.value,!(Z in this.l&&this.l[Z]===v[Z])){this.l[Z]=v[Z];var ot=T[Z];ot!==void 0&&(ot.onChange&&(j.X=ot.onChange,j.Y=v[Z],O.push((function(vt){return function(){var Nt;return D(function(jt){if(jt.h==1)return R(jt,vt.X(vt.Y),2);Nt=jt.i,Nt===!0&&(N.u=!0),jt.h=0})}})(j))),ot.graphOptionXref&&(Z=Object.assign({},{calculatorName:"",calculatorIndex:0},ot.graphOptionXref,{valueNumber:ot.type===1?v[Z]:0,valueBoolean:ot.type===0?v[Z]:!1,valueString:ot.type===2?v[Z]:""}),W.push(Z)))}(O.length!==0||W.length!==0)&&(this.u=!0,this.H=(this.H===void 0?[]:this.H).concat(W),this.F=(this.F===void 0?[]:this.F).concat(O))}};function ng(v){var T,N,O,W,j,G,Z;return D(function(ot){switch(ot.h){case 1:if(!v.u)return ot.return();if(!v.F){ot.h=2;break}T=o(v.F),N=T.next();case 3:if(N.done){ot.h=5;break}return O=N.value,R(ot,O(),4);case 4:N=T.next(),ot.h=3;break;case 5:v.F=void 0;case 2:if(v.H){for(W=new v.i.GraphOptionChangeRequestList,j=o(v.H),G=j.next();!G.done;G=j.next())Z=G.value,W.push_back(Z);v.j.changeOptions(W),W.delete(),v.H=void 0}v.u=!1,ot.h=0}})}n.initialize=function(){var v=this;return D(function(T){return T.h==1?R(T,Hd(v),2):T.h!=3?R(T,eg(v),3):R(T,ng(v),0)})};function Kl(v,T){var N,O;return D(function(W){return T in v.L?W.return(v.L[T]):(N=v.locateFile(T,""),O=fetch(N).then(function(j){return j.arrayBuffer()}),v.L[T]=O,W.return(O))})}n.overrideFile=function(v,T){this.j?this.j.overrideFile(v,T):this.D[v]=T},n.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},n.send=function(v,T){var N=this,O,W,j,G,Z,ot,vt,Nt,jt;return D(function(Bt){switch(Bt.h){case 1:return N.h.inputs?(O=1e3*(T??performance.now()),R(Bt,N.I,2)):Bt.return();case 2:return R(Bt,N.initialize(),3);case 3:for(W=new N.i.PacketDataList,j=o(Object.keys(v)),G=j.next();!G.done;G=j.next())if(Z=G.value,ot=N.h.inputs[Z]){t:{var Dt=v[Z];switch(ot.type){case"video":var Gt=N.s[ot.stream];if(Gt||(Gt=new kc(N.i,N.K),N.s[ot.stream]=Gt),Gt.m===0&&(Gt.m=Gt.i.createTexture()),typeof HTMLVideoElement<"u"&&Dt instanceof HTMLVideoElement)var Zt=Dt.videoWidth,Ce=Dt.videoHeight;else typeof HTMLImageElement<"u"&&Dt instanceof HTMLImageElement?(Zt=Dt.naturalWidth,Ce=Dt.naturalHeight):(Zt=Dt.width,Ce=Dt.height);Ce={glName:Gt.m,width:Zt,height:Ce},Zt=Gt.h,Zt.canvas.width=Ce.width,Zt.canvas.height=Ce.height,Zt.activeTexture(Zt.TEXTURE0),Gt.i.bindTexture2d(Gt.m),Zt.texImage2D(Zt.TEXTURE_2D,0,Zt.RGBA,Zt.RGBA,Zt.UNSIGNED_BYTE,Dt),Gt.i.bindTexture2d(0),Gt=Ce;break t;case"detections":for(Gt=N.s[ot.stream],Gt||(Gt=new Ym(N.i),N.s[ot.stream]=Gt),Gt.data||(Gt.data=new Gt.h.DetectionListData),Gt.data.reset(Dt.length),Ce=0;Ce<Dt.length;++Ce){Zt=Dt[Ce];var Le=Gt.data,dn=Le.setBoundingBox,$s=Ce,qn=Zt.la,he=new Xl;if(Cn(he,1,qn.sa),Cn(he,2,qn.ta),Cn(he,3,qn.height),Cn(he,4,qn.width),Cn(he,5,qn.rotation),Ds(he,6,qn.pa),qn=he.l(),dn.call(Le,$s,qn),Zt.ea)for(Le=0;Le<Zt.ea.length;++Le){he=Zt.ea[Le],dn=Gt.data,$s=dn.addNormalizedLandmark,qn=Ce,he=Object.assign({},he,{visibility:he.visibility?he.visibility:0});var gn=new Ii;Cn(gn,1,he.x),Cn(gn,2,he.y),Cn(gn,3,he.z),he.visibility&&Cn(gn,4,he.visibility),he=gn.l(),$s.call(dn,qn,he)}if(Zt.ba)for(Le=0;Le<Zt.ba.length;++Le)dn=Gt.data,$s=dn.addClassification,qn=Ce,he=Zt.ba[Le],gn=new Fs,Cn(gn,2,he.qa),he.index&&Ds(gn,1,he.index),he.label&&Ds(gn,3,he.label),he.displayName&&Ds(gn,4,he.displayName),he=gn.l(),$s.call(dn,qn,he)}Gt=Gt.data;break t;default:Gt={}}}switch(vt=Gt,Nt=ot.stream,ot.type){case"video":W.pushTexture2d(Object.assign({},vt,{stream:Nt,timestamp:O}));break;case"detections":jt=vt,jt.stream=Nt,jt.timestamp=O,W.pushDetectionList(jt);break;default:throw Error("Unknown input config type: '"+ot.type+"'")}}return N.j.send(W),R(Bt,N.I,4);case 4:W.delete(),Bt.h=0}})};function sg(v,T,N){var O,W,j,G,Z,ot,vt,Nt,jt,Bt,Dt,Gt,Zt,Ce;return D(function(Le){switch(Le.h){case 1:if(!N)return Le.return(T);for(O={},W=0,j=o(Object.keys(N)),G=j.next();!G.done;G=j.next())Z=G.value,ot=N[Z],typeof ot!="string"&&ot.type==="texture"&&T[ot.stream]!==void 0&&++W;1<W&&(v.M=!1),vt=o(Object.keys(N)),G=vt.next();case 2:if(G.done){Le.h=4;break}if(Nt=G.value,jt=N[Nt],typeof jt=="string")return Zt=O,Ce=Nt,R(Le,rg(v,Nt,T[jt]),14);if(Bt=T[jt.stream],jt.type==="detection_list"){if(Bt){for(var dn=Bt.getRectList(),$s=Bt.getLandmarksList(),qn=Bt.getClassificationsList(),he=[],gn=0;gn<dn.size();++gn){var Hr=$c(dn.get(gn)),qd=Xn(Hr,1),Kd=Xn(Hr,2),ag=Xn(Hr,3),og=Xn(Hr,4),lg=Xn(Hr,5,0),Yl=void 0;Yl=Yl===void 0?0:Yl,Hr={la:{sa:qd,ta:Kd,height:ag,width:og,rotation:lg,pa:yo(Sn(Hr,6),Yl)},ea:Tc($s.get(gn)),ba:Xm(Cc(qn.get(gn)))},he.push(Hr)}dn=he}else dn=[];O[Nt]=dn,Le.h=7;break}if(jt.type==="proto_list"){if(Bt){for(dn=Array(Bt.size()),$s=0;$s<Bt.size();$s++)dn[$s]=Bt.get($s);Bt.delete()}else dn=[];O[Nt]=dn,Le.h=7;break}if(Bt===void 0){Le.h=3;break}if(jt.type==="float_list"){O[Nt]=Bt,Le.h=7;break}if(jt.type==="proto"){O[Nt]=Bt,Le.h=7;break}if(jt.type!=="texture")throw Error("Unknown output config type: '"+jt.type+"'");return Dt=v.v[Nt],Dt||(Dt=new kc(v.i,v.K),v.v[Nt]=Dt),R(Le,_c(Dt,Bt,v.M),13);case 13:Gt=Le.i,O[Nt]=Gt;case 7:jt.transform&&O[Nt]&&(O[Nt]=jt.transform(O[Nt])),Le.h=3;break;case 14:Zt[Ce]=Le.i;case 3:G=vt.next(),Le.h=2;break;case 4:return Le.return(O)}})}function rg(v,T,N){var O;return D(function(W){return typeof N=="number"||N instanceof Uint8Array||N instanceof v.i.Uint8BlobList?W.return(N):N instanceof v.i.Texture2dDataOut?(O=v.v[T],O||(O=new kc(v.i,v.K),v.v[T]=O),W.return(_c(O,N,v.M))):W.return(void 0)})}function ig(v,T){for(var N=T.name||"$",O=[].concat(u(T.wants)),W=new v.i.StringList,j=o(T.wants),G=j.next();!G.done;G=j.next())W.push_back(G.value);j=v.i.PacketListener.implement({onResults:function(Z){for(var ot={},vt=0;vt<T.wants.length;++vt)ot[O[vt]]=Z.get(vt);var Nt=v.listeners[N];Nt&&(v.I=sg(v,ot,T.outs).then(function(jt){jt=Nt(jt);for(var Bt=0;Bt<T.wants.length;++Bt){var Dt=ot[O[Bt]];typeof Dt=="object"&&Dt.hasOwnProperty&&Dt.hasOwnProperty("delete")&&Dt.delete()}jt&&(v.I=jt)}))}}),v.j.attachMultiListener(W,j),W.delete()}n.onResults=function(v,T){this.listeners[T||"$"]=v},at("Solution",Nc),at("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"});function jd(v){switch(v===void 0&&(v=0),v){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function Xd(v){var T=this;v=v||{},this.h=new Nc({locateFile:v.locateFile,files:function(N){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:jd(N.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:Tc},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:Tc},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window!="object"||window.navigator===void 0?!1:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(N){var O,W,j;return D(function(G){return G.h==1?(O=jd(N),W="third_party/mediapipe/modules/pose_landmark/"+O,R(G,Kl(T.h,O),2)):(j=G.i,T.h.overrideFile(W,j),G.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}n=Xd.prototype,n.reset=function(){this.h.reset()},n.close=function(){return this.h.close(),Promise.resolve()},n.onResults=function(v){this.h.onResults(v)},n.initialize=function(){var v=this;return D(function(T){return R(T,v.h.initialize(),0)})},n.send=function(v,T){var N=this;return D(function(O){return R(O,N.h.send(v,T),0)})},n.setOptions=function(v){this.h.setOptions(v)},at("Pose",Xd),at("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),at("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),at("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),at("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),at("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),at("VERSION","0.5.1675469404")}).call(sx)),sx}var rO=sO();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iO=1e-7,aO=1e-4;class F_{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class L0{refCount(t){return Bs("refCount")}incRef(t){return Bs("incRef")}timerAvailable(){return!0}time(t){return Bs("time")}read(t){return Bs("read")}readSync(t){return Bs("readSync")}readToGPU(t,e){return Bs("readToGPU")}numDataIds(){return Bs("numDataIds")}disposeData(t,e){return Bs("disposeData")}write(t,e,s){return Bs("write")}move(t,e,s,r,i){return Bs("move")}createTensorFromGPUData(t,e,s){return Bs("createTensorFromGPUData")}memory(){return Bs("memory")}floatPrecision(){return Bs("floatPrecision")}epsilon(){return this.floatPrecision()===32?iO:aO}dispose(){return Bs("dispose")}}function Bs(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lp(n,t,e){return Math.max(n,Math.min(t,e))}function M0(n){return n%2===0?n:n+1}function gh(n,t,e){const s=n[t];n[t]=n[e],n[e]=s}function L_(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}function M(n,t){if(!n)throw new Error(typeof t=="string"?t:t())}function Ks(n,t,e=""){M(Ee(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function Yu(n){M(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function ht(n){if(n.length===0)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function d$(n){return n.length===0}function oO(n,t){if(n===t)return!0;if(n==null||t==null||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==null&&t[e]!==null&&n[e]!==t[e])return!1;return!0}function Ee(n,t){if(n===t)return!0;if(n==null||t==null||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function zu(n){return n%1===0}function Px(n){const t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function Ou(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function f$(n,t=r=>0,e,s){return new Promise((r,i)=>{let a=0;const o=()=>{if(n()){r();return}a++;const u=t(a);if(e!=null&&a>=e){i();return}s!=null?s(o,u):setTimeout(o,u)};o()})}function M_(n,t){let e=1,s=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)e*=n[i];else if(n[i]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${i}`);s=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(s===-1){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(e===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);const r=n.slice();return r[s]=t/e,r}function Qe(n,t){const e=t.length;return n=n==null?t.map((s,r)=>r):[].concat(n),M(n.every(s=>s>=-e&&s<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),M(n.every(s=>zu(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?e+s:s)}function ro(n,t){const e=[],s=[],r=t!=null&&Array.isArray(t)&&t.length===0,i=t==null||r?null:Qe(t,n).sort();let a=0;for(let o=0;o<n.length;++o){if(i!=null){if(i[a]===o&&n[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${n[o]}' is not 1`);(i[a]==null||i[a]>o)&&n[o]===1&&(e.push(n[o]),s.push(o)),i[a]<=o&&a++}n[o]!==1&&(e.push(n[o]),s.push(o))}return{newShape:e,keptDims:s}}function Si(n,t){return kn(n,t)}function kn(n,t){let e=null;if(n==null||n==="float32")e=new Float32Array(t);else if(n==="int32")e=new Int32Array(t);else if(n==="bool")e=new Uint8Array(t);else if(n==="string")e=new Array(t);else throw new Error(`Unknown data type ${n}`);return e}function lO(n,t){for(let e=0;e<n.length;e++){const s=n[e];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)}}function uO(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function z_(n,t){return!(t==="complex64"||t==="float32"&&n!=="complex64"||t==="int32"&&n!=="float32"&&n!=="complex64"||t==="bool"&&n==="bool")}function Mp(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function cO(n){if(n==null)return 0;let t=0;return n.forEach(e=>t+=e.length),t}function xd(n){return typeof n=="string"||n instanceof String}function hO(n){return typeof n=="boolean"}function dO(n){return typeof n=="number"}function Qu(n){return Array.isArray(n)?Qu(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":dO(n)?"float32":xd(n)?"string":hO(n)?"bool":"float32"}function Fx(n){return!!(n&&n.constructor&&n.call&&n.apply)}function Lx(n,t){for(let e=t;e<n;++e)if(n%e===0)return e;return n}function cn(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let s=t-3;s>=0;--s)e[s]=e[s+1]*n[s+1];return e}function B_(n,t,e,s=!1){const r=new Array;if(t.length===1){const i=t[0]*(s?2:1);for(let a=0;a<i;a++)r[a]=e[n+a]}else{const i=t[0],a=t.slice(1),o=a.reduce((u,h)=>u*h)*(s?2:1);for(let u=0;u<i;u++)r[u]=B_(n+u*o,a,e,s)}return r}function Mx(n,t,e=!1){if(n.length===0)return t[0];const s=n.reduce((r,i)=>r*i)*(e?2:1);if(s===0)return[];if(s!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return B_(0,n,t,e)}function rx(n,t){if(Array.isArray(n))return n;if(t==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(t==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${t}`)}function V_(n,t){const e=ta(n,t);for(let s=0;s<e.length;s++)e[s]=1;return e}function ta(n,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function pr(n){n.forEach(t=>{M(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function zx(n,t,e){if(t===0)return 0;if(t===1)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=e[r]*n[r];return s}function z0(n,t,e){if(t===0)return[];if(t===1)return[n];const s=new Array(t);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/e[r]),n-=s[r]*e[r];return s[s.length-1]=n,s}function dl(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p$="tfjsflags";class fO{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=pO,this.populateURLFlags()}setPlatform(t,e){this.platform!=null&&(tt().getBool("IS_TEST")||tt().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,s){if(this.flagRegistry[t]={evaluationFn:e,setHook:s},this.urlFlags[t]!=null){const r=this.urlFlags[t];tt().getBool("IS_TEST")||tt().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${r}.`),this.set(t,r)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(dl(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);p$ in t&&t[p$].split(",").forEach(s=>{const[r,i]=s.split(":");this.urlFlags[r]=gO(r,i)})}}function pO(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...s)=>(mO(t,s[0],s[1]),s.join("="))),t}function mO(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}function gO(n,t){const e=t.toLowerCase();return e==="true"||e==="false"?e==="true":`${+e}`===e?+e:t}function tt(){return U_}let U_=null;function yO(n){U_=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ix;function W_(){if(ix==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");ix=n}return ix}function xO(){const n=W_();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function B0(n,t){const e=xO();if(e.has(n))return e.get(n);{const s=t();return e.set(n,s),e.get(n)}}const V0="Abs",U0="Acos",W0="Acosh",pm="Add",G0="AddN",H0="All",j0="Any",X0="ArgMax",q0="ArgMin",K0="Asin",Y0="Asinh",Q0="Atan",Z0="Atanh",J0="Atan2",tb="AvgPool",G_="AvgPoolGrad",eb="AvgPool3D",H_="AvgPool3DGrad",nb="BatchMatMul",sb="BatchToSpaceND",rb="Bincount",j_="BitwiseAnd",ib="BroadcastArgs",mm="Cast",ab="Ceil",ob="ClipByValue",lb="Complex",ub="ComplexAbs",cb="Concat",hb="Conv2D",db="Conv2DBackpropFilter",fb="Conv2DBackpropInput",pb="Conv3D",X_="Conv3DBackpropFilterV2",mb="Conv3DBackpropInputV2",gb="Cos",yb="Cosh",xb="Cumprod",bb="Cumsum",vb="CropAndResize",wb="DenseBincount",Sb="DepthToSpace",Cb="DepthwiseConv2dNative",$b="DepthwiseConv2dNativeBackpropFilter",Tb="DepthwiseConv2dNativeBackpropInput",kb="Diag",_b="Dilation2D",bO="Dilation2DBackpropInput",vO="Dilation2DBackpropFilter",q_="Draw",Nb="RealDiv",Eb="Einsum",Rb="Elu",K_="EluGrad",Ib="Erf",Ab="Equal",Db="Exp",Ob="ExpandDims",Pb="Expm1",Fb="FFT",Lb="Fill",Mb="FlipLeftRight",zb="Floor",Bb="FloorDiv",Vb="FusedBatchNorm",Ub="GatherV2",Wb="GatherNd",Gb="Greater",Hb="GreaterEqual",gm="Identity",jb="IFFT",Xb="Imag",qb="IsFinite",Kb="IsInf",Yb="IsNan",Qb="LeakyRelu",Zb="Less",Jb="LessEqual",t1="LinSpace",e1="Log",n1="Log1p",s1="LogicalAnd",r1="LogicalNot",i1="LogicalOr",a1="LRN",Y_="LRNGrad",o1="Max",l1="Maximum",u1="MaxPool",Q_="MaxPoolGrad",c1="MaxPool3D",Z_="MaxPool3DGrad",h1="MaxPoolWithArgmax",d1="Mean",f1="Min",p1="Minimum",m1="MirrorPad",g1="Mod",y1="Multinomial",x1="Multiply",b1="Neg",v1="NotEqual",w1="NonMaxSuppressionV3",J_="NonMaxSuppressionV4",S1="NonMaxSuppressionV5",C1="OnesLike",$1="OneHot",T1="Pack",k1="PadV2",_1="Pow",N1="Prelu",E1="Prod",tN="RaggedGather",eN="RaggedRange",nN="RaggedTensorToTensor",R1="Range",I1="Real",A1="Reciprocal",D1="Relu",O1="Reshape",P1="ResizeNearestNeighbor",sN="ResizeNearestNeighborGrad",F1="ResizeBilinear",rN="ResizeBilinearGrad",L1="Relu6",M1="Reverse",z1="Round",B1="Rsqrt",V1="ScatterNd",U1="TensorScatterUpdate",W1="SearchSorted",G1="Select",H1="Selu",j1="Slice",X1="Sin",q1="Sinh",K1="Sign",Y1="Sigmoid",Q1="Softplus",Z1="Sqrt",J1="Sum",tv="SpaceToBatchND",ev="SplitV",nv="Softmax",iN="SparseFillEmptyRows",aN="SparseReshape",sv="SparseSegmentMean",rv="SparseSegmentSum",iv="SparseToDense",av="SquaredDifference",oN="Square",lN="StaticRegexReplace",ov="StridedSlice",lv="StringNGrams",uN="StringSplit",cN="StringToHashBucketFast",uv="Sub",cv="Tan",hv="Tanh",ym="Tile",dv="TopK",fv="Transform",zh="Transpose",hN="Unique",pv="Unpack",mv="UnsortedSegmentSum",gv="ZerosLike",yv="Step",zp="FromPixels",xv="RotateWithOffset",Bp="_FusedMatMul",Vp="FusedConv2D",Up="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jr(...n){tt().getBool("IS_TEST")||tt().getBool("PROD")||console.warn(...n)}function wO(...n){tt().getBool("IS_TEST")||tt().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wp=B0("kernelRegistry",()=>new Map),SO=B0("gradRegistry",()=>new Map);function Gp(n,t){const e=fN(n,t);return Wp.get(e)}function m$(n){return SO.get(n)}function g$(n){const t=Wp.entries(),e=[];for(;;){const{done:s,value:r}=t.next();if(s)break;const[i,a]=r,[o]=i.split("_");o===n&&e.push(a)}return e}function dN(n){const{kernelName:t,backendName:e}=n,s=fN(t,e);Wp.has(s)&&Jr(`The kernel '${t}' for backend '${e}' is already registered`),Wp.set(s,n)}function fN(n,t){return`${t}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pN(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var ax,y$;function CO(){if(y$)return ax;y$=1,ax=t;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function t(U,D,Y){this.low=U|0,this.high=D|0,this.unsigned=!!Y}t.prototype.__isLong__,Object.defineProperty(t.prototype,"__isLong__",{value:!0});function e(U){return(U&&U.__isLong__)===!0}t.isLong=e;var s={},r={};function i(U,D){var Y,nt,dt;return D?(U>>>=0,(dt=0<=U&&U<256)&&(nt=r[U],nt)?nt:(Y=o(U,(U|0)<0?-1:0,!0),dt&&(r[U]=Y),Y)):(U|=0,(dt=-128<=U&&U<128)&&(nt=s[U],nt)?nt:(Y=o(U,U<0?-1:0,!1),dt&&(s[U]=Y),Y))}t.fromInt=i;function a(U,D){if(isNaN(U))return D?k:C;if(D){if(U<0)return k;if(U>=x)return V}else{if(U<=-w)return B;if(U+1>=w)return L}return U<0?a(-U,D).neg():o(U%y|0,U/y|0,D)}t.fromNumber=a;function o(U,D,Y){return new t(U,D,Y)}t.fromBits=o;var u=Math.pow;function h(U,D,Y){if(U.length===0)throw Error("empty string");if(U==="NaN"||U==="Infinity"||U==="+Infinity"||U==="-Infinity")return C;if(typeof D=="number"?(Y=D,D=!1):D=!!D,Y=Y||10,Y<2||36<Y)throw RangeError("radix");var nt;if((nt=U.indexOf("-"))>0)throw Error("interior hyphen");if(nt===0)return h(U.substring(1),D,Y).neg();for(var dt=a(u(Y,8)),at=C,K=0;K<U.length;K+=8){var ct=Math.min(8,U.length-K),yt=parseInt(U.substring(K,K+ct),Y);if(ct<8){var $t=a(u(Y,ct));at=at.mul($t).add(a(yt))}else at=at.mul(dt),at=at.add(a(yt))}return at.unsigned=D,at}t.fromString=h;function d(U,D){return typeof U=="number"?a(U,D):typeof U=="string"?h(U,D):o(U.low,U.high,typeof D=="boolean"?D:U.unsigned)}t.fromValue=d;var f=65536,m=1<<24,y=f*f,x=y*y,w=x/2,S=i(m),C=i(0);t.ZERO=C;var k=i(0,!0);t.UZERO=k;var E=i(1);t.ONE=E;var R=i(1,!0);t.UONE=R;var A=i(-1);t.NEG_ONE=A;var L=o(-1,2147483647,!1);t.MAX_VALUE=L;var V=o(-1,-1,!0);t.MAX_UNSIGNED_VALUE=V;var B=o(0,-2147483648,!1);t.MIN_VALUE=B;var z=t.prototype;return z.toInt=function(){return this.unsigned?this.low>>>0:this.low},z.toNumber=function(){return this.unsigned?(this.high>>>0)*y+(this.low>>>0):this.high*y+(this.low>>>0)},z.toString=function(D){if(D=D||10,D<2||36<D)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(B)){var Y=a(D),nt=this.div(Y),dt=nt.mul(Y).sub(this);return nt.toString(D)+dt.toInt().toString(D)}else return"-"+this.neg().toString(D);for(var at=a(u(D,6),this.unsigned),K=this,ct="";;){var yt=K.div(at),$t=K.sub(yt.mul(at)).toInt()>>>0,H=$t.toString(D);if(K=yt,K.isZero())return H+ct;for(;H.length<6;)H="0"+H;ct=""+H+ct}},z.getHighBits=function(){return this.high},z.getHighBitsUnsigned=function(){return this.high>>>0},z.getLowBits=function(){return this.low},z.getLowBitsUnsigned=function(){return this.low>>>0},z.getNumBitsAbs=function(){if(this.isNegative())return this.eq(B)?64:this.neg().getNumBitsAbs();for(var D=this.high!=0?this.high:this.low,Y=31;Y>0&&(D&1<<Y)==0;Y--);return this.high!=0?Y+33:Y+1},z.isZero=function(){return this.high===0&&this.low===0},z.eqz=z.isZero,z.isNegative=function(){return!this.unsigned&&this.high<0},z.isPositive=function(){return this.unsigned||this.high>=0},z.isOdd=function(){return(this.low&1)===1},z.isEven=function(){return(this.low&1)===0},z.equals=function(D){return e(D)||(D=d(D)),this.unsigned!==D.unsigned&&this.high>>>31===1&&D.high>>>31===1?!1:this.high===D.high&&this.low===D.low},z.eq=z.equals,z.notEquals=function(D){return!this.eq(D)},z.neq=z.notEquals,z.ne=z.notEquals,z.lessThan=function(D){return this.comp(D)<0},z.lt=z.lessThan,z.lessThanOrEqual=function(D){return this.comp(D)<=0},z.lte=z.lessThanOrEqual,z.le=z.lessThanOrEqual,z.greaterThan=function(D){return this.comp(D)>0},z.gt=z.greaterThan,z.greaterThanOrEqual=function(D){return this.comp(D)>=0},z.gte=z.greaterThanOrEqual,z.ge=z.greaterThanOrEqual,z.compare=function(D){if(e(D)||(D=d(D)),this.eq(D))return 0;var Y=this.isNegative(),nt=D.isNegative();return Y&&!nt?-1:!Y&&nt?1:this.unsigned?D.high>>>0>this.high>>>0||D.high===this.high&&D.low>>>0>this.low>>>0?-1:1:this.sub(D).isNegative()?-1:1},z.comp=z.compare,z.negate=function(){return!this.unsigned&&this.eq(B)?B:this.not().add(E)},z.neg=z.negate,z.add=function(D){e(D)||(D=d(D));var Y=this.high>>>16,nt=this.high&65535,dt=this.low>>>16,at=this.low&65535,K=D.high>>>16,ct=D.high&65535,yt=D.low>>>16,$t=D.low&65535,H=0,ut=0,xt=0,bt=0;return bt+=at+$t,xt+=bt>>>16,bt&=65535,xt+=dt+yt,ut+=xt>>>16,xt&=65535,ut+=nt+ct,H+=ut>>>16,ut&=65535,H+=Y+K,H&=65535,o(xt<<16|bt,H<<16|ut,this.unsigned)},z.subtract=function(D){return e(D)||(D=d(D)),this.add(D.neg())},z.sub=z.subtract,z.multiply=function(D){if(this.isZero())return C;if(e(D)||(D=d(D)),n){var Y=n.mul(this.low,this.high,D.low,D.high);return o(Y,n.get_high(),this.unsigned)}if(D.isZero())return C;if(this.eq(B))return D.isOdd()?B:C;if(D.eq(B))return this.isOdd()?B:C;if(this.isNegative())return D.isNegative()?this.neg().mul(D.neg()):this.neg().mul(D).neg();if(D.isNegative())return this.mul(D.neg()).neg();if(this.lt(S)&&D.lt(S))return a(this.toNumber()*D.toNumber(),this.unsigned);var nt=this.high>>>16,dt=this.high&65535,at=this.low>>>16,K=this.low&65535,ct=D.high>>>16,yt=D.high&65535,$t=D.low>>>16,H=D.low&65535,ut=0,xt=0,bt=0,_t=0;return _t+=K*H,bt+=_t>>>16,_t&=65535,bt+=at*H,xt+=bt>>>16,bt&=65535,bt+=K*$t,xt+=bt>>>16,bt&=65535,xt+=dt*H,ut+=xt>>>16,xt&=65535,xt+=at*$t,ut+=xt>>>16,xt&=65535,xt+=K*yt,ut+=xt>>>16,xt&=65535,ut+=nt*H+dt*$t+at*yt+K*ct,ut&=65535,o(bt<<16|_t,ut<<16|xt,this.unsigned)},z.mul=z.multiply,z.divide=function(D){if(e(D)||(D=d(D)),D.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&D.low===-1&&D.high===-1)return this;var Y=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,D.low,D.high);return o(Y,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?k:C;var nt,dt,at;if(this.unsigned){if(D.unsigned||(D=D.toUnsigned()),D.gt(this))return k;if(D.gt(this.shru(1)))return R;at=k}else{if(this.eq(B)){if(D.eq(E)||D.eq(A))return B;if(D.eq(B))return E;var K=this.shr(1);return nt=K.div(D).shl(1),nt.eq(C)?D.isNegative()?E:A:(dt=this.sub(D.mul(nt)),at=nt.add(dt.div(D)),at)}else if(D.eq(B))return this.unsigned?k:C;if(this.isNegative())return D.isNegative()?this.neg().div(D.neg()):this.neg().div(D).neg();if(D.isNegative())return this.div(D.neg()).neg();at=C}for(dt=this;dt.gte(D);){nt=Math.max(1,Math.floor(dt.toNumber()/D.toNumber()));for(var ct=Math.ceil(Math.log(nt)/Math.LN2),yt=ct<=48?1:u(2,ct-48),$t=a(nt),H=$t.mul(D);H.isNegative()||H.gt(dt);)nt-=yt,$t=a(nt,this.unsigned),H=$t.mul(D);$t.isZero()&&($t=E),at=at.add($t),dt=dt.sub(H)}return at},z.div=z.divide,z.modulo=function(D){if(e(D)||(D=d(D)),n){var Y=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,D.low,D.high);return o(Y,n.get_high(),this.unsigned)}return this.sub(this.div(D).mul(D))},z.mod=z.modulo,z.rem=z.modulo,z.not=function(){return o(~this.low,~this.high,this.unsigned)},z.and=function(D){return e(D)||(D=d(D)),o(this.low&D.low,this.high&D.high,this.unsigned)},z.or=function(D){return e(D)||(D=d(D)),o(this.low|D.low,this.high|D.high,this.unsigned)},z.xor=function(D){return e(D)||(D=d(D)),o(this.low^D.low,this.high^D.high,this.unsigned)},z.shiftLeft=function(D){return e(D)&&(D=D.toInt()),(D&=63)===0?this:D<32?o(this.low<<D,this.high<<D|this.low>>>32-D,this.unsigned):o(0,this.low<<D-32,this.unsigned)},z.shl=z.shiftLeft,z.shiftRight=function(D){return e(D)&&(D=D.toInt()),(D&=63)===0?this:D<32?o(this.low>>>D|this.high<<32-D,this.high>>D,this.unsigned):o(this.high>>D-32,this.high>=0?0:-1,this.unsigned)},z.shr=z.shiftRight,z.shiftRightUnsigned=function(D){if(e(D)&&(D=D.toInt()),D&=63,D===0)return this;var Y=this.high;if(D<32){var nt=this.low;return o(nt>>>D|Y<<32-D,Y>>>D,this.unsigned)}else return D===32?o(Y,0,this.unsigned):o(Y>>>D-32,0,this.unsigned)},z.shru=z.shiftRightUnsigned,z.shr_u=z.shiftRightUnsigned,z.toSigned=function(){return this.unsigned?o(this.low,this.high,!1):this},z.toUnsigned=function(){return this.unsigned?this:o(this.low,this.high,!0)},z.toBytes=function(D){return D?this.toBytesLE():this.toBytesBE()},z.toBytesLE=function(){var D=this.high,Y=this.low;return[Y&255,Y>>>8&255,Y>>>16&255,Y>>>24,D&255,D>>>8&255,D>>>16&255,D>>>24]},z.toBytesBE=function(){var D=this.high,Y=this.low;return[D>>>24,D>>>16&255,D>>>8&255,D&255,Y>>>24,Y>>>16&255,Y>>>8&255,Y&255]},t.fromBytes=function(D,Y,nt){return nt?t.fromBytesLE(D,Y):t.fromBytesBE(D,Y)},t.fromBytesLE=function(D,Y){return new t(D[0]|D[1]<<8|D[2]<<16|D[3]<<24,D[4]|D[5]<<8|D[6]<<16|D[7]<<24,Y)},t.fromBytesBE=function(D,Y){return new t(D[4]<<24|D[5]<<16|D[6]<<8|D[7],D[0]<<24|D[1]<<16|D[2]<<8|D[3],Y)},ax}var mN=CO();const gN=O_(mN),$O=UD({__proto__:null,default:gN},[mN]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zo=gN||$O;function xm(n){return Zo.fromString(n,!0,16)}const yN=xm("c3a5c85c97cb3127"),qo=xm("b492b66fbe98f273"),cs=xm("9ae16a3b2f90404f");function Bx(n){return n.xor(n.shru(47))}function xN(n,t,e){const s=n.slice(t,t+e);return Zo.fromBytes(Array.from(s),!0,!0)}function He(n,t){return xN(n,t,8)}function x$(n,t){return xN(n,t,4)}function En(n,t){return t===0?n:n.shru(t).or(n.shl(64-t))}function qa(n,t,e=xm("9ddfea08eb382d69")){let s=n.xor(t).mul(e);s=s.xor(s.shru(47));let r=t.xor(s).mul(e);return r=r.xor(r.shru(47)),r=r.mul(e),r}function TO(n,t,e,s,r,i){r=r.add(n),i=En(i.add(r).add(s),21);const a=r;return r=r.add(t),r=r.add(e),i=i.add(En(r,44)),[r.add(s),i.add(a)]}function Yf(n,t,e,s){return TO(He(n,t),He(n,t+8),He(n,t+16),He(n,t+24),e,s)}function kO(n,t=n.length){if(t>=8){const e=cs.add(t*2),s=He(n,0).add(cs),r=He(n,t-8),i=En(r,37).mul(e).add(s),a=En(s,25).add(r).mul(e);return qa(i,a,e)}if(t>=4){const e=cs.add(t*2),s=x$(n,0);return qa(s.shl(3).add(t),x$(n,t-4),e)}if(t>0){const e=n[0],s=n[t>>1],r=n[t-1],i=e+(s<<8),a=t+(r<<2);return Bx(cs.mul(i).xor(yN.mul(a))).mul(cs)}return cs}function _O(n,t=n.length){const e=cs.add(t*2),s=He(n,0).mul(qo),r=He(n,8),i=He(n,t-8).mul(e),a=He(n,t-16).mul(cs);return qa(En(s.add(r),43).add(En(i,30)).add(a),s.add(En(r.add(cs),18)).add(i),e)}function NO(n,t=n.length){const e=cs.add(t*2),s=He(n,0).mul(cs),r=He(n,8),i=He(n,t-8).mul(e),a=He(n,t-16).mul(cs),o=En(s.add(r),43).add(En(i,30)).add(a),u=qa(o,s.add(En(r.add(cs),18)).add(i),e),h=He(n,16).mul(e),d=He(n,24),f=o.add(He(n,t-32)).mul(e),m=u.add(He(n,t-24)).mul(e);return qa(En(h.add(d),43).add(En(f,30)).add(m),h.add(En(d.add(s),18)).add(f),e)}function EO(n,t=n.length){const e=Zo.fromNumber(81,!0);if(t<=32)return t<=16?kO(n,t):_O(n,t);if(t<=64)return NO(n,t);let s=e,r=e.mul(qo).add(113),i=Bx(r.mul(cs).add(113)).mul(cs),a=[Zo.UZERO,Zo.UZERO],o=[Zo.UZERO,Zo.UZERO];s=s.mul(cs).add(He(n,0));let u=0;const h=(t-1>>6)*64,d=h+(t-1&63)-63;do s=En(s.add(r).add(a[0]).add(He(n,u+8)),37).mul(qo),r=En(r.add(a[1]).add(He(n,u+48)),42).mul(qo),s=s.xor(o[1]),r=r.add(a[0]).add(He(n,u+40)),i=En(i.add(o[0]),33).mul(qo),a=Yf(n,u,a[1].mul(qo),s.add(o[0])),o=Yf(n,u+32,i.add(o[1]),r.add(He(n,u+16))),[i,s]=[s,i],u+=64;while(u!==h);const f=qo.add(i.and(255).shl(1));return u=d,o[0]=o[0].add(t-1&63),a[0]=a[0].add(o[0]),o[0]=o[0].add(a[0]),s=En(s.add(r).add(a[0]).add(He(n,u+8)),37).mul(f),r=En(r.add(a[1]).add(He(n,u+48)),42).mul(f),s=s.xor(o[1].mul(9)),r=r.add(a[0].mul(9).add(He(n,u+40))),i=En(i.add(o[0]),33).mul(f),a=Yf(n,u,a[1].mul(f),s.add(o[0])),o=Yf(n,u+32,i.add(o[1]),r.add(He(n,u+16))),[i,s]=[s,i],qa(qa(a[0],o[0],f).add(Bx(r).mul(yN)).add(i),qa(a[1],o[1],f).add(s),f)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zu(n,t){return t==="string"?Ka(n):bm([n],t)}function RO(n,t){return n instanceof Float32Array&&t==="float32"||n instanceof Int32Array&&t==="int32"||n instanceof Uint8Array&&t==="bool"}function bm(n,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=na(n)),tt().getBool("DEBUG")&&lO(n,t),RO(n,t))return n;if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool"){const e=new Uint8Array(n.length);for(let s=0;s<e.length;++s)Math.round(n[s])!==0&&(e[s]=1);return e}else throw new Error(`Unknown data type ${t}`)}function Yr(){return tt().platform.now()}function Ka(n,t="utf-8"){return t=t||"utf-8",tt().platform.encode(n,t)}function ea(n,t="utf-8"){return t=t||"utf-8",tt().platform.decode(n,t)}function Pr(n){return tt().platform.isTypedArray!=null?tt().platform.isTypedArray(n):pN(n)}function na(n,t=[],e=!1){if(t==null&&(t=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||dl(n)||n==null||Pr(n)&&e)t.push(n);else if(Array.isArray(n)||Pr(n))for(let s=0;s<n.length;++s)na(n[s],t,e);else{let s=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)na(n[r],t,e)}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IO{constructor(t,e){this.backendTimer=t,this.logger=e,e==null&&(this.logger=new DO)}profileKernel(t,e,s){let r;const i=()=>{r=s()};let a;const o=Yr();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(i);else{i();for(const h of r)h.dataSync();a=Promise.resolve({kernelMs:Yr()-o})}if(tt().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let h=0;h<r.length;h++){const d=r[h];d.data().then(f=>{AO(f,d.dtype,t)})}return{kernelName:t,outputs:r,inputs:e,timeMs:a.then(h=>h.kernelMs),extraInfo:a.then(h=>h.getExtraProfileInfo!=null?h.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:s,timeMs:r,inputs:i,extraInfo:a}=t;s.forEach(o=>{Promise.all([o.data(),r,a]).then(u=>{this.logger.logKernelProfile(e,o,u[0],u[1],i,u[2])})})}}function AO(n,t,e){if(t!=="float32")return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${e}'`),!0}return!1}class DO{logKernelProfile(t,e,s,r,i,a){const o=typeof r=="number"?Ou(`${r}ms`,9):r.error,u=Ou(t,25),h=e.rank,d=e.size,f=Ou(e.shape.toString(),14);let m="";for(const y in i){const x=i[y];if(x!=null){const w=x.shape||e.shape,S=w.length;m+=`${y}: ${S}D ${S>0?w:""} `}}console.log(`%c${u}	%c${o}	%c${h}D ${f}	%c${d}	%c${m}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OO(n,t,e){const s={},r={};for(let u=0;u<t.length;u++)s[t[u].id]=!0;for(let u=0;u<n.length;u++){const h=n[u],d=h.inputs;for(const f in d){const m=d[f];let y=!1;for(let x=0;x<t.length;x++)if(s[m.id]){h.outputs.forEach(w=>s[w.id]=!0),y=!0,r[h.id]=!0;break}if(y)break}}const i={};i[e.id]=!0;const a={};for(let u=n.length-1;u>=0;u--){const h=n[u],d=h.inputs;for(let f=0;f<h.outputs.length;f++)if(i[h.outputs[f].id]){for(const m in d)i[d[m].id]=!0,a[h.id]=!0;break}}const o=[];for(let u=0;u<n.length;u++){const h=n[u];if(r[h.id]&&a[h.id]){const d={};for(const m in h.inputs){const y=h.inputs[m];s[y.id]&&(d[m]=y)}const f=Object.assign({},h);f.inputs=d,f.outputs=h.outputs,o.push(f)}}return o}function PO(n,t,e,s){for(let r=t.length-1;r>=0;r--){const i=t[r],a=[];if(i.outputs.forEach(u=>{const h=n[u.id];h!=null?a.push(h):a.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const o=i.gradient(a);for(const u in i.inputs){if(!(u in o))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(o)}.`);const h=e(()=>o[u]());if(h.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${h.dtype}'`);const d=i.inputs[u];if(!Ee(h.shape,d.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${u}' has shape '${h.shape}', which does not match the shape of the input '${d.shape}'`);if(n[d.id]==null)n[d.id]=h;else{const f=n[d.id];n[d.id]=s(f,h),f.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b$=20,yh=3,ox=7;function FO(n,t,e,s){const r=cn(t),i=LO(n,t,e,r),a=t.length,o=bp(n,t,e,r,i),u=["Tensor"];return s&&(u.push(`  dtype: ${e}`),u.push(`  rank: ${a}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(o.map(h=>"    "+h).join(`
`)),u.join(`
`)}function LO(n,t,e,s){const r=ht(t),i=s[s.length-1],a=new Array(i).fill(0),o=t.length,u=e==="complex64"?Nh(n):n;if(o>1)for(let h=0;h<r/i;h++){const d=h*i;for(let f=0;f<i;f++)a[f]=Math.max(a[f],_h(u[d+f],0,e).length)}return a}function _h(n,t,e){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(ox))} + ${parseFloat(n[1].toFixed(ox))}j`:xd(n)?s=`'${n}'`:e==="bool"?s=bN(n):s=parseFloat(n.toFixed(ox)).toString(),Ou(s,t)}function bN(n){return n===0?"false":"true"}function bp(n,t,e,s,r,i=!0){const a=e==="complex64"?2:1,o=t[0],u=t.length;if(u===0){if(e==="complex64"){const w=Nh(n);return[_h(w[0],0,e)]}return e==="bool"?[bN(n[0])]:[n[0].toString()]}if(u===1){if(o>b$){const S=yh*a;let C=Array.from(n.slice(0,S)),k=Array.from(n.slice((o-yh)*a,o*a));return e==="complex64"&&(C=Nh(C),k=Nh(k)),["["+C.map((E,R)=>_h(E,r[R],e)).join(", ")+", ..., "+k.map((E,R)=>_h(E,r[o-yh+R],e)).join(", ")+"]"]}return["["+(e==="complex64"?Nh(n):Array.from(n)).map((S,C)=>_h(S,r[C],e)).join(", ")+"]"]}const h=t.slice(1),d=s.slice(1),f=s[0]*a,m=[];if(o>b$){for(let w=0;w<yh;w++){const S=w*f,C=S+f;m.push(...bp(n.slice(S,C),h,e,d,r,!1))}m.push("...");for(let w=o-yh;w<o;w++){const S=w*f,C=S+f;m.push(...bp(n.slice(S,C),h,e,d,r,w===o-1))}}else for(let w=0;w<o;w++){const S=w*f,C=S+f;m.push(...bp(n.slice(S,C),h,e,d,r,w===o-1))}const y=u===2?",":"";m[0]="["+(o>0?m[0]+y:"");for(let w=1;w<m.length-1;w++)m[w]=" "+m[w]+y;let x=`,
`;for(let w=2;w<u;w++)x+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(i?"":x),m}function Nh(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bu{constructor(t,e,s){if(this.dtype=e,this.shape=t.slice(),this.size=ht(t),s!=null){const r=s.length;M(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||kn(e,this.size),this.strides=cn(t)}set(t,...e){e.length===0&&(e=[0]),M(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const s=this.locToIndex(e);this.values[s]=t}get(...t){t.length===0&&(t=[0]);let e=0;for(const r of t){if(r<0||r>=this.shape[e]){const i=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(i)}e++}let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=this.strides[r]*t[r];return this.values[s]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let e=t[t.length-1];for(let s=0;s<t.length-1;++s)e+=this.strides[s]*t[s];return e}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const e=new Array(this.shape.length);for(let s=0;s<e.length-1;++s)e[s]=Math.floor(t/this.strides[s]),t-=e[s]*this.strides[s];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Qr().makeTensor(this.values,this.shape,this.dtype)}}let Qr=null,Ru=null;function MO(n){Qr=n}function zO(n){Ru=n}class un{constructor(t,e,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=ht(t),this.strides=cn(t),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return Ru.buffer(this.shape,this.dtype,t)}bufferSync(){return Ru.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return Mx(this.shape,t,this.dtype==="complex64")}arraySync(){return Mx(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=Qr().read(this.dataId);if(this.dtype==="string"){const e=await t;try{return e.map(s=>ea(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Qr().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Qr().readSync(this.dataId);if(this.dtype==="string")try{return t.map(e=>ea(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Qr().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Qr().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Ru.print(this,t)}clone(){return this.throwIfDisposed(),Ru.clone(this)}toString(t=!1){const e=this.dataSync();return FO(e,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Ru.cast(this,t)}variable(t=!0,e,s){return this.throwIfDisposed(),Qr().makeVariable(this,t,e,s)}}Object.defineProperty(un,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function vN(){return B0("Tensor",()=>un)}vN();class Hp extends un{constructor(t,e,s,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=s}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Ee(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Qr().disposeTensor(this),this.dataId=t.dataId,Qr().incRef(this,null)}dispose(){Qr().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Hp,Symbol.hasInstance,{value:n=>n instanceof un&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var v$;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(v$||(v$={}));var Vx;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(Vx||(Vx={}));var Ux;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(Ux||(Ux={}));var Wx;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(Wx||(Wx={}));var Gx;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(Gx||(Gx={}));const BO={float32:Wx,int32:Vx,bool:Ux,complex64:Gx};function Ns(n,t){if(n==="string"||t==="string"){if(n==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return BO[n][t]}function vm(n){return Ns(n,"int32")}function wN(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function SN(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hn(n,t){if(n.dtype===t.dtype)return[n,t];const e=Ns(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function VO(n,t){M(n.dtype===t.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${t.dtype}) input must match`)}function CN(n){const t=[];return $N(n,t,new Set),t}function $N(n,t,e){if(n==null)return;if(n instanceof un){t.push(n);return}if(!UO(n))return;const s=n;for(const r in s){const i=s[r];e.has(i)||(e.add(i),$N(i,t,e))}}function UO(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lx(n){return n.kernelName!=null}class w${constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class Vu{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new w$}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const s=t[e];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:e}=this.initializeBackend(t);if(e)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,s=1){return t in this.registryFactory?(Jr(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:s},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:e,asyncInit:s}=this.initializeBackend(t);if(!(s?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new IO(this.backendInstance),!0}setupRegisteredKernels(){g$(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){g$(t).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[t])})}initializeBackend(t){const e=this.registryFactory[t];if(e==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const s=e.factory();if(s&&!(s instanceof L0)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,i=s.then(a=>r<this.pendingBackendInitId?!1:(this.registry[t]=a,this.pendingBackendInit=null,!0)).catch(a=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Jr(`Initialization of backend ${t} failed`),Jr(a.stack||a.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[t]=s,{success:!0,asyncInit:!1}}catch(s){return Jr(`Initialization of backend ${t} failed`),Jr(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const s=t[e],{success:r,asyncInit:i}=this.initializeBackend(s);if(i||r)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const s=this.state.tensorInfo.get(e),r=s.backend,i=this.readSync(e),a=r.refCount(e);r.disposeData(e,!0),s.backend=t,t.move(e,i,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let s=null;if(e==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");e=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof e!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=e(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(t,e,s){t();try{const r=s();return e(),r}catch(r){throw e(),r}}nextTensorId(){return Vu.nextTensorId++}nextVariableId(){return Vu.nextVariableId++}clone(t){const e=Q.runKernel(gm,{x:t}),s={x:t},r=a=>({x:()=>{const o="float32",u={x:a},h={dtype:o};return Q.runKernel(mm,u,h)}}),i=[];return this.addTapeNode(this.state.activeScope.name,s,[e],r,i,{}),e}runKernel(t,e,s){if(this.backendName==null&&this.backend,!(Gp(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,s){const r=this.backend.numDataIds();let i=0;s.forEach(u=>{i+=u.dtype==="complex64"?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-e-i-a;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let e,s=[];const r=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let u;const h=lx(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(lx(t)){const{kernelName:x,inputs:w,attrs:S}=t;this.backendName==null&&this.backend;const C=Gp(x,this.backendName);M(C!=null,()=>`Cannot find registered kernel '${x}' for backend '${this.backendName}'`),o=()=>{const k=this.backend.numDataIds();u=C.kernelFunc({inputs:w,attrs:S,backend:this.backend});const E=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(x,k,E);const R=E.map(A=>A.rank!=null?A:this.makeTensorFromTensorInfo(A));if(r){const A=this.getTensorsForGradient(x,w,R);s=this.saveTensorsForBackwardMode(A)}return R}}else{const{forwardFunc:x}=t,w=S=>{r&&(s=S.map(C=>this.keep(this.clone(C))))};o=()=>{const S=this.backend.numDataIds();u=this.tidy(()=>x(this.backend,w));const C=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(h,S,C),C}}const{inputs:d,attrs:f}=t,m=lx(t)?null:t.backwardsFunc;let y;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?e=o():(y=this.profiler.profileKernel(h,d,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(y),e=y.outputs)}),r&&this.addTapeNode(h,d,e,m,s,f),this.state.profiling&&this.state.activeProfile.kernels.push({name:h,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(x=>d[x]!=null?d[x].shape:null),outputShapes:e.map(x=>x.shape),kernelTimeMs:y.timeMs,extraInfo:y.extraInfo}),Array.isArray(u)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(t,e,s){const r=m$(t);if(r!=null){const i=r.inputsToSave||[],a=r.outputsToSave||[];let o;r.saveAllInputs?(M(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(e).map(h=>e[h])):o=i.map(h=>e[h]);const u=s.filter((h,d)=>a[d]);return o.concat(u)}return[]}makeTensor(t,e,s,r){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let i=t;s==="string"&&xd(t[0])&&(i=t.map(u=>Ka(u)));const a=r.write(i,e,s),o=new un(e,s,a,this.nextTensorId());if(this.trackTensor(o,r),s==="string"){const u=this.state.tensorInfo.get(a),h=cO(i);this.state.numBytes+=h-u.bytes,u.bytes=h}return o}makeTensorFromDataId(t,e,s,r){s=s||"float32";const i={dataId:t,shape:e,dtype:s};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(t,e){const{dataId:s,shape:r,dtype:i}=t,a=new un(r,i,s,this.nextTensorId());return this.trackTensor(a,e),a}makeVariable(t,e=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==t.dtype&&(t=t.cast(r));const i=new Hp(t,e,s,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(t,e){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let s=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(s=t.size*Mp(t.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:s})),t instanceof Hp||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const s=t.size*Mp(t.dtype);this.state.numBytes-=s}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,e,s,r,i,a){const o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:s,saved:i},u=m$(t);u!=null&&(r=u.gradFunc),r!=null&&(o.gradient=h=>(h=h.map((d,f)=>{if(d==null){const m=s[f],y=ta(m.size,m.dtype);return this.makeTensor(y,m.shape,m.dtype)}return d}),r(h.length>1?h:h[0],i,a))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=CN(t),s=new Set(e.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const a=this.state.activeScope.track[i];!a.kept&&!s.has(a.id)&&a.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(i=>{!i.kept&&i.scopeId===r.id&&this.track(i)})}gradients(t,e,s,r=!1){if(M(e.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));M(i instanceof un,()=>"The result y returned by f() must be a tensor.");const a=OO(this.state.activeTape,e,i);if(!r&&a.length===0&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const o={};o[i.id]=s??WO(i.shape),PO(o,a,h=>this.tidy(h),GO);const u=e.map(h=>o[h.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(h=>{for(const d of h.saved)d.dispose()}),this.state.activeTape=null),{value:i,grads:u}})}customGrad(t){return M(Fx(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{M(e.every(o=>o instanceof un),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};e.forEach((o,u)=>{r[u]=o});const i=(o,u)=>(s=t(...e,u),M(s.value instanceof un,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),M(Fx(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),a=(o,u)=>{const h=s.gradFunc(o,u),d=Array.isArray(h)?h:[h];M(d.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),M(d.every(m=>m instanceof un),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const f={};return d.forEach((m,y)=>{f[y]=()=>m}),f};return this.runKernelFunc({forwardFunc:i,backwardsFunc:a,inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){const e=Yr(),s=await this.backend.time(t);return s.wallMs=Yr()-e,s}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new w$;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Vu.nextTensorId=0;Vu.nextVariableId=0;function WO(n){const t=V_(ht(n),"float32");return Q.makeTensor(t,n,"float32")}function TN(){const n=W_();if(n._tfengine==null){const t=new fO(n);n._tfengine=new Vu(t)}return yO(n._tfengine.ENV),MO(()=>n._tfengine),n._tfengine}const Q=TN();function GO(n,t){const e={a:n,b:t};return Q.runKernel(pm,e)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HO(){return typeof navigator<"u"&&navigator!=null}function kN(n){if(n||HO()){if(n||(n=navigator),n.product==="ReactNative")return!0;const t=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!t){const e=n;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function _N(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Es=tt();Es.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Es.registerFlag("IS_BROWSER",()=>_N());Es.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Es.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Es.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Es.registerFlag("PROD",()=>!1);Es.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Es.getBool("DEBUG"));Es.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Es.registerFlag("IS_TEST",()=>!1);Es.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Es.getBool("DEBUG"));Es.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Es.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Es.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function io(n,t){let e=n;if(Pr(n))return t==="string"?[]:[n.length];if(wN(n)){const r=n.channels||"RGBA";return[n.height,n.width*r.length]}else if(SN(n))return[n.buffer.size/(t==null?4:Mp(t))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(e)||Pr(e)&&t!=="string";)s.push(e.length),e=e[0];return Array.isArray(n)&&tt().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&NN(n,s,[]),s}function NN(n,t,e){if(e=e||[],!Array.isArray(n)&&!Pr(n)){M(t.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}M(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),M(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const s=t.slice(1);for(let r=0;r<n.length;++r)NN(n[r],s,e.concat(r))}function S$(n,t,e,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==t||n==="numeric"&&t==="string")throw new Error(`Argument '${e}' passed to '${s}' must be ${n} tensor, but got ${t} tensor`)}}function F(n,t,e,s="numeric"){if(n instanceof vN())return S$(s,n.dtype,t,e),n;let r=Qu(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),S$(s,r,t,e),n==null||!Pr(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const u=n==null?"null":n.constructor.name;throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${u}'`)}const i=io(n,r);!Pr(n)&&!Array.isArray(n)&&(n=[n]);const o=r!=="string"?bm(n,r):na(n,[],!0);return Q.makeTensor(o,i,r)}function jp(n,t,e,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,a)=>F(i,`${t}[${a}]`,e,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EN="__op";function q(n){const t=Object.keys(n);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const s=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+EN;const r=(...i)=>{Q.startScope(e);try{const a=s(...i);return dl(a)&&console.error("Cannot return a Promise inside of tidy."),Q.endScope(a),a}catch(a){throw Q.endScope(null),a}};return Object.defineProperty(r,"name",{value:e,configurable:!0}),r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jO(n,t){const e=F(n,"real","complex"),s=F(t,"imag","complex");Ks(e.shape,s.shape,`real and imag shapes, ${e.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:e,imag:s};return Q.runKernel(lb,r)}const Ja=q({complex_:jO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ao(n,t,e,s){if(s==null)s=Qu(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(SN(n)||wN(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return Q.backend.createTensorFromGPUData(n,t||e,s)}if(!Pr(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){pr(t);const r=ht(t),i=ht(e);M(r===i,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${i}`);for(let a=0;a<e.length;++a){const o=e[a],u=a===e.length-1?o!==ht(t.slice(a)):!0;M(e[a]===t[a]||!u,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!Pr(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n=s!=="string"?bm(n,s):na(n,[],!0),Q.makeTensor(n,t,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xi(n,t,e){const s=io(n,e);return ao(n,t,s,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fl={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class si{static join(t){return new si(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(s=>Pr(s)?s.buffer:s),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let e=0;for(let s=0;s<t.length;s++){const r=t[s];s!==t.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=e+r.byteLength;this.shards.push({buffer:r,start:e,end:i}),e=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,e=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),e=Math.min(this.byteLength,e),e<=t)return new ArrayBuffer(0);const s=this.findShardForByte(t);if(s===-1)throw new Error(`Could not find start shard for byte ${t}`);const r=e-t,i=new ArrayBuffer(r),a=new Uint8Array(i);let o=0;for(let u=s;u<this.shards.length;u++){const h=this.shards[u],f=t+o-h.start,m=o,x=Math.min(e,h.end)-h.start,w=new Uint8Array(h.buffer,f,x-f);if(a.set(w,m),o+=w.length,e<h.end)break}return i}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(r){return t<r.start?-1:t>=r.end?1:0}if(e(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=XO(this.shards,e);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function XO(n,t){let e=0,s=n.length;for(;e<=s;){const r=Math.floor((s-e)/2)+e,i=t(n[r]);if(i===0)return r;i<0?s=r:e=r+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gs(){return Q}function Yt(n,t){return Q.tidy(n,t)}function Ne(n){CN(n).forEach(e=>e.dispose())}function gi(n){return Q.keep(n)}function qO(n){return Q.setBackend(n)}function KO(){return Q.ready()}function qh(){return Q.backendName}function RN(n,t,e=1){return Q.registerBackend(n,t,e)}function Uu(){return Q.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const to=4;async function YO(n,t){const e=[],s=[],r=Array.isArray(n)?n.map(a=>a.name):Object.keys(n);for(let a=0;a<r.length;++a){const o=r[a],u=Array.isArray(n)?n[a].tensor:n[o];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${u.dtype}`);const h={name:o,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const d=new Promise(async f=>{const m=await u.bytes(),y=m.reduce((S,C)=>S+C.length,0)+to*m.length,x=new Uint8Array(y);let w=0;for(let S=0;S<m.length;S++){const C=m[S],k=new Uint8Array(new Uint32Array([C.length]).buffer);x.set(k,w),w+=to,x.set(C,w),w+=C.length}f(x)});s.push(d)}else s.push(u.data());t!=null&&(h.group=t),e.push(h)}const i=await Promise.all(s);return{data:JO(i),specs:e}}function IN(n,t){const e=new si(n),s={};let r=0;for(const i of t){const a=QO(i,(o,u)=>e.slice(r+o,r+u));s[i.name]=AN(i,e.slice(r,r+a)),r+=a}return s}function QO(n,t){const e=ht(n.shape);let s;if("quantization"in n){const r=n.quantization;s=fl[r.dtype]}else if(n.dtype==="string"){let r=0;for(let i=0;i<e;i++)r+=to+new Uint32Array(t(r,r+to))[0];return r}else s=fl[n.dtype];return e*s}async function ZO(n,t){const e=ht(n.shape);let s;if("quantization"in n){const r=n.quantization;s=fl[r.dtype]}else if(n.dtype==="string"){let r=0;for(let i=0;i<e;i++)r+=to+new Uint32Array(await t(r,r+to))[0];return r}else s=fl[n.dtype];return e*s}function AN(n,t){const e=n.name,s=n.dtype,r=n.shape,i=ht(r);let a,o=0;if("quantization"in n){const u=n.quantization;if(u.dtype==="uint8"||u.dtype==="uint16"){if(!("min"in u&&"scale"in u))throw new Error(`Weight ${n.name} with quantization ${u.dtype} doesn't have corresponding metadata min and scale.`)}else if(u.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${n.name} is quantized with ${u.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${u.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const h=fl[u.dtype],d=u.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(s==="float32")if(u.dtype==="uint8"||u.dtype==="uint16"){a=new Float32Array(d.length);for(let f=0;f<d.length;f++){const m=d[f];a[f]=m*u.scale+u.min}}else if(u.dtype==="float16")a=aP()(d);else throw new Error(`Unsupported quantization type ${u.dtype} for weight type float32.`);else if(s==="int32"){if(u.dtype!=="uint8"&&u.dtype!=="uint16")throw new Error(`Unsupported quantization type ${u.dtype} for weight type int32.`);a=new Int32Array(d.length);for(let f=0;f<d.length;f++){const m=d[f];a[f]=Math.round(m*u.scale+u.min)}}else throw new Error(`Unsupported dtype in weight '${e}': ${s}`);o+=i*h}else if(s==="string"){const u=ht(n.shape);a=[];for(let h=0;h<u;h++){const d=new Uint32Array(t.slice(o,o+to))[0];o+=to;const f=new Uint8Array(t.slice(o,o+d));a.push(f),o+=d}}else{const u=fl[s];if(s==="float32")a=new Float32Array(t);else if(s==="int32")a=new Int32Array(t);else if(s==="bool")a=new Uint8Array(t);else if(s==="complex64"){a=new Float32Array(t);const h=new Float32Array(a.length/2),d=new Float32Array(a.length/2);for(let x=0;x<h.length;x++)h[x]=a[x*2],d[x]=a[x*2+1];const f=xi(h,r,"float32"),m=xi(d,r,"float32"),y=Ja(f,m);return f.dispose(),m.dispose(),y}else throw new Error(`Unsupported dtype in weight '${e}': ${s}`);o+=i*u}return xi(a,r,s)}async function C$(n,t,e){let s=new Uint8Array(t);for(;s.byteLength<e;){const{done:r,value:i}=await n.read();if(r&&i==null){const o=e-s.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}const a=new Uint8Array(s.length+i.byteLength);a.set(s,0),a.set(new Uint8Array(i),s.length),s=a}return s.buffer}async function DN(n,t){const e={},s=n.getReader();let r=new ArrayBuffer(0);for(const i of t){const a=await ZO(i,async(h,d)=>(r=await C$(s,r,d),r.slice(h,d)));r=await C$(s,r,a);const o=r.slice(0,a);r=r.slice(a);const u=AN(i,o);if(e[i.name]=u,qh()==="webgpu"){const h=Uu();"uploadToGPU"in h&&ht(u.shape)>=tt().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&h.uploadToGPU(u.dataId)}}return e}function JO(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(i=>{if(t+=i.byteLength,e.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const s=new Uint8Array(t);let r=0;return e.forEach(i=>{s.set(new Uint8Array(i.buffer),r),r+=i.byteLength}),s.buffer}const bv=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function $$(n){return bv?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function tP(n){if(bv)return Buffer.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let s=0,r=t.length;s<r;s++)e+=String.fromCharCode(t[s]);return btoa(e)}function eP(n){if(bv){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let s=0;s<t.length;++s)e.set([t.charCodeAt(s)],s);return e.buffer}function nP(n){return si.join(n)}function T$(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const e=n.split("/");return e[e.length-1]}function ON(n,t){const e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:t};return n.signature!=null&&(e.signature=n.signature),n.userDefinedMetadata!=null&&(e.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(e.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(e.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(e.trainingConfig=n.trainingConfig),e}function PN(n,t,e){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=t,s.weightData=e}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function vv(n,t){let e,s;return n.weightsManifest!=null&&([e,s]=await t(n.weightsManifest)),PN(n,e,s)}function bd(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:$$(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:$$(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new si(n.weightData).byteLength}}function Hx(n){const t=[];for(const e of n)t.push(...e.weights);return t}function sP(){const n=e=>{let s=e<<13,r=0;for(;(s&8388608)===0;)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=n(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}function rP(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let t=1;t<31;t++)n[t]=t<<23;for(let t=33;t<63;t++)n[t]=2147483648+(t-32<<23);return n}function iP(){const n=new Uint32Array(64);for(let t=0;t<64;t++)n[t]=1024;return n[0]=n[32]=0,n}function aP(){const n=sP(),t=rP(),e=iP();return s=>{const r=new ArrayBuffer(4*s.length),i=new Uint32Array(r);for(let a=0;a<s.length;a++){const o=s[a],u=n[e[o>>10]+(o&1023)]+t[o>>10];i[a]=u}return new Float32Array(r)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class an{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return an.instance==null&&(an.instance=new an),an.instance}static registerSaveRouter(t){an.getInstance().saveRouters.push(t)}static registerLoadRouter(t){an.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return an.getHandlers(t,"save")}static getLoadHandlers(t,e){return an.getHandlers(t,"load",e)}static getHandlers(t,e,s){const r=[];return(e==="load"?an.getInstance().loadRouters:an.getInstance().saveRouters).forEach(a=>{const o=a(t,s);o!==null&&r.push(o)}),r}}const oP=n=>an.registerSaveRouter(n),lP=n=>an.registerLoadRouter(n),uP=n=>an.getSaveHandlers(n),cP=(n,t)=>an.getLoadHandlers(n,t);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jx="tensorflowjs",Xx=1,sl="models_store",Wa="model_info_store";function FN(){if(!tt().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function qx(n){const t=n.result;t.createObjectStore(sl,{keyPath:"modelPath"}),t.createObjectStore(Wa,{keyPath:"modelPath"})}class pl{constructor(t){if(this.indexedDB=FN(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((s,r)=>{const i=this.indexedDB.open(jx,Xx);i.onupgradeneeded=()=>qx(i),i.onsuccess=()=>{const a=i.result;if(e==null){const o=a.transaction(sl,"readonly"),h=o.objectStore(sl).get(this.modelPath);h.onsuccess=()=>{if(h.result==null)return a.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(h.result.modelArtifacts)},h.onerror=d=>(a.close(),r(h.error)),o.oncomplete=()=>a.close()}else{e.weightData=si.join(e.weightData);const o=bd(e),u=a.transaction(Wa,"readwrite");let h=u.objectStore(Wa),d;try{d=h.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(m){return r(m)}let f;d.onsuccess=()=>{f=a.transaction(sl,"readwrite");const m=f.objectStore(sl);let y;try{y=m.put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:o})}catch(x){return r(x)}y.onsuccess=()=>s({modelArtifactsInfo:o}),y.onerror=x=>{h=u.objectStore(Wa);const w=h.delete(this.modelPath);w.onsuccess=()=>(a.close(),r(y.error)),w.onerror=S=>(a.close(),r(y.error))}},d.onerror=m=>(a.close(),r(d.error)),u.oncomplete=()=>{f==null?a.close():f.oncomplete=()=>a.close()}}},i.onerror=a=>r(i.error)})}}pl.URL_SCHEME="indexeddb://";const LN=n=>tt().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(pl.URL_SCHEME)?hP(n.slice(pl.URL_SCHEME.length)):null;an.registerSaveRouter(LN);an.registerLoadRouter(LN);function hP(n){return new pl(n)}function dP(n){return n.startsWith(pl.URL_SCHEME)?n.slice(pl.URL_SCHEME.length):n}class fP{constructor(){this.indexedDB=FN()}async listModels(){return new Promise((t,e)=>{const s=this.indexedDB.open(jx,Xx);s.onupgradeneeded=()=>qx(s),s.onsuccess=()=>{const r=s.result,i=r.transaction(Wa,"readonly"),o=i.objectStore(Wa).getAll();o.onsuccess=()=>{const u={};for(const h of o.result)u[h.modelPath]=h.modelArtifactsInfo;t(u)},o.onerror=u=>(r.close(),e(o.error)),i.oncomplete=()=>r.close()},s.onerror=r=>e(s.error)})}async removeModel(t){return t=dP(t),new Promise((e,s)=>{const r=this.indexedDB.open(jx,Xx);r.onupgradeneeded=()=>qx(r),r.onsuccess=()=>{const i=r.result,a=i.transaction(Wa,"readwrite"),o=a.objectStore(Wa),u=o.get(t);let h;u.onsuccess=()=>{if(u.result==null)return i.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const d=o.delete(t),f=()=>{h=i.transaction(sl,"readwrite");const y=h.objectStore(sl).delete(t);y.onsuccess=()=>e(u.result.modelArtifactsInfo),y.onerror=x=>s(u.error)};d.onsuccess=f,d.onerror=m=>(f(),i.close(),s(u.error))}},u.onerror=d=>(i.close(),s(u.error)),a.oncomplete=()=>{h==null?i.close():h.oncomplete=()=>i.close()}},r.onerror=i=>s(r.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qi="/",Iu="tensorflowjs_models",MN="info",pP="model_topology",mP="weight_specs",gP="weight_data",yP="model_metadata";function zN(n){return{info:[Iu,n,MN].join(Qi),topology:[Iu,n,pP].join(Qi),weightSpecs:[Iu,n,mP].join(Qi),weightData:[Iu,n,gP].join(Qi),modelMetadata:[Iu,n,yP].join(Qi)}}function BN(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function xP(n){const t=n.split(Qi);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(Qi)}function bP(n){return n.startsWith(ml.URL_SCHEME)?n.slice(ml.URL_SCHEME.length):n}class ml{constructor(t){if(!tt().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=zN(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),s=JSON.stringify(t.weightSpecs),r=bd(t),i=si.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,tP(i));const a={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch{throw BN(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=r;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const o=JSON.parse(i);e.format=o.format,e.generatedBy=o.generatedBy,e.convertedBy=o.convertedBy,o.signature!=null&&(e.signature=o.signature),o.userDefinedMetadata!=null&&(e.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(e.modelInitializer=o.modelInitializer),o.initializerSignature!=null&&(e.initializerSignature=o.initializerSignature),o.trainingConfig!=null&&(e.trainingConfig=o.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=eP(a),e}}ml.URL_SCHEME="localstorage://";const VN=n=>tt().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ml.URL_SCHEME)?vP(n.slice(ml.URL_SCHEME.length)):null;an.registerSaveRouter(VN);an.registerLoadRouter(VN);function vP(n){return new ml(n)}class wP{constructor(){M(tt().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),M(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},e=Iu+Qi,s=Qi+MN;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);if(i.startsWith(e)&&i.endsWith(s)){const a=xP(i);t[a]=JSON.parse(this.LS.getItem(i))}}return t}async removeModel(t){t=bP(t);const e=zN(t);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(this.LS.getItem(e.info));return BN(e),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pu="://";class us{constructor(){this.managers={}}static getInstance(){return us.instance==null&&(us.instance=new us),us.instance}static registerManager(t,e){M(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(Pu)&&(t=t.slice(0,t.indexOf(Pu))),M(t.length>0,()=>"scheme must not be an empty string.");const s=us.getInstance();M(s.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),s.managers[t]=e}static getManager(t){const e=us.getInstance().managers[t];if(e==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(us.getInstance().managers)}}function vp(n){if(n.indexOf(Pu)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${us.getSchemes().join(",")}`);return{scheme:n.split(Pu)[0],path:n.split(Pu)[1]}}async function UN(n,t,e=!1){M(n!==t,()=>`Old path and new path are the same: '${n}'`);const s=an.getLoadHandlers(n);M(s.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),M(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${n}.`);const r=s[0],i=an.getSaveHandlers(t);M(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),M(i.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${t}.`);const a=i[0],o=vp(n).scheme,u=vp(n).path,h=o===vp(n).scheme,d=await r.load();e&&h&&await us.getManager(o).removeModel(u);const f=await a.save(d);return e&&!h&&await us.getManager(o).removeModel(u),f.modelArtifactsInfo}async function SP(){const n=us.getSchemes(),t={};for(const e of n){const s=await us.getManager(e).listModels();for(const r in s){const i=e+Pu+r;t[i]=s[r]}}return t}async function CP(n){const t=vp(n);return us.getManager(t.scheme).removeModel(t.path)}async function $P(n,t){return UN(n,t,!1)}async function TP(n,t){return UN(n,t,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kP{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){if(typeof window>"u"||!tt().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,e);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return pN(t)}}if(tt().get("IS_BROWSER")){tt().setPlatform("browser",new kP);try{us.registerManager(ml.URL_SCHEME,new wP)}catch{}try{us.registerManager(pl.URL_SCHEME,new fP)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _P={importFetch:()=>require("node-fetch")};let ux;class NP{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return tt().global.fetch!=null?tt().global.fetch(t,e):(ux==null&&(ux=_P.importFetch()),ux(t,e))}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}tt().get("IS_NODE")&&!tt().get("IS_BROWSER")&&tt().setPlatform("node",new NP);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Re(n,t="float32",e){return t=t||"float32",pr(n),new Bu(n,t,e)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EP(n,t){const e=F(n,"x","cast");if(!uO(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&e.dtype!=="string"||t!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:e},r={dtype:t};return Q.runKernel(mm,s,r)}const Ue=q({cast_:EP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RP(n){const e={x:F(n,"x","clone","string_or_numeric")};return Q.runKernel(gm,e)}const Ya=q({clone_:RP});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WN(n,t=!1){console.log(n.toString(t))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */TN();const IP={buffer:Re,cast:Ue,clone:Ya,print:WN};zO(IP);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AP(n,t){let e=F(n,"a","add"),s=F(t,"b","add");[e,s]=hn(e,s);const r={a:e,b:s};return Q.runKernel(pm,r)}const zt=q({add_:AP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DP(n,t){let e=F(n,"a","floorDiv"),s=F(t,"b","floorDiv");[e,s]=hn(e,s);const r={a:e,b:s};return Q.runKernel(Bb,r)}const GN=q({floorDiv_:DP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OP(n,t){let e=F(n,"a","div"),s=F(t,"b","div");if([e,s]=hn(e,s),e.dtype==="int32"&&s.dtype==="int32")return GN(e,s);const r={a:e,b:s},i={};return Q.runKernel(Nb,r,i)}const ae=q({div_:OP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PP(n,t){let e=F(n,"a","mul"),s=F(t,"b","mul");[e,s]=hn(e,s);const r={a:e,b:s};return Q.runKernel(x1,r)}const wt=q({mul_:PP});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FP(n){const t=F(n,"x","abs");if(t.dtype==="complex64"){const e={x:t};return Q.runKernel(ub,e)}else{const e={x:t};return Q.runKernel(V0,e)}}const ur=q({abs_:FP});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LP(n){const e={x:F(n,"x","acos")};return Q.runKernel(U0,e)}const MP=q({acos_:LP});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zP(n){const e={x:F(n,"x","acosh")};return Q.runKernel(W0,e)}const BP=q({acosh_:zP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VP(n){M(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),M(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const t=n.map((r,i)=>F(r,`tensors${i}`,"addN")),e=t[0];t.forEach(r=>{if(r.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(r=>{if(!Ee(r.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=t;return Q.runKernel(G0,s)}const UP=q({addN_:VP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WP(n,t=null,e=!1){const r={x:F(n,"x","all","bool")},i={axis:t,keepDims:e};return Q.runKernel(H0,r,i)}const GP=q({all_:WP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HP(n,t=null,e=!1){const r={x:F(n,"x","any","bool")},i={axis:t,keepDims:e};return Q.runKernel(j0,r,i)}const jP=q({any_:HP});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XP(n,t=0){const s={x:F(n,"x","argMax")},r={axis:t};return Q.runKernel(X0,s,r)}const HN=q({argMax_:XP});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qP(n,t=0){const s={x:F(n,"x","argMin")},r={axis:t};return Q.runKernel(q0,s,r)}const KP=q({argMin_:qP});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YP(n){const e={x:F(n,"x","asin")};return Q.runKernel(K0,e)}const QP=q({asin_:YP});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZP(n){const e={x:F(n,"x","asinh")};return Q.runKernel(Y0,e)}const JP=q({asinh_:ZP});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tF(n){const e={x:F(n,"x","atan")};return Q.runKernel(Q0,e)}const eF=q({atan_:tF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nF(n,t){let e=F(n,"a","atan2"),s=F(t,"b","atan2");[e,s]=hn(e,s);const r={a:e,b:s};return Q.runKernel(J0,r)}const sF=q({atan2_:nF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rF(n){const e={x:F(n,"x","atanh")};return Q.runKernel(Z0,e)}const iF=q({atanh_:rF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vd(n,t,e,s,r="NHWC",i){const a=n[3],o=[...t,a],u=ri(r);return vn(n,o,e,i,s,null,null,u)}function Mr(n,t,e,s,r,i,a="channelsLast"){const[o,u]=Kh(t);let h;if(a==="channelsLast")h=[o,u,n[3],n[3]];else if(a==="channelsFirst")h=[o,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return vn(n,h,e,s,r,i,!1,a)}function la(n,t,e,s,r,i,a="NDHWC"){const[o,u,h]=Kx(t);let d,f;if(a==="NDHWC")f="channelsLast",d=[o,u,h,n[4],n[4]];else if(a==="NCDHW")f="channelsFirst",d=[o,u,h,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return oo(n,d,e,s,r,!1,f,i)}function vn(n,t,e,s,r,i,a=!1,o="channelsLast"){let[u,h,d,f]=[-1,-1,-1,-1];if(o==="channelsLast")[u,h,d,f]=n;else if(o==="channelsFirst")[u,f,h,d]=n;else throw new Error(`Unknown dataFormat ${o}`);const[m,y,,x]=t,[w,S]=Kh(e),[C,k]=Kh(s),E=Fu(m,C),R=Fu(y,k),{padInfo:A,outHeight:L,outWidth:V}=lF(r,h,d,w,S,E,R,i,o),B=a?x*f:x;let z;return o==="channelsFirst"?z=[u,B,L,V]:o==="channelsLast"&&(z=[u,L,V,B]),{batchSize:u,dataFormat:o,inHeight:h,inWidth:d,inChannels:f,outHeight:L,outWidth:V,outChannels:B,padInfo:A,strideHeight:w,strideWidth:S,filterHeight:m,filterWidth:y,effectiveFilterHeight:E,effectiveFilterWidth:R,dilationHeight:C,dilationWidth:k,inShape:n,outShape:z,filterShape:t}}function oo(n,t,e,s,r,i=!1,a="channelsLast",o){let[u,h,d,f,m]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[u,h,d,f,m]=n;else if(a==="channelsFirst")[u,m,h,d,f]=n;else throw new Error(`Unknown dataFormat ${a}`);const[y,x,w,,S]=t,[C,k,E]=Kx(e),[R,A,L]=Kx(s),V=Fu(y,R),B=Fu(x,A),z=Fu(w,L),{padInfo:U,outDepth:D,outHeight:Y,outWidth:nt}=uF(r,h,d,f,C,k,E,V,B,z,o),dt=i?S*m:S;let at;return a==="channelsFirst"?at=[u,dt,D,Y,nt]:a==="channelsLast"&&(at=[u,D,Y,nt,dt]),{batchSize:u,dataFormat:a,inDepth:h,inHeight:d,inWidth:f,inChannels:m,outDepth:D,outHeight:Y,outWidth:nt,outChannels:dt,padInfo:U,strideDepth:C,strideHeight:k,strideWidth:E,filterDepth:y,filterHeight:x,filterWidth:w,effectiveFilterDepth:V,effectiveFilterHeight:B,effectiveFilterWidth:z,dilationDepth:R,dilationHeight:A,dilationWidth:L,inShape:n,outShape:at,filterShape:t}}function aF(n,t,e,s,r){s==null&&(s=wv(n,t,e));const i=n[0],a=n[1],o=Yh((i-t+2*s)/e+1,r),u=Yh((a-t+2*s)/e+1,r);return[o,u]}function oF(n,t,e,s,r,i){r==null&&(r=wv(n,t[0],s[0]));const a=[0,0,0,e];for(let o=0;o<3;o++)n[o]+2*r>=t[o]&&(a[o]=Yh((n[o]-t[o]+2*r)/s[o]+1,i));return a}function wv(n,t,e,s=1){const r=Fu(t,s);return Math.floor((n[0]*(e-1)-e+r)/2)}function Kh(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function Kx(n){return typeof n=="number"?[n,n,n]:n}function Fu(n,t){return t<=1?n:n+(n-1)*(t-1)}function lF(n,t,e,s,r,i,a,o,u){let h,d,f;if(typeof n=="number"){h={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const y=aF([t,e],i,s,n,o);d=y[0],f=y[1]}else if(n==="same"){d=Math.ceil(t/s),f=Math.ceil(e/r);const m=Math.max(0,(d-1)*s+i-t),y=Math.max(0,(f-1)*r+a-e),x=Math.floor(m/2),w=m-x,S=Math.floor(y/2),C=y-S;h={top:x,bottom:w,left:S,right:C,type:"SAME"}}else if(n==="valid")h={top:0,bottom:0,left:0,right:0,type:"VALID"},d=Math.ceil((t-i+1)/s),f=Math.ceil((e-a+1)/r);else if(typeof n=="object"){const m=u==="channelsLast"?n[1][0]:n[2][0],y=u==="channelsLast"?n[1][1]:n[2][1],x=u==="channelsLast"?n[2][0]:n[3][0],w=u==="channelsLast"?n[2][1]:n[3][1];h={top:m,bottom:y,left:x,right:w,type:m===0&&y===0&&x===0&&w===0?"VALID":"EXPLICIT"},d=Yh((t-i+m+y)/s+1,o),f=Yh((e-a+x+w)/r+1,o)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outHeight:d,outWidth:f}}function uF(n,t,e,s,r,i,a,o,u,h,d){let f,m,y,x;if(n==="valid"&&(n=0),typeof n=="number"){f={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const S=oF([t,e,s,1],[o,u,h],1,[r,i,a],n,d);m=S[0],y=S[1],x=S[2]}else if(n==="same"){m=Math.ceil(t/r),y=Math.ceil(e/i),x=Math.ceil(s/a);const w=(m-1)*r+o-t,S=(y-1)*i+u-e,C=(x-1)*a+h-s,k=Math.floor(w/2),E=w-k,R=Math.floor(S/2),A=S-R,L=Math.floor(C/2),V=C-L;f={top:R,bottom:A,left:L,right:V,front:k,back:E,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:f,outDepth:m,outHeight:y,outWidth:x}}function Yh(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function Qh(n){const[t,e,s]=Kh(n);return t===1&&e===1&&s===1}function ps(n,t){return Qh(n)||Qh(t)}function gl(n){return Kh(n).every(t=>t>0)}function ri(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function zr(n,t,e){if(e!=null){if(typeof t=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if(typeof t=="number")M(zu(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else if(typeof t=="object")t.forEach(s=>{s.forEach(r=>{M(zu(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${t}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cF(n,t){const s={x:F(n,"x","reshape","string_or_numeric")},r={shape:t};return Q.runKernel(O1,s,r)}const ft=q({reshape_:cF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hF(n,t,e,s,r){const i=F(n,"x","avgPool","float32"),a=1;M(ps(e,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${a}'`);let o=i,u=!1;i.rank===3&&(u=!0,o=ft(i,[1,i.shape[0],i.shape[1],i.shape[2]])),M(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),zr("avgPool",s,r);const h={x:o},d={filterSize:t,strides:e,pad:s,dimRoundingMode:r};let f=Q.runKernel(tb,h,d);return f=Ue(f,i.dtype),u?ft(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const jN=q({avgPool_:hF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dF(n,t,e,s,r,i="NDHWC"){const a=F(n,"x","avgPool3d","float32");let o=a,u=!1;a.rank===4&&(u=!0,o=ft(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),M(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),M(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),M(typeof e=="number"&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),zr("avgPool3d",s,r);const h={x:o},d={filterSize:t,strides:e,pad:s,dimRoundingMode:r,dataFormat:i};let f=Q.runKernel(eb,h,d);return f=Ue(f,o.dtype),u?ft(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const fF=q({avgPool3d_:dF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pF(n,t=0){M(n.length>=1,()=>"Pass at least one tensor to concat");const e=jp(n,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"&&e.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),e.length===1)return Ya(e[0]);const s=e,r={axis:t};return Q.runKernel(cb,s,r)}const Rn=q({concat_:pF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mF(n,t,e=!1,s=!1){let r=F(n,"a","matMul"),i=F(t,"b","matMul");[r,i]=hn(r,i);const a={a:r,b:i},o={transposeA:e,transposeB:s};return Q.runKernel(nb,a,o)}const Pe=q({matMul_:mF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gF(n){const e={x:F(n,"x","sigmoid","float32")};return Q.runKernel(Y1,e)}const Zi=q({sigmoid_:gF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yF(n,t,e){const s=F(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},i={begin:t,size:e};return Q.runKernel(j1,r,i)}const re=q({slice_:yF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xF(n){const e={x:F(n,"x","tanh","float32")};return Q.runKernel(hv,e)}const Yx=q({tanh_:xF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bF(n,t,e,s,r,i){const a=F(n,"forgetBias","basicLSTMCell"),o=F(t,"lstmKernel","basicLSTMCell"),u=F(e,"lstmBias","basicLSTMCell"),h=F(s,"data","basicLSTMCell"),d=F(r,"c","basicLSTMCell"),f=F(i,"h","basicLSTMCell"),m=Rn([h,f],1),y=Pe(m,o),x=zt(y,u),w=x.shape[0],S=x.shape[1]/4,C=[w,S],k=re(x,[0,0],C),E=re(x,[0,S],C),R=re(x,[0,S*2],C),A=re(x,[0,S*3],C),L=zt(wt(Zi(k),Yx(E)),wt(d,Zi(zt(a,R)))),V=wt(Yx(L),Zi(A));return[L,V]}const vF=q({basicLSTMCell_:bF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wF(n,t,e){const s=F(n,"x","batchToSpaceND"),r=t.reduce((o,u)=>o*u);M(s.rank>=1+t.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`),M(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),M(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`);const i={x:s},a={blockShape:t,crops:e};return Q.runKernel(sb,i,a)}const XN=q({batchToSpaceND_:wF});function SF(n){let t;return n.rank===0||n.rank===1?t=ft(n,[1,1,1,n.size]):n.rank===2?t=ft(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?t=ft(n,[1,n.shape[0],n.shape[1],n.shape[2]]):t=n,t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CF(n,t,e,s,r,i){i==null&&(i=.001);const a=F(n,"x","batchNorm"),o=F(t,"mean","batchNorm"),u=F(e,"variance","batchNorm");let h;r!=null&&(h=F(r,"scale","batchNorm"));let d;s!=null&&(d=F(s,"offset","batchNorm")),M(o.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),M(d==null||o.rank===d.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),M(h==null||o.rank===h.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const m={x:SF(a),scale:h,offset:d,mean:o,variance:u},y={varianceEpsilon:i},x=Q.runKernel(Vb,m,y);return ft(x,a.shape)}const wm=q({batchNorm_:CF});function $F(n,t,e,s,r,i){const a=F(n,"x","batchNorm"),o=F(t,"mean","batchNorm"),u=F(e,"variance","batchNorm");let h;r!=null&&(h=F(r,"scale","batchNorm"));let d;return s!=null&&(d=F(s,"offset","batchNorm")),M(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),M(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),M(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),h!=null&&M(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${h.rank}.`),d!=null&&M(d.rank===2||d.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${d.rank}.`),wm(a,o,u,d,h,i)}const TF=q({batchNorm2d_:$F});function kF(n,t,e,s,r,i){const a=F(n,"x","batchNorm"),o=F(t,"mean","batchNorm"),u=F(e,"variance","batchNorm");let h;r!=null&&(h=F(r,"scale","batchNorm"));let d;return s!=null&&(d=F(s,"offset","batchNorm")),M(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),M(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),M(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),h!=null&&M(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${h.rank}.`),d!=null&&M(d.rank===3||d.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${d.rank}.`),wm(a,o,u,d,h,i)}const _F=q({batchNorm3d_:kF});function NF(n,t,e,s,r,i){const a=F(n,"x","batchNorm"),o=F(t,"mean","batchNorm"),u=F(e,"variance","batchNorm");let h;r!=null&&(h=F(r,"scale","batchNorm"));let d;return s!=null&&(d=F(s,"offset","batchNorm")),M(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),M(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),M(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),h!=null&&M(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${h.rank}.`),d!=null&&M(d.rank===4||d.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${d.rank}.`),wm(a,o,u,d,h,i)}const EF=q({batchNorm4d_:NF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RF(n,t,e){const s=F(n,"x","bincount"),r=F(t,"weights","bincount");M(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),M(e>=0,()=>`size must be non-negative, but got ${e}.`),M(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const i={x:s,weights:r},a={size:e};return Q.runKernel(rb,i,a)}const qN=q({bincount_:RF});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IF(n,t){const e=F(n,"x","bitwiseAnd"),s=F(t,"y","bitwiseAnd");if(!Ee(e.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${e.shape}, y: ${s.shape}`);if(e.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${e.dtype} and type of y: ${s.dtype}`);const r={a:e,b:s};return Q.runKernel(j_,r)}const AF=q({bitwiseAnd_:IF});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DF(n,t){const e=F(n,"s0","broadcastArgs","int32"),s=F(t,"s1","broadcastArgs","int32");if(e.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:e,s1:s};return Q.runKernel(ib,r)}const OF=q({broadcastArgs_:DF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PF(n,t){let e=F(n,"broadcastTo","x");const s=e.shape;if(pr(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const h=e.shape.slice();for(;h.length<t.length;)h.unshift(1);e=ft(e,h)}const r=e.shape,i=Array.from(t);for(let h=t.length-1;h>=0;h--)if(r[h]===t[h])i[h]=1;else if(e.shape[h]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);if(i.map((h,d)=>h>1?d:-1).filter(h=>h>=0).length===0)return Ya(e);const o={x:e},u={reps:i};return Q.runKernel(ym,o,u)}const Bh=q({broadcastTo_:PF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FF(n){const e={x:F(n,"x","ceil","float32")};return Q.runKernel(ab,e)}const LF=q({ceil_:FF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wd(n,t,e){pr(n),e=e||Qu(t);const s={shape:n,value:t,dtype:e};return Q.runKernel(Lb,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MF(n,t,e){const s=F(n,"x","clipByValue");if(M(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e)return wd(s.shape,t,s.dtype);const r={x:s},i={clipValueMin:t,clipValueMax:e};return Q.runKernel(ob,r,i)}const KN=q({clipByValue_:MF});function zF(n){return Rn(n,0)}const BF=q({concat1d_:zF});function VF(n,t){return Rn(n,t)}const UF=q({concat2d_:VF});function WF(n,t){return Rn(n,t)}const GF=q({concat3d_:WF});function HF(n,t){return Rn(n,t)}const jF=q({concat4d_:HF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XF(n,t,e,s,r="NHWC",i=[1,1],a){const o=F(n,"x","conv2d","float32"),u=F(t,"filter","conv2d","float32");let h=o,d=!1;o.rank===3&&(d=!0,h=ft(o,[1,o.shape[0],o.shape[1],o.shape[2]])),M(h.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${h.rank}.`),M(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),zr("conv2d",s,a);const f=r==="NHWC"?h.shape[3]:h.shape[1];M(f===u.shape[2],()=>`Error in conv2d: depth of input (${f}) must match input depth for filter ${u.shape[2]}.`),M(ps(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),M(gl(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),M(gl(e),()=>"Error in conv2D: Strides should be larger than 0.");const m={x:h,filter:u},y={strides:e,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a},x=Q.runKernel(hb,m,y);return d?ft(x,[x.shape[1],x.shape[2],x.shape[3]]):x}const Sm=q({conv2d_:XF});function qF(n,t,e,s,r="NWC",i=1,a){const o=F(n,"x","conv1d"),u=F(t,"filter","conv1d");let h=o,d=!1;o.rank===2&&(d=!0,h=ft(o,[1,o.shape[0],o.shape[1]])),M(h.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${h.rank}.`),M(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),zr("conv1d",s,a),M(h.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${h.shape[2]}) must match input depth for filter ${u.shape[1]}.`),M(ps(e,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${i}'`),M(gl(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),M(gl(e),()=>"Error in conv1D: Stride should be larger than 0."),M(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const f=ft(u,[1,u.shape[0],u.shape[1],u.shape[2]]),m=ft(h,[h.shape[0],1,h.shape[1],h.shape[2]]),S=Sm(m,f,[1,e],s,"NHWC",[1,i],a);return d?ft(S,[S.shape[2],S.shape[3]]):ft(S,[S.shape[0],S.shape[2],S.shape[3]])}const KF=q({conv1d_:qF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YF(n,t,e,s,r,i="NHWC",a){M(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let o=n,u=t,h=!1;t.rank===3&&(h=!0,u=ft(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,n[0],n[1],n[2]]),M(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),M(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),M(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const d=i==="NHWC"?o[3]:o[1],f=i==="NHWC"?u.shape[3]:u.shape[1];M(d===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${d}) must match input depth for filter ${e.shape[2]}.`),M(f===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${f}) must match output depth for filter ${e.shape[3]}.`),zr("conv2dDerInput",r,a);const m={dy:u,filter:e},y={strides:s,pad:r,dataFormat:i,dimRoundingMode:a,inputShape:o},x=Q.runKernel(fb,m,y);return h?ft(x,[x.shape[1],x.shape[2],x.shape[3]]):x}const YN=q({conv2DBackpropInput_:YF});function QF(n,t,e,s,r,i){const a=F(n,"x","conv2dTranspose"),o=F(t,"filter","conv2dTranspose");return YN(e,a,o,s,r,"NHWC",i)}const ZF=q({conv2dTranspose_:QF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JF(n,t,e,s,r="NDHWC",i=[1,1,1]){const a=F(n,"x","conv3d"),o=F(t,"filter","conv3d");let u=a,h=!1;a.rank===4&&(h=!0,u=ft(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),M(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),M(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),M(u.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${o.shape[3]}.`),M(ps(e,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),M(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),M(gl(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),M(gl(e),()=>"Error in conv3D: Strides should be larger than 0.");const d={x:u,filter:o},f={strides:e,pad:s,dataFormat:r,dilations:i},m=Q.runKernel(pb,d,f);return h?ft(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const tL=q({conv3d_:JF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eL(n,t,e,s,r){M(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let i=n,a=t,o=!1;t.rank===4&&(o=!0,a=ft(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const u=i[4],h=a.shape[4];M(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),M(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),M(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),M(u===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${e.shape[3]}.`),M(h===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${h}) must match output depth for filter ${e.shape[4]}.`);const d={dy:a,filter:e},f={pad:r,strides:s,inputShape:i},m=Q.runKernel(mb,d,f);return o?ft(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const nL=q({conv3DBackpropInput_:eL});function sL(n,t,e,s,r){const i=F(n,"x","conv3dTranspose"),a=F(t,"filter","conv3dTranspose");return nL(e,i,a,s,r)}const rL=q({conv3dTranspose_:sL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iL(n){const e={x:F(n,"x","cos","float32")};return Q.runKernel(gb,e)}const aL=q({cos_:iL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oL(n){const e={x:F(n,"x","cosh","float32")};return Q.runKernel(yb,e)}const lL=q({cosh_:oL});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uL(n,t=0,e=!1,s=!1){const i={x:F(n,"x","cumprod")},a={axis:t,exclusive:e,reverse:s};return Q.runKernel(xb,i,a)}const cL=q({cumprod_:uL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hL(n,t=0,e=!1,s=!1){const i={x:F(n,"x","cumsum")},a={axis:t,exclusive:e,reverse:s};return Q.runKernel(bb,i,a)}const dL=q({cumsum_:hL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fL(n,t,e,s=!1){const r=F(n,"x","denseBincount"),i=F(t,"weights","denseBincount");M(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),M(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),M(e>=0,()=>`size must be non-negative, but got ${e}.`),M(i.size===r.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`);const a={x:r,weights:i},o={size:e,binaryOutput:s};return Q.runKernel(wb,a,o)}const pL=q({denseBincount_:fL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mL(n,t,e="NHWC"){const s=F(n,"x","depthToSpace","float32"),r=e==="NHWC"?s.shape[1]:s.shape[2],i=e==="NHWC"?s.shape[2]:s.shape[3],a=e==="NHWC"?s.shape[3]:s.shape[1];M(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),M(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${t}  for depthToSpace with input shape
    ${s.shape}`),M(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${t} for depthToSpace with input shape
        ${s.shape}`),M(a%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${a} for depthToSpace with input shape ${s.shape}`);const o={x:s},u={blockSize:t,dataFormat:e};return Q.runKernel(Sb,o,u)}const gL=q({depthToSpace_:mL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yL(n,t,e,s,r="NHWC",i=[1,1],a){const o=F(n,"x","depthwiseConv2d","float32"),u=F(t,"filter","depthwiseConv2d","float32");let h=o,d=!1;o.rank===3&&(d=!0,h=ft(o,[1,o.shape[0],o.shape[1],o.shape[2]])),M(h.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),M(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const f=r==="NHWC"?h.shape[3]:h.shape[1];M(f===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${f}) must match the inChannels dimension in filter ${u.shape[2]}.`),zr("depthwiseConv2d",s,a);const m={x:h,filter:u},y={strides:e,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a},x=Q.runKernel(Cb,m,y);return d?ft(x,[x.shape[1],x.shape[2],x.shape[3]]):x}const Sv=q({depthwiseConv2d_:yL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xL(n){const e={x:F(n,"x","diag")};return Q.runKernel(kb,e)}const bL=q({diag_:xL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vL(n,t,e,s,r=[1,1],i="NHWC"){const a=F(n,"x","dilation2d"),o=F(t,"filter","dilation2d");M(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),M(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),M(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let u=a,h=!1;a.rank===3&&(u=ft(a,[1,a.shape[0],a.shape[1],a.shape[2]]),h=!0),M(u.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${o.shape[2]}`);const d={x:u,filter:o},f={strides:e,pad:s,dilations:r},m=Q.runKernel(_b,d,f);return h?ft(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const wL=q({dilation2d_:vL});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wu(n,t){const e=n.length,s=[];for(let r=0;r<e;r++){const i=e-1-r,a=n[i]||1;(t[t.length-1-r]||1)>1&&a===1&&s.unshift(i)}return s}function QN(n,t){const e=[];for(let s=0;s<t.length;s++){const r=n[n.length-s-1],i=t.length-s-1,a=t[i];(r==null||r===1&&a>1)&&e.unshift(i)}return e}function ne(n,t){const e=Math.max(n.length,t.length),s=new Array(e);for(let r=0;r<e;r++){let i=n[n.length-r-1];i==null&&(i=1);let a=t[t.length-r-1];if(a==null&&(a=1),i===1)s[e-r-1]=a;else if(a===1)s[e-r-1]=i;else if(i!==a){const o=`Operands could not be broadcast together with shapes ${n} and ${t}.`;throw Error(o)}else s[e-r-1]=i}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SL(n,t){let e=F(n,"a","equal","string_or_numeric"),s=F(t,"b","equal","string_or_numeric");[e,s]=hn(e,s),ne(e.shape,s.shape);const r={a:e,b:s};return Q.runKernel(Ab,r)}const ZN=q({equal_:SL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CL(n,t,e){const s=F(t,"a","where"),r=F(e,"b","where"),i=F(n,"condition","where","bool"),a=ne(ne(i.shape,s.shape),r.shape),o=Bh(i,a),u=Bh(s,a),h=Bh(r,a),d={condition:o,t:u,e:h};return Q.runKernel(G1,d)}const Qa=q({where_:CL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $L(n){const e={x:F(n,"x","zerosLike")};return Q.runKernel(gv,e)}const fr=q({zerosLike_:$L});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TL(n,t){let e=F(n,"a","div"),s=F(t,"b","div");[e,s]=hn(e,s);const r=ae(e,s),i=fr(r),a=ZN(s,i);return Qa(a,i,r)}const kL=q({divNoNan_:TL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _L(n,t){const e=F(n,"t1","dot"),s=F(t,"t2","dot");M((e.rank===1||e.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${s.rank}.`);const r=e.rank===1?e.size:e.shape[1],i=s.rank===1?s.size:s.shape[0];if(M(r===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`),e.rank===1&&s.rank===1){const a=ft(e,[1,-1]),o=ft(s,[-1,1]),u=Pe(a,o);return ft(u,[])}else if(e.rank===1&&s.rank===2){const a=ft(e,[1,-1]),o=ft(s,[s.shape[0],s.shape[1]]),u=Pe(a,o);return ft(u,[u.size])}else if(e.rank===2&&s.rank===1){const a=ft(s,[-1,1]),o=Pe(e,a);return ft(o,[o.size])}else{const a=ft(s,[s.shape[0],s.shape[1]]);return Pe(e,a)}}const NL=q({dot_:_L});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EL(n,...t){const e=t.map((r,i)=>F(r,`tensors${i}`,"einsum")),s={equation:n};return Q.runKernel(Eb,e,s)}const Au=q({einsum_:EL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RL(n){const e={x:F(n,"x","elu","float32")};return Q.runKernel(Rb,e)}const JN=q({elu_:RL});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IL(n,t){const e=F(n,"x","ensureShape","string_or_numeric");if(!oO(e.shape,t))throw new Error(`EnsureShape: Shape of tensor ${e.shape} is not compatible with expected shape ${t}`);return n}const AL=q({ensureShape_:IL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DL(n){let t=F(n,"x","erf");M(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Ue(t,"float32"));const e={x:t};return Q.runKernel(Ib,e)}const OL=q({erf_:DL});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cv(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function tE(n,t,e){const s=n.length+t.length,r=[];let i=0,a=0;for(let o=0;o<s;o++)e.indexOf(o)===-1?r.push(n[i++]):r.push(t[a++]);return r}function mr(n,t){const e=[],s=n.length;for(let i=0;i<s;i++)t.indexOf(i)===-1&&e.push(n[i]);const r=t.map(i=>n[i]);return[e,r]}function Ys(n,t){const e=t.map(s=>1);return tE(n,e,t)}function Qs(n,t,e){M(Cv(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function ts(n,t){if(Cv(n,t))return null;const e=[];for(let s=0;s<t;++s)n.indexOf(s)===-1&&e.push(s);return n.forEach(s=>e.push(s)),e}function Sd(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function es(n,t){const e=[];for(let s=t-n;s<t;++s)e.push(s);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PL(n,t=null,e=!1){const r={x:F(n,"x","max")},i={reductionIndices:t,keepDims:e};return Q.runKernel(o1,r,i)}const Lu=q({max_:PL});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FL(n,t=null,e=!1){const r={x:F(n,"x","min")},i={axis:t,keepDims:e};return Q.runKernel(f1,r,i)}const Qx=q({min_:FL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LL(n,t){let e=F(n,"base","pow"),s=F(t,"exp","pow");[e,s]=hn(e,s);const r={a:e,b:s};return Q.runKernel(_1,r)}const Zh=q({pow_:LL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ie(n,t){if((Pr(n)&&t!=="string"||Array.isArray(n))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&Pr(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ao(n,[],[],t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ML(n){const e={x:F(n,"x","sqrt","float32")};return Q.runKernel(Z1,e)}const sa=q({sqrt_:ML});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zL(n){const t=F(n,"x","square"),e={};return Q.runKernel("Square",{x:t},e)}const Dr=q({square_:zL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BL(n,t=null,e=!1){let s=F(n,"x","sum");s.dtype==="bool"&&(s=Ue(s,"int32"));const r={x:s},i={axis:t,keepDims:e};return Q.runKernel(J1,r,i)}const Ke=q({sum_:BL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VL(n,t="euclidean",e=null,s=!1){n=F(n,"x","norm");const r=eE(n,t,e);let i=r.shape;if(s){const a=Qe(e,n.shape);i=Ys(r.shape,a)}return ft(r,i)}function eE(n,t,e=null){if(n.rank===0)return ur(n);if(n.rank!==1&&e===null)return eE(ft(n,[-1]),t,e);if(n.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(t===1)return Ke(ur(n),e);if(t===1/0)return Lu(ur(n),e);if(t===-1/0)return Qx(ur(n),e);if(t==="euclidean"||t===2)return sa(Ke(Zh(ur(n),ie(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&e.length===2){if(t===1)return Lu(Ke(ur(n),e[0]),e[1]-1);if(t===1/0)return Lu(Ke(ur(n),e[1]),e[0]);if(t===-1/0)return Qx(Ke(ur(n),e[1]),e[0]);if(t==="fro"||t==="euclidean")return sa(Ke(Dr(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const Cm=q({norm_:VL});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UL(n,t=null,e=!1){return Cm(n,"euclidean",t,e)}const WL=q({euclideanNorm_:UL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GL(n){const e={x:F(n,"x","exp")};return Q.runKernel(Db,e)}const ra=q({exp_:GL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HL(n,t=0){const e=F(n,"x","expandDims","string_or_numeric");M(t<=e.rank,()=>"Axis must be <= rank of the tensor");const s={input:e},r={dim:t};return Q.runKernel(Ob,s,r)}const cr=q({expandDims_:HL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jL(n){const e={x:F(n,"x","expm1")};return Q.runKernel(Pb,e)}const XL=q({expm1_:jL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qL(n,t){const e=F(n,"x","tile","string_or_numeric");M(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`);const s={x:e},r={reps:t};return Q.runKernel(ym,s,r)}const Vh=q({tile_:qL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KL(n,t,e,s="float32"){t==null&&(t=n);const r=Re([n,t],s),i=n<=t?n:t;for(let o=0;o<i;++o)r.set(1,o,o);const a=ft(r.toTensor(),[n,t]);if(e==null)return a;if(e.length===1)return Vh(cr(a,0),[e[0],1,1]);if(e.length===2)return Vh(cr(cr(a,0),0),[e[0],e[1],1,1]);if(e.length===3)return Vh(cr(cr(cr(a,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}const nE=q({eye_:KL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YL(n){const e={x:F(n,"x","floor","float32")};return Q.runKernel(zb,e)}const sE=q({floor_:YL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QL(n,t,e=0,s=0){const r=F(n,"x","gather"),i=F(t,"indices","gather","int32"),a={x:r,indices:i},o={axis:e,batchDims:s};return Q.runKernel(Ub,a,o)}const rE=q({gather_:QL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZL(n,t){let e=F(n,"a","greater","string_or_numeric"),s=F(t,"b","greater","string_or_numeric");[e,s]=hn(e,s),ne(e.shape,s.shape);const r={a:e,b:s};return Q.runKernel(Gb,r)}const $m=q({greater_:ZL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JL(n,t){let e=F(n,"a","greaterEqual","string_or_numeric"),s=F(t,"b","greaterEqual","string_or_numeric");[e,s]=hn(e,s),ne(e.shape,s.shape);const r={a:e,b:s};return Q.runKernel(Hb,r)}const iE=q({greaterEqual_:JL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tM(n){const e={input:F(n,"input","imag")};return Q.runKernel(Xb,e)}const Tm=q({imag_:tM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eM(n){const e={x:F(n,"x","isFinite")};return Q.runKernel(qb,e)}const nM=q({isFinite_:eM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sM(n){const e={x:F(n,"x","isInf")};return Q.runKernel(Kb,e)}const rM=q({isInf_:sM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iM(n){const e={x:F(n,"x","isNaN")};return Q.runKernel(Yb,e)}const aM=q({isNaN_:iM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oM(n,t=.2){const s={x:F(n,"x","leakyRelu")},r={alpha:t};return Q.runKernel(Qb,s,r)}const aE=q({leakyRelu_:oM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lM(n,t){let e=F(n,"a","less","string_or_numeric"),s=F(t,"b","less","string_or_numeric");[e,s]=hn(e,s),ne(e.shape,s.shape);const r={a:e,b:s};return Q.runKernel(Zb,r)}const Zx=q({less_:lM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uM(n,t){let e=F(n,"a","lessEqual","string_or_numeric"),s=F(t,"b","lessEqual","string_or_numeric");[e,s]=hn(e,s),ne(e.shape,s.shape);const r={a:e,b:s};return Q.runKernel(Jb,r)}const $v=q({lessEqual_:uM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cM(n,t,e){if(e<=0)throw new Error("The number of values should be positive.");const s={start:n,stop:t,num:e};return Q.runKernel(t1,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hM(n,t=5,e=1,s=1,r=.5){const i=F(n,"x","localResponseNormalization");M(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),M(zu(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let a=i,o=!1;i.rank===3&&(o=!0,a=ft(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const u={x:a},h={depthRadius:t,bias:e,alpha:s,beta:r},d=Q.runKernel(a1,u,h);return o?ft(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const dM=q({localResponseNormalization_:hM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fM(n){const e={x:F(n,"x","log","float32")};return Q.runKernel(e1,e)}const Jh=q({log_:fM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pM(n){const e={x:F(n,"x","log1p")};return Q.runKernel(n1,e)}const oE=q({log1p_:pM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mM(n,t){M(Fx(n),()=>"The f passed in variableGrads(f) must be a function"),M(t==null||Array.isArray(t)&&t.every(h=>h instanceof Hp),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=t!=null;if(!e){t=[];for(const h in Q.registeredVariables)t.push(Q.registeredVariables[h])}const s=e?t.filter(h=>!h.trainable):null,r=t.length;t=t.filter(h=>h.trainable),M(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const i=!0,{value:a,grads:o}=Q.gradients(n,t,null,i);M(o.some(h=>h!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),M(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const u={};return t.forEach((h,d)=>{o[d]!=null&&(u[h.name]=o[d])}),s?.forEach(h=>u[h.name]=null),{value:a,grads:u}}function ia(n){return Q.customGrad(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gM(n){const e={x:F(n,"x","neg")};return Q.runKernel(b1,e)}const bi=q({neg_:gM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yM(n){const e={x:F(n,"x","softplus")};return Q.runKernel(Q1,e)}const lE=q({softplus_:yM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xM(n){const t=F(n,"x","logSigmoid");return ia(s=>({value:bi(lE(bi(s))),gradFunc:a=>wt(a,Zi(bi(s)))}))(t)}const bM=q({logSigmoid_:xM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vM(n,t){let e=F(n,"a","sub"),s=F(t,"b","sub");[e,s]=hn(e,s);const r={a:e,b:s};return Q.runKernel(uv,r)}const Jt=q({sub_:vM});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wM(n,t=-1){const e=F(n,"logits","logSoftmax");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return ia((r,i)=>{const o=Lu(r,t,!0),u=Jt(r,o),h=Jt(Ue(u,"float32"),Jh(Ke(ra(u),t,!0)));return i([h]),{value:h,gradFunc:(f,m)=>{const[y]=m,x=!0,w=ra(y);return Jt(f,wt(Ke(f,t,x),w))}}})(e)}const SM=q({logSoftmax_:wM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CM(n,t=null,e=!1){const s=F(n,"x","logSumExp"),r=Qe(t,s.shape),i=Lu(s,r,!0),a=Jt(s,i),o=ra(a),u=Ke(o,r),h=Jh(u),d=zt(ft(i,h.shape),h);if(e){const f=Ys(d.shape,r);return ft(d,f)}return d}const uE=q({logSumExp_:CM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $M(n,t){const e=F(n,"a","logicalAnd","bool"),s=F(t,"b","logicalAnd","bool");ne(e.shape,s.shape);const r={a:e,b:s};return Q.runKernel(s1,r)}const Xp=q({logicalAnd_:$M});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TM(n){const e={x:F(n,"x","logicalNot","bool")};return Q.runKernel(r1,e)}const cE=q({logicalNot_:TM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kM(n,t){const e=F(n,"a","logicalOr","bool"),s=F(t,"b","logicalOr","bool");ne(e.shape,s.shape);const r={a:e,b:s};return Q.runKernel(i1,r)}const hE=q({logicalOr_:kM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _M(n,t){const e=F(n,"a","logicalXor","bool"),s=F(t,"b","logicalXor","bool");return ne(e.shape,s.shape),Xp(hE(n,t),cE(Xp(n,t)))}const NM=q({logicalXor_:_M});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qf=2147483648;function EM(n,t,e="left"){const s=F(n,"sortedSequence","searchSorted"),r=F(t,"values","searchSorted"),i=s.shape[s.shape.length-1],a=r.shape[r.shape.length-1],o=ft(s,[-1,i]),u=ft(r,[-1,a]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(ht(u.shape)>=Qf)throw new Error(`values tensor size must less than ${Qf}`);if(o.shape[1]>=Qf)throw new Error(`trailing dim_size must less than ${Qf} for int32 output type, was ${o.shape[1]}`);const h={sortedSequence:o,values:u},d={side:e};return Q.runKernel(W1,h,d)}const Tv=q({searchSorted_:EM});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RM(n,t){return Tv(n,t,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IM(n,t,e,s,r){const i=F(n,"x","maxPool"),a=1;let o=i,u=!1;i.rank===3&&(u=!0,o=ft(i,[1,i.shape[0],i.shape[1],i.shape[2]])),M(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),M(ps(e,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${a}'`),zr("maxPool",s,r);const h={x:o},d={filterSize:t,strides:e,pad:s,dimRoundingMode:r},f=Q.runKernel(u1,h,d);return u?ft(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const dE=q({maxPool_:IM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AM(n,t=[1,1,1],e,s,r,i="NDHWC"){const a=F(n,"x","maxPool3d");let o=a,u=!1;a.rank===4&&(u=!0,o=ft(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),M(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),M(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),zr("maxPool3d",s,r);const h={x:o},d={filterSize:t,strides:e,pad:s,dimRoundingMode:r,dataFormat:i},f=Q.runKernel(c1,h,d);return u?ft(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const DM=q({maxPool3d_:AM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OM(n,t,e,s,r=!1){const a={x:F(n,"x","maxPoolWithArgmax")},o={filterSize:t,strides:e,pad:s,includeBatchInIndex:r},u=Q.runKernel(h1,a,o);return{result:u[0],indexes:u[1]}}const PM=q({maxPoolWithArgmax_:OM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FM(n,t){let e=F(n,"a","maximum"),s=F(t,"b","maximum");[e,s]=hn(e,s),e.dtype==="bool"&&(e=Ue(e,"int32"),s=Ue(s,"int32")),ne(e.shape,s.shape);const r={a:e,b:s};return Q.runKernel(l1,r)}const fE=q({maximum_:FM});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LM(n,t=null,e=!1){const r={x:F(n,"x","mean")},i={axis:t,keepDims:e};return Q.runKernel(d1,r,i)}const qp=q({mean_:LM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aa(n,t="float32"){if(pr(n),t==="complex64"){const s=aa(n,"float32"),r=aa(n,"float32");return Ja(s,r)}const e=ta(ht(n),t);return Q.makeTensor(e,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rl(n,t="float32"){if(pr(n),t==="complex64"){const s=rl(n,"float32"),r=aa(n,"float32");return Ja(s,r)}const e=V_(ht(n),t);return Q.makeTensor(e,n,t)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MM(n,t,{indexing:e="xy"}={}){if(e!=="xy"&&e!=="ij")throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(n===void 0)return[];let s=F(n,"x","meshgrid",n instanceof un?n.dtype:"float32");if(t===void 0)return[s];let r=F(t,"y","meshgrid",t instanceof un?t.dtype:"float32");const i=ht(s.shape),a=ht(r.shape);return e==="xy"?(s=ft(s,[1,-1]),r=ft(r,[-1,1]),[Pe(rl([a,1],s.dtype),s),Pe(r,rl([1,i],r.dtype))]):(s=ft(s,[-1,1]),r=ft(r,[1,-1]),[Pe(s,rl([1,a],s.dtype)),Pe(rl([i,1],r.dtype),r)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zM(n,t){let e=F(n,"a","minimum"),s=F(t,"b","minimum");[e,s]=hn(e,s),e.dtype==="bool"&&(e=Ue(e,"int32"),s=Ue(s,"int32")),ne(e.shape,s.shape);const r={a:e,b:s};return Q.runKernel(p1,r)}const td=q({minimum_:zM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BM(n,t,e){M(e==="reflect"||e==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const s=F(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");M(t.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`);const r=e==="reflect"?1:0;for(let o=0;o<s.rank;o++)M(t[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),M(t[o][0]>=0&&t[o][0]<=s.shape[o]-r&&t[o][1]>=0&&t[o][1]<=s.shape[o]-r,()=>`Padding in dimension ${o} cannot be greater than or equal to ${s.shape[o]-r} or less than 0 for input of shape ${s.shape}`);const i={paddings:t,mode:e},a={x:s};return Q.runKernel(m1,a,i)}const pE=q({mirrorPad_:BM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VM(n,t){let e=F(n,"a","mod"),s=F(t,"b","mod");[e,s]=hn(e,s);const r={a:e,b:s};return Q.runKernel(g1,r)}const UM=q({mod_:VM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WM(n,t=null,e=!1){n=F(n,"x","moments");const s=Qe(t,n.shape),r=qp(n,s,e);let i=r.shape;e||(i=Ys(r.shape,s));const a=Dr(Jt(Ue(n,"float32"),ft(r,i))),o=qp(a,s,e);return{mean:r,variance:o}}const GM=q({moments_:WM});function HM(n,t,e,s){const r=F(t,"data","multiRNNCell"),i=jp(e,"c","multiRNNCell"),a=jp(s,"h","multiRNNCell");let o=r;const u=[];for(let f=0;f<n.length;f++){const m=n[f](o,i[f],a[f]);u.push(m[0]),u.push(m[1]),o=m[1]}const h=[],d=[];for(let f=0;f<u.length;f+=2)h.push(u[f]),d.push(u[f+1]);return[h,d]}const jM=q({multiRNNCell_:HM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XM(n,t,e,s=!1){const r=F(n,"logits","multinomial"),i=r.size,a=r.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);e=e||Math.random();const u={logits:a===1?ft(r,[1,-1]):r},h={numSamples:t,seed:e,normalized:s},d=Q.runKernel(y1,u,h);return a===1?ft(d,[d.size]):d}const qM=q({multinomial_:XM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KM(n,t){let e=F(n,"a","notEqual","string_or_numeric"),s=F(t,"b","notEqual","string_or_numeric");[e,s]=hn(e,s),ne(e.shape,s.shape);const r={a:e,b:s};return Q.runKernel(v1,r)}const mE=q({notEqual_:KM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YM(n,t,e=1,s=0,r="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const a={indices:F(n,"indices","oneHot","int32")},o={dtype:r,depth:t,onValue:e,offValue:s};return Q.runKernel($1,a,o)}const QM=q({oneHot_:YM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZM(n){const e={x:F(n,"x","onesLike")};return Q.runKernel(C1,e)}const JM=q({onesLike_:ZM});function tz(n,t){const e=F(n,"v1","outerProduct"),s=F(t,"v2","outerProduct");M(e.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${s.rank}.`);const r=ft(e,[-1,1]),i=ft(s,[1,-1]);return Pe(r,i)}const ez=q({outerProduct_:tz});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nz(n,t,e=0){const s=F(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:t,constantValue:e},i={x:s};return Q.runKernel(k1,i,r)}const eo=q({pad_:nz});function sz(n,t,e=0){return M(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),eo(n,[t],e)}const rz=q({pad1d_:sz});function iz(n,t,e=0){return M(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),eo(n,t,e)}const az=q({pad2d_:iz});function oz(n,t,e=0){return M(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),eo(n,t,e)}const lz=q({pad3d_:oz});function uz(n,t,e=0){return M(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),eo(n,t,e)}const cz=q({pad4d_:uz});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hz(n,t,e){const s=F(n,"x","spaceToBatchND");M(s.rank>=1+t.length,()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`),M(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),M(s.shape.reduce((a,o,u)=>u>0&&u<=t.length?a&&(o+e[u-1][0]+e[u-1][1])%t[u-1]===0:a,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);const r={x:s},i={blockShape:t,paddings:e};return Q.runKernel(tv,r,i)}const gE=q({spaceToBatchND_:hz});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dz(n,t,e,s,r,i,a){r==null&&(r=[1,1]),i==null&&(i=1),s===0&&(s="valid");const o=F(n,"x","maxPool");let u=o,h=!1;o.rank===3&&(h=!0,u=ft(o,[1,o.shape[0],o.shape[1],o.shape[2]])),M(ps(i,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`);const d=Mr(u.shape,t,i,r,s),f=[d.dilationHeight,d.dilationWidth];let m;s==="same"?m=pz([d.filterHeight,d.filterWidth],f):m=[[0,0],[0,0]];const y=f[0]===1&&f[1]===1,[x,w]=fz([d.inHeight,d.inWidth],f,m),S=y?s:"valid",C=y?u:gE(u,f,x),E=(e==="avg"?()=>jN(C,t,i,S,a):()=>dE(C,t,i,S,a))(),R=y?E:XN(E,f,w);return h?ft(R,[R.shape[1],R.shape[2],R.shape[3]]):R}function fz(n,t,e){const s=e.map(d=>d[0]),r=e.map(d=>d[1]),i=n.concat(s,r),a=t.map((d,f)=>(d-i[f]%d)%d),o=r.map((d,f)=>d+a[f]),u=t.map((d,f)=>[s[f],o[f]]),h=t.map((d,f)=>[0,a[f]]);return[u,h]}function pz(n,t){const s=n.map((a,o)=>a+(a-1)*(t[o]-1)).map(a=>a-1),r=s.map(a=>Math.floor(a/2)),i=s.map((a,o)=>a-r[o]);return s.map((a,o)=>[r[o],i[o]])}const mz=q({pool_:dz});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gz(n,t){const e=F(n,"x","prelu"),s=F(t,"alpha","prelu"),r={x:e,alpha:s};return Q.runKernel(N1,r)}const yE=q({prelu_:gz});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yz(n,t=null,e=!1){let s=F(n,"x","prod");s.dtype==="bool"&&(s=Ue(s,"int32"));const r={x:s},i={axis:t,keepDims:e};return Q.runKernel(E1,r,i)}const xz=q({prod_:yz});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bz(n,t,e,s){const r=n.map((d,f)=>F(d,`tensors${f}`,"raggedGather","int32")),i=F(t,"paramsDenseValues","raggedGather"),a=F(e,"indices","raggedGather","int32"),o={paramsNestedSplits:r,paramsDenseValues:i,indices:a},u={outputRaggedRank:s},h=Q.runKernel(tN,o,u);return{outputNestedSplits:h.slice(0,h.length-1),outputDenseValues:h[h.length-1]}}const vz=q({raggedGather_:bz});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wz(n,t,e){const s=F(n,"starts","raggedRange"),r=F(t,"limits","raggedRange",s.dtype),i=F(e,"deltas","raggedRange",s.dtype),a={starts:s,limits:r,deltas:i},o=Q.runKernel(eN,a);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}const Sz=q({raggedRange_:wz});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cz(n,t,e,s,r){const i=F(n,"shape","raggedTensorToTensor","int32"),a=F(t,"values","raggedTensorToTensor"),o=F(e,"defaultValue","raggedTensorToTensor",a.dtype),u=s.map((f,m)=>F(f,`tensors${m}`,"raggedTensorToTensor","int32")),h={shape:i,values:a,defaultValue:o,rowPartitionTensors:u},d={rowPartitionTypes:r};return Q.runKernel(nN,h,d)}const $z=q({raggedTensorToTensor_:Cz});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tz(n,t,e){pr(n);const s=ht(n);let r=null;if(e==null||e==="float32")r=new Float32Array(s);else if(e==="int32")r=new Int32Array(s);else if(e==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${e}`);for(let i=0;i<s;i++)r[i]=t();return Q.makeTensor(r,n,e)}const kz=q({rand_:Tz});var wp={exports:{}},_z=wp.exports,k$;function Nz(){return k$||(k$=1,(function(n){(function(t,e,s){function r(u){var h=this,d=o();h.next=function(){var f=2091639*h.s0+h.c*23283064365386963e-26;return h.s0=h.s1,h.s1=h.s2,h.s2=f-(h.c=f|0)},h.c=1,h.s0=d(" "),h.s1=d(" "),h.s2=d(" "),h.s0-=d(u),h.s0<0&&(h.s0+=1),h.s1-=d(u),h.s1<0&&(h.s1+=1),h.s2-=d(u),h.s2<0&&(h.s2+=1),d=null}function i(u,h){return h.c=u.c,h.s0=u.s0,h.s1=u.s1,h.s2=u.s2,h}function a(u,h){var d=new r(u),f=h&&h.state,m=d.next;return m.int32=function(){return d.next()*4294967296|0},m.double=function(){return m()+(m()*2097152|0)*11102230246251565e-32},m.quick=m,f&&(typeof f=="object"&&i(f,d),m.state=function(){return i(d,{})}),m}function o(){var u=4022871197,h=function(d){d=String(d);for(var f=0;f<d.length;f++){u+=d.charCodeAt(f);var m=.02519603282416938*u;u=m>>>0,m-=u,m*=u,u=m>>>0,m-=u,u+=m*4294967296}return(u>>>0)*23283064365386963e-26};return h}e&&e.exports?e.exports=a:this.alea=a})(_z,n)})(wp)),wp.exports}var Sp={exports:{}},Ez=Sp.exports,_$;function Rz(){return _$||(_$=1,(function(n){(function(t,e,s){function r(o){var u=this,h="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var f=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^f^f>>>8},o===(o|0)?u.x=o:h+=o;for(var d=0;d<h.length+64;d++)u.x^=h.charCodeAt(d)|0,u.next()}function i(o,u){return u.x=o.x,u.y=o.y,u.z=o.z,u.w=o.w,u}function a(o,u){var h=new r(o),d=u&&u.state,f=function(){return(h.next()>>>0)/4294967296};return f.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,x=(m+y)/(1<<21);while(x===0);return x},f.int32=h.next,f.quick=f,d&&(typeof d=="object"&&i(d,h),f.state=function(){return i(h,{})}),f}e&&e.exports?e.exports=a:this.xor128=a})(Ez,n)})(Sp)),Sp.exports}var Cp={exports:{}},Iz=Cp.exports,N$;function Az(){return N$||(N$=1,(function(n){(function(t,e,s){function r(o){var u=this,h="";u.next=function(){var f=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(f^f<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,o===(o|0)?u.x=o:h+=o;for(var d=0;d<h.length+64;d++)u.x^=h.charCodeAt(d)|0,d==h.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function i(o,u){return u.x=o.x,u.y=o.y,u.z=o.z,u.w=o.w,u.v=o.v,u.d=o.d,u}function a(o,u){var h=new r(o),d=u&&u.state,f=function(){return(h.next()>>>0)/4294967296};return f.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,x=(m+y)/(1<<21);while(x===0);return x},f.int32=h.next,f.quick=f,d&&(typeof d=="object"&&i(d,h),f.state=function(){return i(h,{})}),f}e&&e.exports?e.exports=a:this.xorwow=a})(Iz,n)})(Cp)),Cp.exports}var $p={exports:{}},Dz=$p.exports,E$;function Oz(){return E$||(E$=1,(function(n){(function(t,e,s){function r(o){var u=this;u.next=function(){var d=u.x,f=u.i,m,y;return m=d[f],m^=m>>>7,y=m^m<<24,m=d[f+1&7],y^=m^m>>>10,m=d[f+3&7],y^=m^m>>>3,m=d[f+4&7],y^=m^m<<7,m=d[f+7&7],m=m^m<<13,y^=m^m<<9,d[f]=y,u.i=f+1&7,y};function h(d,f){var m,y=[];if(f===(f|0))y[0]=f;else for(f=""+f,m=0;m<f.length;++m)y[m&7]=y[m&7]<<15^f.charCodeAt(m)+y[m+1&7]<<13;for(;y.length<8;)y.push(0);for(m=0;m<8&&y[m]===0;++m);for(m==8?y[7]=-1:y[m],d.x=y,d.i=0,m=256;m>0;--m)d.next()}h(u,o)}function i(o,u){return u.x=o.x.slice(),u.i=o.i,u}function a(o,u){o==null&&(o=+new Date);var h=new r(o),d=u&&u.state,f=function(){return(h.next()>>>0)/4294967296};return f.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,x=(m+y)/(1<<21);while(x===0);return x},f.int32=h.next,f.quick=f,d&&(d.x&&i(d,h),f.state=function(){return i(h,{})}),f}e&&e.exports?e.exports=a:this.xorshift7=a})(Dz,n)})($p)),$p.exports}var Tp={exports:{}},Pz=Tp.exports,R$;function Fz(){return R$||(R$=1,(function(n){(function(t,e,s){function r(o){var u=this;u.next=function(){var d=u.w,f=u.X,m=u.i,y,x;return u.w=d=d+1640531527|0,x=f[m+34&127],y=f[m=m+1&127],x^=x<<13,y^=y<<17,x^=x>>>15,y^=y>>>12,x=f[m]=x^y,u.i=m,x+(d^d>>>16)|0};function h(d,f){var m,y,x,w,S,C=[],k=128;for(f===(f|0)?(y=f,f=null):(f=f+"\0",y=0,k=Math.max(k,f.length)),x=0,w=-32;w<k;++w)f&&(y^=f.charCodeAt((w+32)%f.length)),w===0&&(S=y),y^=y<<10,y^=y>>>15,y^=y<<4,y^=y>>>13,w>=0&&(S=S+1640531527|0,m=C[w&127]^=y+S,x=m==0?x+1:0);for(x>=128&&(C[(f&&f.length||0)&127]=-1),x=127,w=512;w>0;--w)y=C[x+34&127],m=C[x=x+1&127],y^=y<<13,m^=m<<17,y^=y>>>15,m^=m>>>12,C[x]=y^m;d.w=S,d.X=C,d.i=x}h(u,o)}function i(o,u){return u.i=o.i,u.w=o.w,u.X=o.X.slice(),u}function a(o,u){o==null&&(o=+new Date);var h=new r(o),d=u&&u.state,f=function(){return(h.next()>>>0)/4294967296};return f.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,x=(m+y)/(1<<21);while(x===0);return x},f.int32=h.next,f.quick=f,d&&(d.X&&i(d,h),f.state=function(){return i(h,{})}),f}e&&e.exports?e.exports=a:this.xor4096=a})(Pz,n)})(Tp)),Tp.exports}var kp={exports:{}},Lz=kp.exports,I$;function Mz(){return I$||(I$=1,(function(n){(function(t,e,s){function r(o){var u=this,h="";u.next=function(){var f=u.b,m=u.c,y=u.d,x=u.a;return f=f<<25^f>>>7^m,m=m-y|0,y=y<<24^y>>>8^x,x=x-f|0,u.b=f=f<<20^f>>>12^m,u.c=m=m-y|0,u.d=y<<16^m>>>16^x,u.a=x-f|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,o===Math.floor(o)?(u.a=o/4294967296|0,u.b=o|0):h+=o;for(var d=0;d<h.length+20;d++)u.b^=h.charCodeAt(d)|0,u.next()}function i(o,u){return u.a=o.a,u.b=o.b,u.c=o.c,u.d=o.d,u}function a(o,u){var h=new r(o),d=u&&u.state,f=function(){return(h.next()>>>0)/4294967296};return f.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,x=(m+y)/(1<<21);while(x===0);return x},f.int32=h.next,f.quick=f,d&&(typeof d=="object"&&i(d,h),f.state=function(){return i(h,{})}),f}e&&e.exports?e.exports=a:this.tychei=a})(Lz,n)})(kp)),kp.exports}var _p={exports:{}};const zz={},Bz=Object.freeze(Object.defineProperty({__proto__:null,default:zz},Symbol.toStringTag,{value:"Module"})),Vz=WD(Bz);var Uz=_p.exports,A$;function Wz(){return A$||(A$=1,(function(n){(function(t,e,s){var r=256,i=6,a=52,o="random",u=s.pow(r,i),h=s.pow(2,a),d=h*2,f=r-1,m;function y(R,A,L){var V=[];A=A==!0?{entropy:!0}:A||{};var B=C(S(A.entropy?[R,E(e)]:R??k(),3),V),z=new x(V),U=function(){for(var D=z.g(i),Y=u,nt=0;D<h;)D=(D+nt)*r,Y*=r,nt=z.g(1);for(;D>=d;)D/=2,Y/=2,nt>>>=1;return(D+nt)/Y};return U.int32=function(){return z.g(4)|0},U.quick=function(){return z.g(4)/4294967296},U.double=U,C(E(z.S),e),(A.pass||L||function(D,Y,nt,dt){return dt&&(dt.S&&w(dt,z),D.state=function(){return w(z,{})}),nt?(s[o]=D,Y):D})(U,B,"global"in A?A.global:this==s,A.state)}function x(R){var A,L=R.length,V=this,B=0,z=V.i=V.j=0,U=V.S=[];for(L||(R=[L++]);B<r;)U[B]=B++;for(B=0;B<r;B++)U[B]=U[z=f&z+R[B%L]+(A=U[B])],U[z]=A;(V.g=function(D){for(var Y,nt=0,dt=V.i,at=V.j,K=V.S;D--;)Y=K[dt=f&dt+1],nt=nt*r+K[f&(K[dt]=K[at=f&at+Y])+(K[at]=Y)];return V.i=dt,V.j=at,nt})(r)}function w(R,A){return A.i=R.i,A.j=R.j,A.S=R.S.slice(),A}function S(R,A){var L=[],V=typeof R,B;if(A&&V=="object")for(B in R)try{L.push(S(R[B],A-1))}catch{}return L.length?L:V=="string"?R:R+"\0"}function C(R,A){for(var L=R+"",V,B=0;B<L.length;)A[f&B]=f&(V^=A[f&B]*19)+L.charCodeAt(B++);return E(A)}function k(){try{var R;return m&&(R=m.randomBytes)?R=R(r):(R=new Uint8Array(r),(t.crypto||t.msCrypto).getRandomValues(R)),E(R)}catch{var A=t.navigator,L=A&&A.plugins;return[+new Date,t,L,t.screen,E(e)]}}function E(R){return String.fromCharCode.apply(0,R)}if(C(s.random(),e),n.exports){n.exports=y;try{m=Vz}catch{}}else s["seed"+o]=y})(typeof self<"u"?self:Uz,[],Math)})(_p)),_p.exports}var cx,D$;function Gz(){if(D$)return cx;D$=1;var n=Nz(),t=Rz(),e=Az(),s=Oz(),r=Fz(),i=Mz(),a=Wz();return a.alea=n,a.xor128=t,a.xorwow=e,a.xorshift7=s,a.xor4096=r,a.tychei=i,cx=a,cx}var kv=Gz();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _v{constructor(t,e,s,r,i){this.mean=t,this.stdDev=e,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const a=i||Math.random();this.random=kv.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let t,e,s=!1;for(;!s;){let r,i,a;do r=2*this.random()-1,i=2*this.random()-1,a=r*r+i*i;while(a>=1||a===0);const o=Math.sqrt(-2*Math.log(a)/a);t=this.mean+this.stdDev*r*o,e=this.mean+this.stdDev*i*o,(!this.truncated||this.isValidTruncated(t))&&(s=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class Hz{constructor(t,e,s,r){this.alpha=t,this.beta=1/e,this.dtype=s;const i=r||Math.random();this.randu=kv.alea(i.toString()),this.randn=new _v(0,1,s,!1,this.randu()),t<1?this.d=t+2/3:this.d=t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,s,r,i,a;for(;;){do r=this.randn.nextValue(),a=1+this.c*r;while(a<=0);if(a*=a*a,t=r*r,e=1-.331*t*t,s=.5*t+this.d*(1-a+Math.log(a)),i=this.randu(),i<e||Math.log(i)<s)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(t){return this.dtype==="float32"?t:Math.round(t)}}class jz{constructor(t=0,e=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=e-t,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=kv.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xz(n,t,e=1,s="float32",r){if(pr(n),e==null&&(e=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const i=new Hz(t,e,s,r),a=Re(n,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const qz=q({randomGamma_:Xz});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kz(n,t=0,e=1,s,r){if(pr(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const i=new _v(t,e,s,!1,r),a=Re(n,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const xE=q({randomNormal_:Kz});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yz(n,t,e){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return xE(n,0,1,t,e)}const Qz=q({randomStandardNormal_:Yz});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zz(n,t=0,e=1,s="float32",r){pr(n);const i=Re(n,s),a=new jz(t,e,null,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const Nv=q({randomUniform_:Zz});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jz(n,t,e,s){return Nv(n,t,e,"int32",s)}const tB=q({randomUniformInt_:Jz});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ed(n,t,e=1,s="float32"){if(e===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:t,step:e,dtype:s};return Q.runKernel(R1,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eB(n){const e={input:F(n,"input","real")};return Q.runKernel(I1,e)}const nd=q({real_:eB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nB(n){const e={x:F(n,"x","reciprocal")};return Q.runKernel(A1,e)}const sB=q({reciprocal_:nB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rB(n){const e={x:F(n,"x","relu")};return Q.runKernel(D1,e)}const km=q({relu_:rB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iB(n){const e={x:F(n,"x","relu6")};return Q.runKernel(L1,e)}const bE=q({relu6_:iB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aB(n,t){const s={x:F(n,"x","reverse")},r={dims:t};return Q.runKernel(M1,s,r)}const yl=q({reverse_:aB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oB(n){const t=F(n,"x","reverse");return M(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),yl(t,0)}const lB=q({reverse1d_:oB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uB(n,t){const e=F(n,"x","reverse");return M(e.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),yl(e,t)}const cB=q({reverse2d_:uB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hB(n,t){const e=F(n,"x","reverse");return M(e.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),yl(e,t)}const dB=q({reverse3d_:hB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fB(n,t){const e=F(n,"x","reverse");return M(e.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),yl(e,t)}const pB=q({reverse4d_:fB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mB(n){const e={x:F(n,"x","round")};return Q.runKernel(z1,e)}const vE=q({round_:mB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gB(n){const e={x:F(n,"x","rsqrt","float32")};return Q.runKernel(B1,e)}const yB=q({rsqrt_:gB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xB(n){const e={x:F(n,"x","selu")};return Q.runKernel(H1,e)}const bB=q({selu_:xB});function vB(n,t,e,s,r,i=[1,1],a="NHWC"){const o=F(n,"x","separableConv2d"),u=F(t,"depthwiseFilter","separableConv2d"),h=F(e,"pointwiseFilter","separableConv2d");let d=o,f=!1;if(o.rank===3&&(f=!0,d=ft(o,[1,o.shape[0],o.shape[1],o.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");M(d.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${d.rank}.`),M(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),M(h.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),M(h.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${h.shape[0]}.`),M(h.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${h.shape[1]}.`);const m=u.shape[2],y=u.shape[3];M(h.shape[2]===m*y,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*y}, but got ${h.shape[2]}.`);const x=Sv(d,u,s,r,a,i),S=Sm(x,h,1,"valid",a);return f?ft(S,[S.shape[1],S.shape[2],S.shape[3]]):S}const wB=q({separableConv2d_:vB});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function SB(n,t){const e=F(n,"x","setdiff1d"),s=F(t,"y","setdiff1d");M(e.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${s.dtype}).`),M(e.rank===1,()=>`x should be 1D tensor, but got x (${e.shape}).`),M(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await e.data(),i=await s.data(),a=new Set(i);let o=0;for(let d=0;d<r.length;d++)a.has(r[d])||o++;const u=new Bu([o],e.dtype),h=new Bu([o],"int32");for(let d=0,f=0;d<r.length;d++)a.has(r[d])||(u.values[f]=r[d],h.values[f]=d,f++);return[u.toTensor(),h.toTensor()]}const CB=SB;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $B(n){const e={x:F(n,"x","sign")};return Q.runKernel(K1,e)}const TB=q({sign_:$B});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kB(n){const e={x:F(n,"x","sin","float32")};return Q.runKernel(X1,e)}const _B=q({sin_:kB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NB(n){const e={x:F(n,"x","sinh")};return Q.runKernel(q1,e)}const EB=q({sinh_:NB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RB(n,t,e){const s=F(n,"x","slice1d");return M(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),re(s,[t],[e])}const IB=q({slice1d_:RB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AB(n,t,e){const s=F(n,"x","slice2d");return M(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),re(s,t,e)}const DB=q({slice2d_:AB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OB(n,t,e){const s=F(n,"x","slice3d");return M(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),re(s,t,e)}const PB=q({slice3d_:OB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FB(n,t,e){const s=F(n,"x","slice4d");return M(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),re(s,t,e)}const LB=q({slice4d_:FB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MB(n,t=-1){const e=F(n,"logits","softmax","float32");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);const s={logits:e},r={dim:t};return Q.runKernel(nv,s,r)}const zB=q({softmax_:MB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BB(n){M(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const t={input:n};return Q.runKernel(Fb,t)}const Ev=q({fft_:BB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VB(n){M(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const t={input:n};return Q.runKernel(jb,t)}const Kp=q({ifft_:VB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UB(n){const t=n.shape[n.shape.length-1],e=n.size/t;let s;if(t<=2){const r=ft(n,[e,t]);s=Kp(r)}else{const r=[e,2*(t-1)],i=ft(nd(n),[e,t]),a=ft(Tm(n),[e,t]),o=yl(re(i,[0,1],[e,t-2]),1),u=wt(yl(re(a,[0,1],[e,t-2]),1),ie(-1)),h=Rn([i,o],1),d=Rn([a,u],1),f=ft(Ja(h,d),[r[0],r[1]]);s=Kp(f)}if(s=nd(s),n.rank===3&&n.shape[0]!==0){const r=s,i=n.shape[0];s=ft(s,[i,s.shape[0]/i,s.shape[1]]),r.dispose()}return s}const wE=q({irfft_:UB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WB(n,t,e=0){const r={x:F(n,"x","split")},i={numOrSizeSplits:t,axis:e};return Q.runKernel(ev,r,i)}const sd=q({split_:WB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GB(n,t){M(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1];const s=n.size/e;let r;if(t!=null&&t<e){const x=n.shape.map(S=>0),w=n.shape.map(S=>S);w[n.shape.length-1]=t,r=re(n,x,w),e=t}else if(t!=null&&t>e){const x=n.shape.map(w=>w);x[n.shape.length-1]=t-e,r=Rn([n,aa(x)],n.shape.length-1),e=t}else r=n;const i=fr(r),a=ft(Ja(r,i),[s,e]),o=Ev(a),u=Math.floor(e/2)+1,h=nd(o),d=Tm(o),f=sd(h,[u,e-u],h.shape.length-1),m=sd(d,[u,e-u],d.shape.length-1),y=r.shape.slice();return y[r.shape.length-1]=u,ft(Ja(f[0],m[0]),y)}const Rv=q({rfft_:GB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HB(n,t){let e=F(n,"a","squaredDifference"),s=F(t,"b","squaredDifference");[e,s]=hn(e,s),ne(e.shape,s.shape);const r={a:e,b:s},i={};return Q.runKernel(av,r,i)}const SE=q({squaredDifference_:HB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jB(n,t){const e=F(n,"x","squeeze","string_or_numeric");return ft(e,ro(e.shape,t).newShape)}const De=q({squeeze_:jB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XB(n,t=0){const e=jp(n,"tensors","stack","string_or_numeric");M(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&M(t<=e[0].rank,()=>"Axis must be <= rank of the tensor");const s=e,r={axis:t};return Q.runKernel(T1,s,r)}const oa=q({stack_:XB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qB(n,t=0){const s={x:F(n,"x","step")},r={alpha:t};return Q.runKernel(yv,s,r)}const CE=q({step_:qB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KB(n,t,e,s,r=0,i=0,a=0,o=0,u=0){const d={x:F(n,"x","stridedSlice","string_or_numeric")},f={begin:t,end:e,strides:s,beginMask:r,endMask:i,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:u};return Q.runKernel(ov,d,f)}const YB=q({stridedSlice_:KB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QB(n){const e={x:F(n,"x","tan","float32")};return Q.runKernel(cv,e)}const ZB=q({tan_:QB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jn(n,t){Yu(n);const e=io(n,t);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return ao(n,null,e,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Or(n,t,e){if(Yu(n),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=io(n,e);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ao(n,t,s,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $E(n,t,e){if(Yu(n),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=io(n,e);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return ao(n,t,s,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JB(n,t,e){if(Yu(n),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=io(n,e);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return ao(n,t,s,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t4(n,t,e){if(Yu(n),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=io(n,e);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return ao(n,t,s,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e4(n,t,e){if(Yu(n),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=io(n,e);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||s,ao(n,t,s,e)}function TE(n,t,e){const s=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(e.rank<r)throw new Error(i+` update.rank < ${r}. `);if(n.length<s+(e.rank-r))throw new Error(i+` Output shape length < ${s+(e.rank-r)}`);if(e.rank!==r+n.length-s)throw new Error(i+` update.rank != ${r+n.length-s}`);for(let a=0;a<r;++a)if(e.shape[a]!==t.shape[a])throw new Error(i+` updates.shape[${a}] (${e.shape[a]}) != indices.shape[${a}] (${t.shape[a]}).`);for(let a=0;a<e.rank-r;++a)if(e.shape[a+r]!==n[a+s])throw new Error(i+` updates.shape[${a+r}] (${e.shape[a+r]}) != shape[${a+r}] (${n[a+r]})`)}function Iv(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(e.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}TE(e,t,n)}function $l(n,t,e){const s=t.shape.length,r=s>1?t.shape[s-1]:1,i=e.length;let a=1;for(let f=r;f<i;++f)a*=e[f];const o=r<1?1:r,u=ht(t.shape)/o,h=[...cn(e.slice(0,r)),1],d=ht(e);return{sliceRank:r,numUpdates:u,sliceSize:a,strides:h,outputSize:d}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n4(n,t,e){const s=F(n,"tensor","tensorScatterupdate"),r=F(t,"indices","tensorScatterupdate","int32"),i=F(e,"updates","tensorScatterupdate");if(Iv(i,r,s.shape),s.dtype!==i.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${i.dtype}.`);const a={tensor:s,indices:r,updates:i},o={};return Q.runKernel(U1,a,o)}const s4=q({tensorScatterUpdate_:n4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r4(n,t=1,e=!0){const s=F(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);const i={x:s},a={k:t,sorted:e},[o,u]=Q.runKernel(dv,i,a);return{values:o,indices:u}}const i4=q({topk_:r4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a4(n,t=0,e=1,s,r){if(pr(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new _v(t,e,s,!0,r),a=Re(n,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const o4=q({truncatedNormal_:a4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l4(n,t=0){const e=F(n,"x","unique","string_or_numeric");M(e.rank>0,()=>"The input tensor must be at least 1D");const s={x:e},r={axis:t},[i,a]=Q.runKernel(hN,s,r);return{values:i,indices:a}}const u4=q({unique_:l4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c4(n,t,e){const s=F(n,"x","unsortedSegmentSum"),r=F(t,"segmentIds","unsortedSegmentSum","int32");M(zu(e),()=>"numSegments must be of dtype int");const i={x:s,segmentIds:r},a={numSegments:e};return Q.runKernel(mv,i,a)}const h4=q({unsortedSegmentSum_:c4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d4(n,t=0){const e=F(n,"x","unstack","string_or_numeric");M(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`);const s={value:e},r={axis:t};return Q.runKernel(pv,s,r)}const Tl=q({unstack_:d4});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f4(n,t){return Tv(n,t,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p4(n,t=!0,e,s){return Q.makeVariable(n,t,e,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kE(n,t){const e=[];for(let i=0;i<t.length;i++)t[i]&&e.push(i);const s=Re(n,"int32"),r=Re([e.length,n.length],"int32");for(let i=0;i<e.length;i++){const a=s.indexToLoc(e[i]),o=i*n.length;r.values.set(a,o)}return r.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function m4(n){const t=F(n,"condition","whereAsync","bool"),e=await t.data(),s=kE(t.shape,e);return n!==t&&t.dispose(),s}const _E=m4;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function g4(n,t,e){const s=F(n,"tensor","boolMask"),r=F(t,"mask","boolMask","bool"),i=e??0,a=r.rank,o=s.shape;M(a>0,()=>"mask cannot be scalar"),Ks(o.slice(i,i+a),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let w=i;w<i+a;w++)u*=o[w];const h=o.slice(0,i).concat([u],o.slice(i+a)),d=ft(s,h),f=ft(r,[-1]),m=await _E(f),y=De(m,[1]),x=rE(d,y,i);return n!==s&&s.dispose(),t!==r&&r.dispose(),y.dispose(),d.dispose(),f.dispose(),m.dispose(),x}const y4=g4;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x4(n,t,e){const s=F(n,"x","transpose");if(t==null&&(t=s.shape.map((a,o)=>o).reverse()),M(s.rank===t.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${t}.`),t.forEach(a=>{M(a>=0&&a<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${t}`)}),s.rank<=1)return s.clone();const r={x:s},i={perm:t};return s.dtype==="complex64"?Yt(()=>{let a=nd(s),o=Tm(s);return a=Q.runKernel(zh,{x:a},i),o=Q.runKernel(zh,{x:o},i),e&&(o=bi(o)),Ja(a,o)}):Q.runKernel(zh,r,i)}const Jx=q({transpose_:x4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b4(n,t,e,s,r=!0){const i=F(n,"v","movingAverage"),a=F(t,"x","movingAverage"),o=F(e,"decay","movingAverage");VO(i,a),M(Ee(i.shape,a.shape),()=>"Shape mismatch in v and x");const u=ie(1),h=Jt(u,o);let d=wt(Jt(a,i),h);if(r){M(s!=null,()=>"When using zeroDebias: true, step is required.");const f=F(s,"step","movingAverage");d=ae(d,Jt(u,Zh(o,f)))}return zt(i,d)}const v4=q({movingAverage_:b4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w4(n,t,e){pr(e);const s=F(n,"indices","scatterND","int32"),r=F(t,"updates","scatterND");Iv(r,s,e);const i={indices:s,updates:r},a={shape:e};return Q.runKernel(V1,i,a)}const S4=q({scatterND_:w4});function C4(n,t,e,s){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const r=n.rank>0?n.shape[0]:1,i=n.rank>1?n.shape[1]:1;if(e.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${i}.`);const a=t.size;if(!(t.rank===0||t.rank===1&&a===r))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${r}]`);if(t.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $4(n,t,e,s=0){pr(e);const r=F(n,"sparseIndices","sparseToDense","int32"),i=F(t,"sparseValues","sparseToDense","string_or_numeric"),a=F(s,"defaultValue","sparseToDense",i.dtype);C4(r,i,e,a);const o={sparseIndices:r,sparseValues:i,defaultValue:a},u={outputShape:e};return Q.runKernel(iv,o,u)}const T4=q({sparseToDense_:$4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k4(n,t){const e=F(t,"indices","gatherND","int32"),r={params:F(n,"x","gatherND","string_or_numeric"),indices:e};return Q.runKernel(Wb,r)}const _4=q({gatherND_:k4});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N4(n,t){if(t==null)return n.shape.slice();if(Ee(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let s=0;s<n.shape.length;s++)t[s]==null&&n.shape[s]!=null?e.push(n.shape[s]):e.push(t[s]);return e}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E4(n,t,e,s){const r=F(n,"x","dropout");if(M(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),M(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return n instanceof un?r.clone():r;const i=N4(r,e),a=1-t,o=ae(sE(zt(Nv(i,0,1,"float32",s),a)),a);return wt(r,o)}const R4=q({dropout_:E4});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NE(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function Av(n,t,e){const s=1-n%2,r=new Float32Array(n);for(let i=0;i<n;++i){const a=2*Math.PI*i/(n+s-1);r[i]=t-e*Math.cos(a)}return Jn(r,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function I4(n,t,e=1){const s=F(n,"predictions","inTopK"),r=F(t,"targets","inTopK");M(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),M(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),Ks(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const i=s.shape[s.shape.length-1];M(e>0&&e<=i,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${e}`);const a=await s.data(),o=await r.data(),[u,h]=[a.length/i,i],d=Si("bool",u);for(let f=0;f<u;f++){const m=f*h,y=a.subarray(m,m+h),x=[];for(let w=0;w<y.length;w++)x.push({value:y[w],index:w});x.sort((w,S)=>S.value-w.value),d[f]=0;for(let w=0;w<e;w++)if(x[w].index===o[f]){d[f]=1;break}}return n!==s&&s.dispose(),t!==r&&r.dispose(),xi(d,r.shape,"bool")}const A4=I4;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D4(n,t,e,s,r,i="NHWC",a){let o=n;n.rank===3&&(o=ft(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=t;u.rank===3&&(u=ft(t,[1,t.shape[0],t.shape[1],t.shape[2]])),M(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),M(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),M(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const h=i==="NHWC"?o.shape[3]:o.shape[1],d=i==="NHWC"?u.shape[3]:u.shape[1];M(h===e[2],()=>`Error in conv2dDerFilter: depth of input ${h}) must match input depth in filter (${e[2]}.`),M(d===e[3],()=>`Error in conv2dDerFilter: depth of dy (${d}) must match output depth for filter (${e[3]}).`),zr("conv2dDerFilter",r,a);const f={x:o,dy:u},m={strides:s,pad:r,dataFormat:i,dimRoundingMode:a,filterShape:e};return Q.runKernel(db,f,m)}const O4=q({conv2DBackpropFilter_:D4});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _m(n,t,e){if(e==null||e==="linear")return n;if(e==="relu")return wt(n,CE(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function Nm(n,t){let e=t;const s=QN(n.shape,t.shape);return s.length>0&&(e=Ke(e,s)),ft(e,n.shape)}function Em(n,t,e,s){if(t==="linear")return n;if(t==="relu")return km(n);if(t==="elu")return JN(n);if(t==="relu6")return bE(n);if(t==="prelu")return yE(n,e);if(t==="leakyrelu")return aE(n,s);if(t==="sigmoid")return Zi(n);throw new Error(`Unknown fused activation ${t}.`)}const Rm=(n,t)=>!(n>0)||t==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P4({x:n,filter:t,strides:e,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:a,bias:o,activation:u="linear",preluActivationWeights:h,leakyreluAlpha:d}){if(u=u||"linear",Rm(Q.state.gradientDepth,u)===!1){M(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let L=Sm(n,t,e,s,r,i,a);return o!=null&&(L=zt(L,o)),Em(L,u,h,d)}const f=F(n,"x","conv2d","float32"),m=F(t,"filter","conv2d","float32");let y=f,x=!1;f.rank===3&&(x=!0,y=ft(f,[1,f.shape[0],f.shape[1],f.shape[2]])),M(y.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${y.rank}.`),M(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),zr("fused conv2d",s,a);const w=r==="NHWC"?y.shape[3]:y.shape[1];M(m.shape[2]===w,()=>`Error in conv2d: depth of input (${w}) must match input depth for filter ${m.shape[2]}.`),M(ps(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);const S=vn(y.shape,m.shape,e,i,s,a);let C;o!=null&&(C=F(o,"bias","fused conv2d"),[C]=hn(C,f),r==="NHWC"?ne(S.outShape,C.shape):(M(C.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${C.shape.length}.`),M(C.shape.length===0||C.shape[0]===S.outChannels||C.shape[0]===1,()=>`Error in fused conv2d: bias shape (${C.shape}) is not compatible with the number of output channels (${S.outChannels})`)));let k;if(h!=null){const L=h.shape;if(M(L.length<=1||L.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${L.length}.`),L.length===1)M(L[0]===1||L[0]===S.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${L}) is not compatible with the number of output channels (${S.outChannels}).`);else if(L.length===3)try{ne(L,S.outShape)}catch{const B=`Error in fused conv2d: PReLU activation weights (${L}) is not compatible with the output shape of the conv2d (${S.outShape}).`;throw Error(B)}k=F(h,"prelu weights","fused conv2d")}const E=(L,V)=>{M(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[B,z,U,D]=V,Y=_m(L,U,u);M(Qh(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const nt=YN(z.shape,Y,B,e,s),dt=O4(z,Y,B.shape,e,s),at=[nt,dt];if(D!=null){const K=Nm(D,Y);at.push(K)}return at},R={x:y,filter:m,bias:C,preluActivationWeights:k},A={strides:e,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a,activation:u,leakyreluAlpha:d};return o==null?ia((V,B,z)=>{let U=Q.runKernel(Vp,R,A);return z([B,V,U]),x&&(U=ft(U,[U.shape[1],U.shape[2],U.shape[3]])),{value:U,gradFunc:E}})(y,m):ia((V,B,z,U)=>{let D=Q.runKernel(Vp,R,A);return U([B,V,D,z]),x&&(D=ft(D,[D.shape[1],D.shape[2],D.shape[3]])),{value:D,gradFunc:E}})(y,m,C)}const F4=q({fusedConv2d_:P4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L4(n,t,e,s,r,i=[1,1],a){let o=n;n.rank===3&&(o=ft(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=t;u.rank===3&&(u=ft(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const h={x:o,dy:u},d={strides:s,pad:r,dimRoundingMode:a,dilations:i,filterShape:e};return Q.runKernel($b,h,d)}const M4=q({depthwiseConv2dNativeBackpropFilter_:L4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z4(n,t,e,s,r,i=[1,1],a){let o=t,u=!1;t.rank===3&&(u=!0,o=ft(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const h={dy:o,filter:e},d={strides:s,pad:r,dimRoundingMode:a,dilations:i,inputShape:n},f=Q.runKernel(Tb,h,d);return u?ft(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const B4=q({depthwiseConv2dNativeBackpropInput_:z4});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V4({x:n,filter:t,strides:e,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:a,bias:o,activation:u="linear",preluActivationWeights:h,leakyreluAlpha:d}){if(Rm(Q.state.gradientDepth,u)===!1){let A=Sv(n,t,e,s,r,i,a);return o!=null&&(A=zt(A,o)),Em(A,u,h,d)}const f=F(n,"x","depthwiseConv2d","float32"),m=F(t,"filter","depthwiseConv2d","float32");let y=f,x=!1;f.rank===3&&(x=!0,y=ft(f,[1,f.shape[0],f.shape[1],f.shape[2]])),M(y.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${y.rank}.`),M(m.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`),M(y.shape[3]===m.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${y.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),i==null&&(i=[1,1]),M(ps(e,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),zr("fused depthwiseConv2d",s,a);const w=vn(y.shape,m.shape,e,i,s,a,!0);let S;o!=null&&(S=F(o,"bias","fused conv2d"),[S]=hn(S,f),ne(w.outShape,S.shape));let C;h!=null&&(C=F(h,"prelu weights","fused depthwiseConv2d"));const k=(A,L)=>{M(Qh(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[V,B,z,U]=L,D=_m(A,z,u),Y=B4(B.shape,D,V,e,s,i,a),nt=M4(B,D,V.shape,e,s,i,a);if(U!=null){const dt=Nm(S,D);return[Y,nt,dt]}return[Y,nt]},E={x:y,filter:m,bias:S,preluActivationWeights:C},R={strides:e,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a,activation:u,leakyreluAlpha:d};return o==null?ia((L,V,B)=>{let z=Q.runKernel(Up,E,R);return B([V,L,z]),x&&(z=ft(z,[z.shape[1],z.shape[2],z.shape[3]])),{value:z,gradFunc:k}})(y,m):ia((L,V,B,z)=>{let U=Q.runKernel(Up,E,R);return z([V,L,U,B]),x&&(U=ft(U,[U.shape[1],U.shape[2],U.shape[3]])),{value:U,gradFunc:k}})(y,m,S)}const U4=q({fusedDepthwiseConv2d_:V4});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W4({a:n,b:t,transposeA:e=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:a,leakyreluAlpha:o=.2}){if(Rm(Q.state.gradientDepth,i)===!1){let D=Pe(n,t,e,s);return r!=null&&(D=zt(D,r)),Em(D,i,a,o)}let u=F(n,"a","fused matMul"),h=F(t,"b","fused matMul");[u,h]=hn(u,h);const d=e?u.shape[u.rank-2]:u.shape[u.rank-1],f=s?h.shape[h.rank-1]:h.shape[h.rank-2],m=e?u.shape[u.rank-1]:u.shape[u.rank-2],y=s?h.shape[h.rank-2]:h.shape[h.rank-1],x=u.shape.slice(0,-2),w=h.shape.slice(0,-2),S=ht(x),C=ht(w);M(d===f,()=>`Error in fused matMul: inner shapes (${d}) and (${f}) of Tensors with shapes ${u.shape} and ${h.shape} and transposeA=${e} and transposeB=${s} must match.`);const E=ne(u.shape.slice(0,-2),h.shape.slice(0,-2)).concat([m,y]),R=e?ft(u,[S,d,m]):ft(u,[S,m,d]),A=s?ft(h,[C,y,f]):ft(h,[C,f,y]);let L;r!=null&&(L=F(r,"bias","fused matMul"),[L]=hn(L,u),ne(E,L.shape));let V;a!=null&&(V=F(a,"prelu weights","fused matMul"));const B=(D,Y)=>{const[nt,dt,at,K]=Y,ct=_m(ft(D,at.shape),at,i);let yt,$t;if(!e&&!s?(yt=Pe(ct,dt,!1,!0),$t=Pe(nt,ct,!0,!1)):!e&&s?(yt=Pe(ct,dt,!1,!1),$t=Pe(ct,nt,!0,!1)):e&&!s?(yt=Pe(dt,ct,!1,!0),$t=Pe(nt,ct,!1,!1)):(yt=Pe(dt,ct,!0,!0),$t=Pe(ct,nt,!0,!0)),r!=null){const H=Nm(K,ct);return[yt,$t,H]}else return[yt,$t]},z={a:R,b:A,bias:L,preluActivationWeights:V},U={transposeA:e,transposeB:s,activation:i,leakyreluAlpha:o};return r==null?ia((Y,nt,dt)=>{const at=Q.runKernel(Bp,z,U);return dt([Y,nt,at]),{value:ft(at,E),gradFunc:B}})(R,A):ia((Y,nt,dt,at)=>{const K=Q.runKernel(Bp,z,U);return at([Y,nt,K,dt]),{value:ft(K,E),gradFunc:B}})(R,A,L)}const G4=q({fusedMatMul_:W4});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H4=Object.freeze(Object.defineProperty({__proto__:null,conv2d:F4,depthwiseConv2d:U4,matMul:G4},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j4(n){return Av(n,.54,.46)}const X4=q({hammingWindow_:j4});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q4(n){return Av(n,.5,.5)}const EE=q({hannWindow_:q4});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K4(n,t,e,s=!1,r=0){let i=0;const a=[];for(;i+t<=n.size;)a.push(re(n,i,t)),i+=e;if(s)for(;i<n.size;){const o=i+t-n.size,u=Rn([re(n,i,t-o),wd([o],r)]);a.push(u),i+=e}return a.length===0?Or([],[0,t]):ft(Rn(a),[a.length,t])}const RE=q({frame_:K4});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y4(n,t,e,s,r=EE){s==null&&(s=NE(t));const i=RE(n,t,e),a=wt(i,r(t));return Rv(a,s)}const Q4=q({stft_:Y4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z4(n,t,e,s,r="bilinear",i=0){const a=F(n,"image","cropAndResize"),o=F(t,"boxes","cropAndResize","float32"),u=F(e,"boxInd","cropAndResize","int32"),h=o.shape[0];M(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),M(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${h},4] but had shape ${o.shape}.`),M(u.rank===1&&u.shape[0]===h,()=>`Error in cropAndResize: boxInd must be have size [${h}] but had shape ${o.shape}.`),M(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),M(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),M(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const d={image:a,boxes:o,boxInd:u},f={method:r,extrapolationValue:i,cropSize:s};return Q.runKernel(vb,d,f)}const J4=q({cropAndResize_:Z4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tV(n){const t=F(n,"image","flipLeftRight","float32");M(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const e={image:t};return Q.runKernel(Mb,e,{})}const eV=q({flipLeftRight_:tV});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nV(n){const t=F(n,"image","grayscaleToRGB"),e=t.rank-1,s=t.shape[e];M(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),M(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(t.rank);return r.fill(1,0,e),r[e]=3,Vh(t,r)}const sV=q({grayscaleToRGB_:nV});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rV(n){const t=F(n,"image","RGBToGrayscale"),e=t.rank-1,s=t.shape[e];M(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),M(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=t.dtype,i=Ue(t,"float32"),a=Jn([.2989,.587,.114]);let o;switch(t.rank){case 2:o=Au("ij,j->i",i,a);break;case 3:o=Au("ijk,k->ij",i,a);break;case 4:o=Au("ijkl,l->ijk",i,a);break;case 5:o=Au("ijklm,m->ijkl",i,a);break;case 6:o=Au("ijklmn,n->ijklm",i,a);break;default:throw new Error("Not a valid tensor rank.")}return o=cr(o,-1),Ue(o,r)}const iV=q({rgbToGrayscale_:rV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aV(n,t,e=0,s=.5){const r=F(n,"image","rotateWithOffset","float32");M(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const i={image:r},a={radians:t,fillValue:e,center:s};return Q.runKernel(xv,i,a)}const oV=q({rotateWithOffset_:aV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ju(n,t,e,s,r,i){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),i==null&&(i=0);const a=n.shape[0];return e=Math.min(e,a),M(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),M(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),M(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),M(t.rank===1,()=>"scores must be a 1D tensor"),M(t.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${t.shape[0]}`),M(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:e,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lV(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY){const i=F(n,"boxes","nonMaxSuppression","float32"),a=F(t,"scores","nonMaxSuppression","float32"),o=Ju(i,a,e,s,r);e=o.maxOutputSize,s=o.iouThreshold,r=o.scoreThreshold;const u={maxOutputSize:e,iouThreshold:s,scoreThreshold:r};return Q.runKernel(w1,{boxes:i,scores:a},u)}const uV=q({nonMaxSuppression_:lV});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cV(n,t,e){const s=hV(n,t,e),r=s<0?-(s+1):s;n.splice(r,0,t)}function hV(n,t,e){return fV(n,t,e||dV)}function dV(n,t){return n>t?1:n<t?-1:0}function fV(n,t,e){let s=0,r=n.length,i=0,a=!1;for(;s<r;){i=s+(r-s>>>1);const o=e(t,n[i]);o>0?s=i+1:(r=i,a=!o)}return a?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dv(n,t,e,s,r){return Pv(n,t,e,s,r,0)}function IE(n,t,e,s,r,i){return Pv(n,t,e,s,r,0,!1,i,!0)}function Ov(n,t,e,s,r,i){return Pv(n,t,e,s,r,i,!0)}function Pv(n,t,e,s,r,i,a=!1,o=!1,u=!1){const h=[];for(let S=0;S<t.length;S++)t[S]>r&&h.push({score:t[S],boxIndex:S,suppressBeginIndex:0});h.sort(O$);const d=i>0?-.5/i:0,f=[],m=[];for(;f.length<e&&h.length>0;){const S=h.pop(),{score:C,boxIndex:k,suppressBeginIndex:E}=S;if(C<r)break;let R=!1;for(let A=f.length-1;A>=E;--A){const L=pV(n,k,f[A]);if(L>=s){R=!0;break}if(S.score=S.score*mV(s,d,L),S.score<=r)break}S.suppressBeginIndex=f.length,R||(S.score===C?(f.push(k),m.push(S.score)):S.score>r&&cV(h,S,O$))}const y=f.length,x=e-y;o&&x>0&&(f.push(...new Array(x).fill(0)),m.push(...new Array(x).fill(0)));const w={selectedIndices:f};return a&&(w.selectedScores=m),u&&(w.validOutputs=y),w}function pV(n,t,e){const s=n.subarray(t*4,t*4+4),r=n.subarray(e*4,e*4+4),i=Math.min(s[0],s[2]),a=Math.min(s[1],s[3]),o=Math.max(s[0],s[2]),u=Math.max(s[1],s[3]),h=Math.min(r[0],r[2]),d=Math.min(r[1],r[3]),f=Math.max(r[0],r[2]),m=Math.max(r[1],r[3]),y=(o-i)*(u-a),x=(f-h)*(m-d);if(y<=0||x<=0)return 0;const w=Math.max(i,h),S=Math.max(a,d),C=Math.min(o,f),k=Math.min(u,m),E=Math.max(C-w,0)*Math.max(k-S,0);return E/(y+x-E)}function mV(n,t,e){const s=Math.exp(t*e*e);return e<=n?s:0}function O$(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function gV(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY){const i=F(n,"boxes","nonMaxSuppressionAsync"),a=F(t,"scores","nonMaxSuppressionAsync"),o=Ju(i,a,e,s,r);e=o.maxOutputSize,s=o.iouThreshold,r=o.scoreThreshold;const u=await Promise.all([i.data(),a.data()]),h=u[0],d=u[1],{selectedIndices:f}=Dv(h,d,e,s,r);return i!==n&&i.dispose(),a!==t&&a.dispose(),Jn(f,"int32")}const yV=gV;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xV(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const a=F(n,"boxes","nonMaxSuppression"),o=F(t,"scores","nonMaxSuppression"),u=Ju(a,o,e,s,r,i);e=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,i=u.softNmsSigma;const h={boxes:a,scores:o},d={maxOutputSize:e,iouThreshold:s,scoreThreshold:r,softNmsSigma:i},f=Q.runKernel(S1,h,d);return{selectedIndices:f[0],selectedScores:f[1]}}const bV=q({nonMaxSuppressionWithScore_:xV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function vV(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const a=F(n,"boxes","nonMaxSuppressionAsync"),o=F(t,"scores","nonMaxSuppressionAsync"),u=Ju(a,o,e,s,r,i);e=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,i=u.softNmsSigma;const h=await Promise.all([a.data(),o.data()]),d=h[0],f=h[1],{selectedIndices:m,selectedScores:y}=Ov(d,f,e,s,r,i);return a!==n&&a.dispose(),o!==t&&o.dispose(),{selectedIndices:Jn(m,"int32"),selectedScores:Jn(y)}}const wV=vV;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SV(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const a=F(n,"boxes","nonMaxSuppression"),o=F(t,"scores","nonMaxSuppression"),u=Ju(a,o,e,s,r,null),h=u.maxOutputSize,d=u.iouThreshold,f=u.scoreThreshold,m={boxes:a,scores:o},y={maxOutputSize:h,iouThreshold:d,scoreThreshold:f,padToMaxOutputSize:i},x=Q.runKernel(J_,m,y);return{selectedIndices:x[0],validOutputs:x[1]}}const CV=q({nonMaxSuppressionPadded_:SV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function $V(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const a=F(n,"boxes","nonMaxSuppressionAsync"),o=F(t,"scores","nonMaxSuppressionAsync"),u=Ju(a,o,e,s,r,null),h=u.maxOutputSize,d=u.iouThreshold,f=u.scoreThreshold,[m,y]=await Promise.all([a.data(),o.data()]),{selectedIndices:x,validOutputs:w}=IE(m,y,h,d,f,i);return a!==n&&a.dispose(),o!==t&&o.dispose(),{selectedIndices:Jn(x,"int32"),validOutputs:ie(w,"int32")}}const TV=$V;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kV(n,t,e=!1,s=!1){const r=F(n,"images","resizeBilinear");M(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),M(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),M(s===!1||e===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,a=!1;r.rank===3&&(a=!0,i=ft(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const o={images:i},u={alignCorners:e,halfPixelCenters:s,size:t},h=Q.runKernel(F1,o,u);return a?ft(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const _V=q({resizeBilinear_:kV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NV(n,t,e=!1,s=!1){const r=F(n,"images","resizeNearestNeighbor");M(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),M(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),M(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),M(s===!1||e===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,a=!1;r.rank===3&&(a=!0,i=ft(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const o={images:i},u={alignCorners:e,halfPixelCenters:s,size:t},h=Q.runKernel(P1,o,u);return a?ft(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const EV=q({resizeNearestNeighbor_:NV});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RV(n,t="binary",e=!1,s=.5){const r=F(n,"image","threshold"),i=.2989,a=.587,o=.114,u=r.shape[0]*r.shape[1];let h=wt(Jn([s]),255),d,f,m,y;if(M(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),M(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),M(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),M(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),r.shape[2]===3){[d,f,m]=sd(r,[1,1,1],-1);const S=wt(d,i),C=wt(f,a),k=wt(m,o);y=zt(zt(S,C),k)}else y=n;if(t==="otsu"){const S=qN(Ue(vE(y),"int32"),xi([]),256);h=IV(S,u)}const x=e?$v(y,h):$m(y,h);return Ue(wt(x,255),"int32")}function IV(n,t){let e=Jn([-1]),s=Jn([0]),r=Jn([0]),i,a,o,u,h,d;for(let f=0;f<n.size-1;f++){i=re(n,0,f+1),a=re(n,f+1),h=ae(Ke(i),t),d=ae(Ke(a),t);const m=Ke(wt(i,ed(0,i.size)));o=ae(m,Ke(i));const y=wd(a.shape,i.size),x=zt(ed(0,a.size),y),w=wt(a,x);u=ae(Ke(w),Ke(a));const S=Jt(o,u),C=Jt(o,u),k=wt(h,d);r=wt(wt(k,S),C);const E=$m(r,s);s=Qa(E,r,s),e=Qa(E,Jn([f]),e)}return e}const AV=q({threshold_:RV});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DV(n,t,e="nearest",s="constant",r=0,i){const a=F(n,"image","transform","float32"),o=F(t,"transforms","transform","float32");M(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),M(o.rank===2&&(o.shape[0]===a.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),M(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const u={image:a,transforms:o},h={interpolation:e,fillMode:s,fillValue:r,outputShape:i};return Q.runKernel(fv,u,h)}const OV=q({transform_:DV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PV(n,t,e){const s=F(n,"a","bandPart");M(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[i,a]=s.shape.slice(-2);let o,u;typeof t=="number"?(M(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),M(t<=i,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${i}).`),o=F(t<0?i:t,"numLower","bandPart")):(M(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=Qa(Zx(t,0),i,td(t,i))),typeof e=="number"?(M(e%1===0,()=>`bandPart(): numUpper must be an integer, got ${e}.`),M(e<=a,()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${a}).`),u=F(e<0?a:e,"numUpper","bandPart")):(M(e.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=Qa(Zx(e,0),a,td(e,a)));const h=ft(ed(0,i,1,"int32"),[-1,1]),d=ed(0,a,1,"int32"),f=Jt(h,d),m=Xp($v(f,o),iE(f,bi(u))),y=aa([i,a],s.dtype);return ft(oa(Tl(ft(s,[-1,i,a])).map(x=>Qa(m,x,y))),r)}const FV=q({bandPart_:PV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LV(n){let t;if(Array.isArray(n)){t=!1,M(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let i=1;i<n.length;++i)M(n[i].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${r})`)}else t=!0,n=sd(n,n.shape[0],0).map(r=>De(r,[0]));M(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],s=n;for(let r=0;r<n.length;++r)e.push(Q.tidy(()=>{let i=s[r];if(r>0)for(let a=0;a<r;++a){const o=wt(Ke(wt(e[a],i)),e[a]);i=Jt(i,o)}return ae(i,Cm(i,"euclidean"))}));return t?oa(e,0):e}const MV=q({gramSchmidt_:LV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zV(n,t=!1){if(M(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return P$(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((u,h)=>u*h),s=Tl(ft(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],i=[];s.forEach(u=>{const[h,d]=P$(u,t);r.push(h),i.push(d)});const a=ft(oa(r,0),n.shape),o=ft(oa(i,0),n.shape);return[a,o]}}function P$(n,t=!1){return Q.tidy(()=>{M(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],s=n.shape[1];let r=nE(e),i=Ya(n);const a=Or([[1]],[1,1]);let o=Ya(a);const u=e>=s?s:e;for(let h=0;h<u;++h){const d=i,f=o,m=r;[o,i,r]=Q.tidy(()=>{const y=re(i,[h,h],[e-h,1]),x=Cm(y),w=re(i,[h,h],[1,1]),S=Qa($m(w,0),Or([[-1]]),Or([[1]])),C=Jt(w,wt(S,x)),k=ae(y,C);k.shape[0]===1?o=Ya(a):o=Rn([a,re(k,[1,0],[k.shape[0]-1,k.shape[1]])],0);const E=bi(ae(Pe(S,C),x)),R=re(i,[h,0],[e-h,s]),A=wt(E,o),L=Jx(o);if(h===0)i=Jt(R,Pe(A,Pe(L,R)));else{const z=Jt(R,Pe(A,Pe(L,R)));i=Rn([re(i,[0,0],[h,s]),z],0)}const V=Jx(A),B=re(r,[0,h],[e,r.shape[1]-h]);if(h===0)r=Jt(B,Pe(Pe(B,o),V));else{const z=Jt(B,Pe(Pe(B,o),V));r=Rn([re(r,[0,0],[e,h]),z],1)}return[o,i,r]}),Ne([d,f,m])}return!t&&e>s&&(r=re(r,[0,0],[e,s]),i=re(i,[0,0],[s,s])),[r,i]})}const BV=q({qr_:zV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ks;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(ks||(ks={}));function VV(n,t,e=ks.SUM_BY_NONZERO_WEIGHTS){const s=F(n,"losses","computeWeightedLoss");let r=null;t!=null&&(r=F(t,"weights","computeWeightedLoss"));const i=r==null?s:wt(s,r);if(e===ks.NONE)return i;if(e===ks.SUM)return Ke(i);if(e===ks.MEAN){if(r==null)return qp(i);{const a=s.size/r.size,o=ae(Ke(i),Ke(r));return a>1?ae(o,ie(a)):o}}if(e===ks.SUM_BY_NONZERO_WEIGHTS){if(r==null)return ae(Ke(i),ie(s.size));{const a=wt(r,rl(s.shape)),o=Ue(Ke(mE(a,ie(0))),"float32");return ae(Ke(i),o)}}throw Error(`Unknown reduction: ${e}`)}const ua=q({computeWeightedLoss_:VV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UV(n,t,e,s=ks.SUM_BY_NONZERO_WEIGHTS){const r=F(n,"labels","absoluteDifference"),i=F(t,"predictions","absoluteDifference");let a=null;e!=null&&(a=F(e,"weights","absoluteDifference")),Ks(r.shape,i.shape,"Error in absoluteDifference: ");const o=ur(Jt(r,i));return ua(o,a,s)}const WV=q({absoluteDifference_:UV});function GV(n,t,e,s,r=ks.SUM_BY_NONZERO_WEIGHTS){const i=F(n,"labels","cosineDistance"),a=F(t,"predictions","cosineDistance");let o=null;s!=null&&(o=F(s,"weights","cosineDistance")),Ks(i.shape,a.shape,"Error in cosineDistance: ");const u=ie(1),h=Jt(u,Ke(wt(i,a),e,!0));return ua(h,o,r)}const HV=q({cosineDistance_:GV});function jV(n,t,e,s=ks.SUM_BY_NONZERO_WEIGHTS){let r=F(n,"labels","hingeLoss");const i=F(t,"predictions","hingeLoss");let a=null;e!=null&&(a=F(e,"weights","hingeLoss")),Ks(r.shape,i.shape,"Error in hingeLoss: ");const o=ie(1);r=Jt(wt(ie(2),r),o);const u=km(Jt(o,wt(r,i)));return ua(u,a,s)}const XV=q({hingeLoss_:jV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qV(n,t,e,s=1,r=ks.SUM_BY_NONZERO_WEIGHTS){const i=F(n,"labels","huberLoss"),a=F(t,"predictions","huberLoss");let o=null;e!=null&&(o=F(e,"weights","huberLoss")),Ks(i.shape,a.shape,"Error in huberLoss: ");const u=ie(s),h=ur(Jt(a,i)),d=td(h,u),f=Jt(h,d),m=zt(wt(ie(.5),Dr(d)),wt(u,f));return ua(m,o,r)}const KV=q({huberLoss_:qV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YV(n,t,e,s=1e-7,r=ks.SUM_BY_NONZERO_WEIGHTS){const i=F(n,"labels","logLoss"),a=F(t,"predictions","logLoss");let o=null;e!=null&&(o=F(e,"weights","logLoss")),Ks(i.shape,a.shape,"Error in logLoss: ");const u=ie(1),h=ie(s),d=bi(wt(i,Jh(zt(a,h)))),f=wt(Jt(u,i),Jh(zt(Jt(u,a),h))),m=Jt(d,f);return ua(m,o,r)}const QV=q({logLoss_:YV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZV(n,t,e,s=ks.SUM_BY_NONZERO_WEIGHTS){const r=F(n,"labels","meanSquaredError"),i=F(t,"predictions","meanSquaredError");let a=null;e!=null&&(a=F(e,"weights","meanSquaredError")),Ks(r.shape,i.shape,"Error in meanSquaredError: ");const o=SE(r,i);return ua(o,a,s)}const JV=q({meanSquaredError_:ZV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tU(n,t){const e=F(n,"labels","sigmoidCrossEntropyWithLogits"),s=F(t,"logits","sigmoidCrossEntropyWithLogits");Ks(e.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=km(s),i=wt(s,e),a=oE(ra(bi(ur(s))));return zt(Jt(r,i),a)}function eU(n,t,e,s=0,r=ks.SUM_BY_NONZERO_WEIGHTS){let i=F(n,"multiClassLabels","sigmoidCrossEntropy");const a=F(t,"logits","sigmoidCrossEntropy");let o=null;if(e!=null&&(o=F(e,"weights","sigmoidCrossEntropy")),Ks(i.shape,a.shape,"Error in sigmoidCrossEntropy: "),s>0){const h=ie(s),d=ie(1),f=ie(.5);i=zt(wt(i,Jt(d,h)),wt(f,h))}const u=tU(i,a);return ua(u,o,r)}const nU=q({sigmoidCrossEntropy_:eU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sU(n,t,e=-1){if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);return ia((r,i,a)=>{const u=uE(i,[e],!0),h=Jt(Ue(i,"float32"),u);a([r,h]);const d=bi(wt(h,r));return{value:Ke(d,[e]),gradFunc:(y,x)=>{const[w,S]=x,C=Ys(y.shape,[e]);return[wt(ft(y,C),Jt(Ue(w,"float32"),ra(S))),wt(ft(y,C),Jt(ra(S),Ue(w,"float32")))]}}})(n,t)}function rU(n,t,e,s=0,r=ks.SUM_BY_NONZERO_WEIGHTS){let i=F(n,"onehotLabels","softmaxCrossEntropy");const a=F(t,"logits","softmaxCrossEntropy");let o=null;if(e!=null&&(o=F(e,"weights","softmaxCrossEntropy")),Ks(i.shape,a.shape,"Error in softmaxCrossEntropy: "),s>0){const h=ie(s),d=ie(1),f=ie(i.shape[1]);i=zt(wt(i,Jt(d,h)),ae(h,f))}const u=sU(i,a);return ua(u,o,r)}const iU=q({softmaxCrossEntropy_:rU});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aU(n,t,e,s){const r=F(n,"indices","sparseFillEmptyRows","int32"),i=F(t,"values","sparseFillEmptyRows"),a=F(e,"denseShape","sparseFillEmptyRows","int32"),o=F(s,"defaultValue","sparseFillEmptyRows",i.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(i.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const u={indices:r,values:i,denseShape:a,defaultValue:o},h=Q.runKernel(iN,u);return{outputIndices:h[0],outputValues:h[1],emptyRowIndicator:h[2],reverseIndexMap:h[3]}}const oU=q({sparseFillEmptyRows_:aU});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lU(n,t,e){const s=F(n,"inputIndices","sparseReshape","int32"),r=F(t,"inputShape","sparseReshape","int32"),i=F(e,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(i.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const a={inputIndices:s,inputShape:r,newShape:i},o=Q.runKernel(aN,a);return{outputIndices:o[0],outputShape:o[1]}}const uU=q({sparseReshape_:lU});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cU(n,t,e){const s=F(n,"data","sparseSegmentMean"),r=F(t,"indices","sparseSegmentMean","int32"),i=F(e,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${i.shape}`);const a={data:s,indices:r,segmentIds:i};return Q.runKernel(sv,a)}const hU=q({sparseSegmentMean_:cU});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dU(n,t,e){const s=F(n,"data","sparseSegmentSum"),r=F(t,"indices","sparseSegmentSum","int32"),i=F(e,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${i.shape}`);const a={data:s,indices:r,segmentIds:i};return Q.runKernel(rv,a)}const fU=q({sparseSegmentSum_:dU});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pU(n,t,e,s,r,i,a,o){const u=F(n,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);const h=F(t,"dataSplits","stringNGrams");if(h.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const d={separator:e,nGramWidths:s,leftPad:r,rightPad:i,padWidth:a,preserveShortSequences:o},f={data:u,dataSplits:h},m=Q.runKernel(lv,f,d);return{nGrams:m[0],nGramsSplits:m[1]}}const mU=q({stringNGrams_:pU});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gU(n,t,e=!0){const s=F(n,"input","stringSplit","string"),r=F(t,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const i={skipEmpty:e},a={input:s,delimiter:r},o=Q.runKernel(uN,a,i);return{indices:o[0],values:o[1],shape:o[2]}}const yU=q({stringSplit_:gU});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xU(n,t){const e=F(n,"input","stringToHashBucketFast","string"),s={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const r={input:e};return Q.runKernel(cN,r,s)}const bU=q({stringToHashBucketFast_:xU});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vU(n,t,e,s=!0){const r=F(n,"input","staticRegexReplace","string"),i={pattern:t,rewrite:e,replaceGlobal:s};return Q.runKernel(lN,{x:r},i)}const wU=q({staticRegexReplace_:vU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SU={fft:Ev,ifft:Kp,rfft:Rv,irfft:wE},CU={hammingWindow:X4,hannWindow:EE,frame:RE,stft:Q4},ll={flipLeftRight:eV,grayscaleToRGB:sV,resizeNearestNeighbor:EV,resizeBilinear:_V,rgbToGrayscale:iV,rotateWithOffset:oV,cropAndResize:J4,nonMaxSuppression:uV,nonMaxSuppressionAsync:yV,nonMaxSuppressionWithScore:bV,nonMaxSuppressionWithScoreAsync:wV,nonMaxSuppressionPadded:CV,nonMaxSuppressionPaddedAsync:TV,threshold:AV,transform:OV},$U={bandPart:FV,gramSchmidt:MV,qr:BV},TU={absoluteDifference:WV,computeWeightedLoss:ua,cosineDistance:HV,hingeLoss:XV,huberLoss:KV,logLoss:QV,meanSquaredError:JV,sigmoidCrossEntropy:nU,softmaxCrossEntropy:iU},kU={sparseFillEmptyRows:oU,sparseReshape:uU,sparseSegmentMean:hU,sparseSegmentSum:fU},_U={stringNGrams:mU,stringSplit:yU,stringToHashBucketFast:bU,staticRegexReplace:wU};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NU=new Map,EU=new Map;class RU{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class Jo{constructor(){this.classNameMap={}}static getMap(){return Jo.instance==null&&(Jo.instance=new Jo),Jo.instance}static register(t){Jo.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function IU(n,t,e){M(n.className!=null,()=>"Class being registered does not have the static className property defined."),M(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),M(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof e>"u"&&(e=n.className);const s=e,r=t+">"+s;return Jo.register(n),NU.set(r,n),EU.set(n,r),n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kl extends RU{minimize(t,e=!1,s){const{value:r,grads:i}=this.computeGradients(t,s);if(s!=null){const a=s.map(o=>({name:o.name,tensor:i[o.name]}));this.applyGradients(a)}else this.applyGradients(i);return Ne(i),e?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return mM(t,e)}dispose(){this.iterations_!=null&&Ne(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:ie(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(kl,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AU extends kl{static get className(){return"Adadelta"}constructor(t,e,s=null){super(),this.learningRate=t,this.rho=e,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=Q.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=Q.registeredVariables[s],a=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:Yt(()=>fr(i).variable(a))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:Yt(()=>fr(i).variable(a))});const o=Array.isArray(t)?t[r].tensor:t[s];if(o==null)return;const u=this.accumulatedGrads[r].variable,h=this.accumulatedUpdates[r].variable;Yt(()=>{const d=zt(wt(u,this.rho),wt(Dr(o),1-this.rho)),f=wt(ae(sa(zt(h,this.epsilon)),sa(zt(u,this.epsilon))),o),m=zt(wt(h,this.rho),wt(Dr(f),1-this.rho));u.assign(d),h.assign(m);const y=zt(wt(f,-this.learningRate),i);i.assign(y)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Ne(this.accumulatedGrads.map(t=>t.variable)),Ne(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=t.length/2,s=!1;this.accumulatedGrads=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DU extends kl{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=Q.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:Yt(()=>wd(i.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(t)?t[r].tensor:t[s];if(a==null)return;const o=this.accumulatedGrads[r].variable;Yt(()=>{const u=zt(o,Dr(a));o.assign(u);const h=zt(wt(ae(a,sa(zt(u,Q.backend.epsilon()))),-this.learningRate),i);i.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Ne(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulatedGrads=t.map(s=>({originalName:s.name,variable:s.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OU extends kl{static get className(){return"Adam"}constructor(t,e,s,r=null){super(),this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Yt(()=>{this.accBeta1=ie(e).variable(),this.accBeta2=ie(s).variable()}),r==null&&(this.epsilon=Q.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);Yt(()=>{const s=Jt(1,this.accBeta1),r=Jt(1,this.accBeta2);e.forEach((i,a)=>{const o=Q.registeredVariables[i],u=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${i}/m`,variable:Yt(()=>fr(o).variable(u))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${i}/v`,variable:Yt(()=>fr(o).variable(u))});const h=Array.isArray(t)?t[a].tensor:t[i];if(h==null)return;const d=this.accumulatedFirstMoment[a].variable,f=this.accumulatedSecondMoment[a].variable,m=zt(wt(d,this.beta1),wt(h,1-this.beta1)),y=zt(wt(f,this.beta2),wt(Dr(h),1-this.beta2)),x=ae(m,s),w=ae(y,r);d.assign(m),f.assign(y);const S=zt(wt(ae(x,zt(sa(w),this.epsilon)),-this.learningRate),o);o.assign(S)}),this.accBeta1.assign(wt(this.accBeta1,this.beta1)),this.accBeta2.assign(wt(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Ne(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&Ne(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t),Yt(()=>{this.accBeta1.assign(Zh(this.beta1,this.iterations_+1)),this.accBeta2.assign(Zh(this.beta2,this.iterations_+1))});const e=t.length/2,s=!1;this.accumulatedFirstMoment=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PU extends kl{static get className(){return"Adamax"}constructor(t,e,s,r=null,i=0){super(),this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Yt(()=>{this.iteration=ie(0).variable(),this.accBeta1=ie(e).variable()}),r==null&&(this.epsilon=Q.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);Yt(()=>{const s=Jt(1,this.accBeta1),r=ae(-this.learningRate,zt(wt(this.iteration,this.decay),1));e.forEach((i,a)=>{const o=Q.registeredVariables[i],u=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${i}/m`,variable:fr(o).variable(u)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${i}/v`,variable:fr(o).variable(u)});const h=Array.isArray(t)?t[a].tensor:t[i];if(h==null)return;const d=this.accumulatedFirstMoment[a].variable,f=this.accumulatedWeightedInfNorm[a].variable,m=zt(wt(d,this.beta1),wt(h,1-this.beta1)),y=wt(f,this.beta2),x=ur(h),w=fE(y,x);d.assign(m),f.assign(w);const S=zt(wt(ae(r,s),ae(m,zt(w,this.epsilon))),o);o.assign(S)}),this.iteration.assign(zt(this.iteration,1)),this.accBeta1.assign(wt(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Ne(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&Ne(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AE extends kl{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=Array.isArray(t)?t[r].tensor:t[s];if(i==null)return;const a=Q.registeredVariables[s];Yt(()=>{const o=zt(wt(this.c,i),a);a.assign(o)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=gi(ie(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FU extends AE{static get className(){return"Momentum"}constructor(t,e,s=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=s,this.accumulations=[],this.m=ie(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=Q.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:Yt(()=>fr(i).variable(!1))});const a=this.accumulations[r].variable,o=Array.isArray(t)?t[r].tensor:t[s];o!=null&&Yt(()=>{let u;const h=zt(wt(this.m,a),o);this.useNesterov?u=zt(wt(this.c,zt(o,wt(h,this.m))),i):u=zt(wt(this.c,h),i),a.assign(h),i.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Ne(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulations=t.map(s=>({originalName:s.name,variable:s.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LU extends kl{static get className(){return"RMSProp"}constructor(t,e=.9,s=0,r=null,i=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,r==null&&(this.epsilon=Q.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=Q.registeredVariables[s],a=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:Yt(()=>fr(i).variable(a))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:Yt(()=>fr(i).variable(a))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:Yt(()=>fr(i).variable(a))});const o=Array.isArray(t)?t[r].tensor:t[s];if(o==null)return;const u=this.accumulatedMeanSquares[r].variable,h=this.accumulatedMoments[r].variable;Yt(()=>{const d=zt(wt(u,this.decay),wt(Dr(o),1-this.decay));if(this.centered){const f=this.accumulatedMeanGrads[r].variable,m=zt(wt(f,this.decay),wt(o,1-this.decay)),y=ae(wt(o,this.learningRate),sa(Jt(d,zt(Dr(m),this.epsilon)))),x=zt(wt(h,this.momentum),y);u.assign(d),f.assign(m),h.assign(x);const w=Jt(i,x);i.assign(w)}else{const f=zt(wt(u,this.decay),wt(Dr(o),1-this.decay)),m=zt(wt(h,this.momentum),ae(wt(o,this.learningRate),sa(zt(f,this.epsilon))));u.assign(f),h.assign(m);const y=Jt(i,m);i.assign(y)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Ne(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Ne(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&Ne(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,s=!1;this.accumulatedMeanSquares=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=t.slice(e*2,e*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MU=[AU,DU,OU,PU,FU,LU,AE];function zU(){for(const n of MU)IU(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BU="model",VU=".json",UU=".weights.bin";function F$(n){return new Promise(t=>setTimeout(t)).then(n)}class xl{constructor(t){if(!tt().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(xl.URL_SCHEME)&&(t=t.slice(xl.URL_SCHEME.length)),(t==null||t.length===0)&&(t=BU),this.modelJsonFileName=t+VU,this.weightDataFileName=t+UU}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=si.join(t.weightData),s=window.URL.createObjectURL(new Blob([e],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],i=ON(t,r),a=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=a,await F$(()=>o.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){const u=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=s,await F$(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:bd(t)}}}}xl.URL_SCHEME="downloads://";class WU{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}async load(){return new Promise((t,e)=>{const s=new FileReader;s.onload=r=>{const i=JSON.parse(r.target.result),a=i.modelTopology;if(a==null){e(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(i.weightsManifest==null){e(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){t({modelTopology:a});return}const u=vv(i,h=>this.loadWeights(h));t(u)},s.onerror=r=>e(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(t){const e=[],s=[];for(const a of t)e.push(...a.weights),s.push(...a.paths);const r=this.checkManifestAndWeightFiles(t),i=s.map(a=>this.loadWeightsFile(a,r[a]));return Promise.all(i).then(a=>[e,a])}loadWeightsFile(t,e){return new Promise((s,r)=>{const i=new FileReader;i.onload=a=>{const o=a.target.result;s(o)},i.onerror=a=>r(`Failed to weights data from file of path '${t}'.`),i.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){const e=[],s=this.weightsFiles.map(i=>T$(i.name)),r={};for(const i of t)i.paths.forEach(a=>{const o=T$(a);if(e.indexOf(o)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${o}'`);if(e.push(o),s.indexOf(o)===-1)throw new Error(`Weight file with basename '${o}' is not provided.`);r[a]=this.weightsFiles[s.indexOf(o)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const GU=n=>tt().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(xl.URL_SCHEME)?HU(n.slice(xl.URL_SCHEME.length)):null;an.registerSaveRouter(GU);function HU(n="model"){return new xl(n)}function jU(n){return new WU(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L$(n,t,e,s){a(n),e=e??0,s=s??1,o(e,s);let r=0;const i=u=>(u.then(h=>{const d=e+ ++r/n.length*(s-e);return t(d),h}),u);function a(u){M(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function o(u,h){M(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),M(h>=0&&h<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${h}`),M(h>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${h}`)}return Promise.all(n.map(i))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function DE(n,t){t==null&&(t={});const e=t.fetchFunc==null?tt().platform.fetch:t.fetchFunc,s=n.map(f=>e(f,t.requestInit,{isBinary:!0})),o=(t.onProgress==null?await Promise.all(s):await L$(s,t.onProgress,0,.5)).map(f=>f.arrayBuffer());return t.onProgress==null?await Promise.all(o):await L$(o,t.onProgress,.5,1)}function XU(n,t){var e;const s=t.fetchFunc==null?tt().platform.fetch:t.fetchFunc;let r=0,i;return(e=t.onProgress)===null||e===void 0||e.call(t,0),new ReadableStream({pull:async a=>{for(var o;r<n.length;){i||(i=(await s(n[r],t.requestInit,{isBinary:!0})).body.getReader());const{done:u,value:h}=await i.read();if(u){r++,i=void 0,(o=t.onProgress)===null||o===void 0||o.call(t,r/n.length);continue}a.enqueue(h);return}a.close()}})}async function qU(n,t="",e,s){return OE(a=>DE(a,{requestInit:s}))(n,t,e)}function OE(n){return async(t,e="",s)=>{const r=t.map(()=>!1),i={},a=s!=null?s.map(()=>!1):[],o=[];if(t.forEach((y,x)=>{let w=0;y.weights.forEach(S=>{const C="quantization"in S?S.quantization.dtype:S.dtype,k=fl[C]*ht(S.shape),E=()=>{r[x]=!0,i[x]==null&&(i[x]=[]),i[x].push({manifestEntry:S,groupOffset:w,sizeBytes:k})};s!=null?s.forEach((R,A)=>{R===S.name&&(E(),a[A]=!0)}):E(),o.push(S.name),w+=k})}),!a.every(y=>y)){const y=s.filter((x,w)=>!a[w]);throw new Error(`Could not find weights in manifest with names: ${y.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}const u=r.reduce((y,x,w)=>(x&&y.push(w),y),[]),h=[];u.forEach(y=>{t[y].paths.forEach(x=>{const w=e+(e.endsWith("/")?"":"/")+x;h.push(w)})});const d=await n(h),f={};let m=0;return u.forEach(y=>{const x=t[y].paths.length,w=new si(d.slice(m,m+x));i[y].forEach(C=>{const k=w.slice(C.groupOffset,C.groupOffset+C.sizeBytes),E=IN(k,[C.manifestEntry]);for(const R in E)f[R]=E[R]}),m+=x}),f}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KU="application/octet-stream",YU="application/json";class Fv{constructor(t,e){if(this.DEFAULT_METHOD="POST",e==null&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.weightUrlConverter=e.weightUrlConverter,e.fetchFunc!=null?(M(typeof e.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=tt().platform.fetch,M(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&M(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,e.requestInit!=null&&e.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{},this.loadOptions=e}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],r=ON(t,s);if(e.body.append("model.json",new Blob([JSON.stringify(r)],{type:YU}),"model.json"),t.weightData!=null){const a=si.join(t.weightData);e.body.append("model.weights.bin",new Blob([a],{type:KU}),"model.weights.bin")}const i=await this.fetch(this.path,e);if(i.ok)return{modelArtifactsInfo:bd(t),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async loadModelJSON(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}const s=e.modelTopology,r=e.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return e}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const t=await this.loadModelJSON();return vv(t,e=>this.loadWeights(e))}async loadStream(){const t=await this.loadModelJSON(),e=await this.getWeightUrls(t.weightsManifest),s=Hx(t.weightsManifest),r=()=>XU(e,this.loadOptions);return Object.assign(Object.assign({},t),{weightSpecs:s,getWeightStream:r})}async getWeightUrls(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=QU(e),i=this.weightPathPrefix||s,a=[],o=[];for(const u of t)for(const h of u.paths)this.weightUrlConverter!=null?o.push(this.weightUrlConverter(h)):a.push(i+h+r);return this.weightUrlConverter&&a.push(...await Promise.all(o)),a}async loadWeights(t){const e=await this.getWeightUrls(t),s=Hx(t),r=await DE(e,this.loadOptions);return[s,r]}}Fv.URL_SCHEME_REGEX=/^https?:\/\//;function QU(n){const t=n.lastIndexOf("/"),e=n.lastIndexOf("?"),s=n.substring(0,t),r=e>t?n.substring(e):"";return[s+"/",r]}function t0(n){return n.match(Fv.URL_SCHEME_REGEX)!=null}const PE=(n,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let e=!0;if(Array.isArray(n)?e=n.every(s=>t0(s)):e=t0(n),e)return Lv(n,t)}return null};an.registerSaveRouter(PE);an.registerLoadRouter(PE);function Lv(n,t){return new Fv(n,t)}function ZU(n,t){return Lv(n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hx{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class FE{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class JU{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function tW(n,t,e,s){const r=arguments;return new JU(LE(...r))}function LE(n,t,e,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new hx(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new hx({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new hx({modelTopology:n,weightSpecs:t,weightData:e,trainingConfig:s}))}function eW(n){return new FE(n)}function nW(n){return new FE(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ME=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:si,browserFiles:jU,browserHTTPRequest:ZU,concatenateArrayBuffers:nP,copyModel:$P,decodeWeights:IN,decodeWeightsStream:DN,encodeWeights:YO,fromMemory:tW,fromMemorySync:LE,getLoadHandlers:cP,getModelArtifactsForJSON:vv,getModelArtifactsForJSONSync:PN,getModelArtifactsInfoForJSON:bd,getSaveHandlers:uP,getWeightSpecs:Hx,http:Lv,isHTTPScheme:t0,listModels:SP,loadWeights:qU,moveModel:TP,registerLoadRouter:lP,registerSaveRouter:oP,removeModel:CP,weightsLoaderFactory:OE,withSaveHandler:eW,withSaveHandlerSync:nW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Wo,M$=!1;function sW(n,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,s=!1,r=!1,i=!1,a=!1,o=!1;if(n.data instanceof Uint8Array)e=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)i=!0;else if(n.getContext!=null)a=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(Gp(zp,Q.backendName)!=null){const x={pixels:n},w={numChannels:t};return Q.runKernel(zp,x,w)}const[h,d]=r?[n.videoWidth,n.videoHeight]:[n.width,n.height];let f;if(a)f=n.getContext("2d").getImageData(0,0,h,d).data;else if(s||e)f=n.data;else if(i||r||o){if(Wo==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Wo=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Wo=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Wo.canvas.width=h,Wo.canvas.height=d,Wo.drawImage(n,0,0,h,d),f=Wo.getImageData(0,0,h,d).data}let m;if(t===4)m=new Int32Array(f);else{const x=h*d;m=new Int32Array(x*t);for(let w=0;w<x;w++)for(let S=0;S<t;++S)m[w*t+S]=f[w*4+S]}return $E(m,[d,h,t],"int32")}function rW(n){if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const t=n.rank===2?1:n.shape[2];if(t>4||t===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`)}async function Mv(n,t){let e=F(n,"img","toPixels");if(!(n instanceof un)){const h=e;e=Ue(h,"int32"),h.dispose()}rW(e);const[s,r]=e.shape.slice(0,2),i=e.rank===2?1:e.shape[2],a=await e.data(),o=e.dtype==="float32"?255:1,u=new Uint8ClampedArray(r*s*4);for(let h=0;h<s*r;++h){const d=[0,0,0,255];for(let m=0;m<i;m++){const y=a[h*i+m];if(e.dtype==="float32"){if(y<0||y>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${y}.`)}else if(e.dtype==="int32"&&(y<0||y>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${y}.`);i===1?(d[0]=y*o,d[1]=y*o,d[2]=y*o):d[m]=y*o}const f=h*4;u[f+0]=Math.round(d[0]),u[f+1]=Math.round(d[1]),u[f+2]=Math.round(d[2]),u[f+3]=Math.round(d[3])}if(t!=null){M$||Gp(q_,Q.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),M$=!0),t.width=r,t.height=s;const h=t.getContext("2d"),d=new ImageData(u,r,s);h.putImageData(d,0,0)}return e!==n&&e.dispose(),u}const zE=q({fromPixels_:sW});function zv(n,t){const e=n.shape.length,s=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[s-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[s-1]} vs. ${e}`);if(ht(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=t.shape,i=r[r.length-1];let a=1;for(let f=0;f<r.length-1;++f)a*=r[f];const o=n.shape,u=r.slice();u.pop();let h=1;for(let f=i;f<e;++f)h*=o[f],u.push(o[f]);const d=[...cn(n.shape).map(f=>f/h),1].slice(0,i);return[u,a,h,d]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e0=-2,iW=-1;function Bv(n,t,e){const s=n.shape.length;M(s===t.length,()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`),M(s===e.length,()=>`Error in slice${s}D: Length of size ${e} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)M(t[r]+e[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${t[r]+e[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function aW(n){const t=[];let e=0;for(;n>0;)n&1&&t.push(e),n/=2,e++;return t}function Vv(n,t,e){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((t[r]-n[r])/e[r]);return s}function BE(n,t,e,s){const r=[...n];for(let i=r.length;i<s.length;i++)r.push(1);for(let i=0;i<e;i++)i===0?r[t]=1:(r.splice(t,0,1),r.pop());return r}function VE(n,t,e){return e<=n?e:e-(t-1)}function UE(n,t){const e=[];for(let s=0;s<n;s++)e.push(t+s);return e}function oW(n,t,e,s,r,i,a,o,u){const h=n.length;let d=new Array(h),f=new Array(h),m=new Array(h);if(t.length&&e>0){const y=t[0],x=e+1;d=WE(a,y,x,s,n),f=GE(o,y,x,r,n),m=BE(i,y,x,n)}else for(let y=0;y<h;y++)d[y]=jE(a,s,i,n,y,u),f[y]=XE(o,r,i,n,y,u),m[y]=HE(i,y,u);return{begin:d,end:f,strides:m}}function WE(n,t,e,s,r){const i=[...r],a=UE(e,t);for(let o=0;o<i.length;o++)if(a.indexOf(o)>-1)i[o]=0;else{const u=VE(t,e,o);let h=s[u];n&1<<u&&(h=0),i[o]=h}return i}function GE(n,t,e,s,r){const i=[...r],a=UE(e,t);for(let o=0;o<i.length;o++)if(a.indexOf(o)>-1)i[o]=Number.MAX_SAFE_INTEGER;else{const u=VE(t,e,o);let h=s[u];n&1<<u&&(h=Number.MAX_SAFE_INTEGER),i[o]=h}for(let o=0;o<i.length;o++){const u=r[o];i[o]<0&&(i[o]+=u),i[o]=Lp(0,i[o],r[o])}return i}function HE(n,t,e){let s=n[t];return(e&1<<t||s==null)&&(s=1),s}function jE(n,t,e,s,r,i){let a=t[r];const o=e[r]||1;(n&1<<r||i&1<<r||a==null)&&(o>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);const u=s[r];return a<0&&(a+=u),a=Lp(0,a,u-1),a}function XE(n,t,e,s,r,i){let a=t[r];const o=e[r]||1;(n&1<<r||i&1<<r||a==null)&&(o>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);const u=s[r];return a<0&&(a+=u),o>0?a=Lp(0,a,u):a=Lp(-1,a,u-1),a}function Uv(n,t,e){let s=e.length;for(let r=0;r<e.length;r++)if(e[r]>1){s=r;break}for(let r=s+1;r<e.length;r++)if(t[r]>0||e[r]!==n[r])return!1;return!0}function Wv(n,t){let e=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)e+=n[s]*t[s];return e}function Gv(n,t,e){let s;const r=n.shape.length;typeof t=="number"?s=[t,...new Array(r-1).fill(0)]:t.length<r?s=t.concat(new Array(r-t.length).fill(0)):s=t.slice(),s.forEach(a=>{M(a!==-1,()=>"slice() does not support negative begin indexing.")});let i;return e==null?i=new Array(r).fill(-1):typeof e=="number"?i=[e,...new Array(r-1).fill(-1)]:e.length<r?i=e.concat(new Array(r-e.length).fill(-1)):i=e,i=i.map((a,o)=>a>=0?a:(M(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${o}.`),n.shape[o]-s[o])),[s,i]}function Hv(n,t,e,s,r,i,a,o,u){let h;if(s==null?(h=new Array(t.length),h.fill(1)):h=s,a!=null&&(a&a-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let d=!1;const f={dims:h.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:h.slice(),beginMask:r,endMask:i,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:u};for(let E=0;E<f.dims;E++)d&&(1<<E&o)!==0&&f.numAddAxisAfterEllipsis++,1<<E&a&&(d=!0);d||(f.ellipsisMask|=1<<f.dims,f.dims++);const m={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};lW(f,m);let y=!0,x=!0,w=!0;const S=[],C=[];for(let E=0;E<n.length;++E){if(m.strides[E]===0)throw Error(`strides[${E}] must be non-zero`);const R=!!(m.shrinkAxisMask&1<<E),A=n[E];if(A===-1){S.push(R?1:-1);continue}const L=[m.beginMask&1<<E,m.endMask&1<<E],V=[m.strides[E]>0?0:-1,m.strides[E]>0?A:A-1];if(R&&m.strides[E]<=0)throw Error("only stride 1 allowed on non-range indexing.");w=w&&m.strides[E]===1;const B=!!(m.beginMask&1<<E&&m.endMask&1<<E);if(m.beginValid&&m.endValid){if(R){const Y=m.begin[E]<0?A+m.begin[E]:m.begin[E];if(m.begin[E]=Y,m.end[E]=m.begin[E]+1,Y<0||Y>=A)throw Error(`slice index ${m.begin[E]} of dimension ${E} out of bounds.`)}else m.begin[E]=z$(m.begin[E],0,m.strides[E],A,L,V),m.end[E]=z$(m.end[E],1,m.strides[E],A,L,V);const D=m.strides[E]===1&&m.begin[E]===0&&m.end[E]===A;y=y&&D,x=x&&(E===0&&m.strides[E]===1||D)}else y=y&&m.strides[E]===1&&B,x=x&&(E===0&&m.strides[E]===1||B);let z,U=!1;if(m.beginValid&&m.endValid?(z=m.end[E]-m.begin[E],U=!0):R?(z=1,U=!0):B&&A>=0&&(m.strides[E]<0?z=-A:z=A,U=!0),U){let D;z===0||z<0!=m.strides[E]<0?D=0:D=Math.trunc(z/m.strides[E])+(z%m.strides[E]!==0?1:0),S.push(D)}else S.push(-1)}for(let E=0;E<m.finalShapeGatherIndices.length;++E){const R=m.finalShapeGatherIndices[E];R>=0?C.push(S[R]):R===e0&&C.push(1)}return{finalShapeSparse:C.filter((E,R)=>m.finalShapeGatherIndices[R]!==e0),finalShape:C,isIdentity:y,sliceDim0:x,isSimpleSlice:w,begin:m.begin,end:m.end,strides:m.strides}}function lW(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=n.begin!=null,t.endValid=n.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(t.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,t.dims);for(;e<r;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=s}else if(1<<s&n.newAxisMask)t.finalShapeGatherIndices.push(e0),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);n.begin!=null&&(t.begin[e]=n.begin[s]),n.end!=null&&(t.end[e]=n.end[s]),t.strides[e]=n.strides[s],n.beginMask&1<<s&&(t.beginMask|=1<<e),n.endMask&1<<s&&(t.endMask|=1<<e),n.shrinkAxisMask&1<<s?(t.finalShapeGatherIndices.push(iW),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(s)),t.inputShapeGatherIndicesSparse[e]=s,e++}}function z$(n,t,e,s,r,i){if(r[t])return e>0?i[t]:i[t+1&1];{const a=n<0?s+n:n;return a<i[0]?i[0]:a>i[1]?i[1]:a}}const uW=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:Bv,computeFlatOffset:Wv,computeOutShape:Vv,getNormalizedAxes:oW,isSliceContinous:Uv,maskToAxes:aW,parseSliceParams:Gv,sliceInfo:Hv,startForAxis:jE,startIndicesWithElidedDims:WE,stopForAxis:XE,stopIndicesWithElidedDims:GE,stridesForAxis:HE,stridesWithElidedDims:BE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cW=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function hW(){return new Promise(n=>cW(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jv(n,t){const e=n[0].length;n.forEach((r,i)=>{M(r.length===e,()=>`Error in concat${e}D: rank of tensors[${i}] must be the same as the rank of the rest (${e})`)}),M(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const s=n[0];n.forEach((r,i)=>{for(let a=0;a<e;a++)M(a===t||r[a]===s[a],()=>`Error in concat${e}D: Shape of tensors[${i}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${i}.`)})}function Fr(n,t){const e=n[0].slice();for(let s=1;s<n.length;s++)e[t]+=n[s][t];return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Zr;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(Zr||(Zr={}));function qE(n,t,e){let s=new Array;if(e==null&&t==null)return s;if(t==null)for(;s.length<n+e.length;)s.push(-1);else s=t.slice();if(e==null)return s;if(n+e.length!==s.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n+e.length}, but shape.rank = ${s.length}`);for(let r=1;r<e.length;++r){const i=e[r],a=s[s.length-e.length+r],o=s[a];if(i>=0)if(o>=0){if(o!==i)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${r+n}] = ${i} but shape[${r+n}] = ${o}`)}else s[a]=i}return s}function KE(n){const t={FIRST_DIM_SIZE:Zr.FIRST_DIM_SIZE,VALUE_ROWIDS:Zr.VALUE_ROWIDS,ROW_LENGTHS:Zr.ROW_LENGTHS,ROW_SPLITS:Zr.ROW_SPLITS,ROW_LIMITS:Zr.ROW_LIMITS,ROW_STARTS:Zr.ROW_STARTS},e=[];for(const s of n)if(s in t)e.push(t[s]);else break;return e}function YE(n){return n.length===0?0:n[0]===Zr.FIRST_DIM_SIZE?n.length-1:n.length}function QE(n,t){if(n==null||t==null)return;const e=n.length,s=t.length;if(e>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(e,s-1);++r){const i=n[r],a=t[r+1];if(i>=0&&a>=0&&i!==1&&i!==a)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${r-n.length}] = ${i} but ragged tensor input.flatValues.shape[${r-n.length}] = ${a}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xv=30;function Im(n){return n<=Xv?n:Lx(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qv(n,t,e){const s=e*(typeof n=="number"?n:n[0]),r=t*(typeof n=="number"?n:n[1]);return[s,r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cd(n,t,e,s=!0){let r=[];if(s)r=r.concat(t.slice(0)),r.push(n[0]/e),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const i=t.length;for(let a=0;a<i;++a)r=r.concat([n[a+1]/t[a],t[a]]);r=r.concat(n.slice(i+1))}return r}function $d(n,t,e=!0){const s=[];if(e){s.push(t);for(let r=t+1;r<n;++r)r<=2*t?(s.push(r),s.push(r-(t+1))):s.push(r)}else{const r=[],i=[];for(let a=1;a<n;++a)a>=t*2+1||a%2===1?i.push(a):r.push(a);s.push(...r),s.push(0),s.push(...i)}return s}function Td(n,t,e,s=!0){const r=[];s?r.push(n[0]/e):r.push(n[0]*e);for(let i=1;i<n.length;++i)i<=t.length?s?r.push(t[i-1]*n[i]):r.push(n[i]/t[i-1]):r.push(n[i]);return r}function Kv(n,t){const e=[0];for(let s=0;s<t;++s)e.push(n[s][0]);return e}function Yv(n,t,e){const s=n.slice(0,1);for(let r=0;r<e;++r)s.push(n[r+1]-t[r][0]-t[r][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qv=1.7580993408473768,Zv=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jv=.3275911,tw=.254829592,ew=-.284496736,nw=1.421413741,sw=-1.453152027,rw=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rd(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);const e=new Float32Array(n.length*2);for(let s=0;s<e.length;s+=2)e[s]=n[s/2],e[s+1]=t[s/2];return e}function dW(n){const t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)t[s/2]=n[s],e[s/2]=n[s+1];return{real:t,imag:e}}function fW(n){const t=Math.ceil(n.length/4),e=new Float32Array(t),s=new Float32Array(t);for(let r=0;r<n.length;r+=4)e[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:e,imag:s}}function pW(n){const t=Math.floor(n.length/4),e=new Float32Array(t),s=new Float32Array(t);for(let r=2;r<n.length;r+=4)e[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:e,imag:s}}function mW(n,t){const e=n[t*2],s=n[t*2+1];return{real:e,imag:s}}function gW(n,t,e,s){n[s*2]=t,n[s*2+1]=e}function yW(n,t){const e=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const i=(t?2:-2)*Math.PI*(r/n);e[r]=Math.cos(i),s[r]=Math.sin(i)}return{real:e,imag:s}}function xW(n,t,e){const s=(e?2:-2)*Math.PI*(n/t),r=Math.cos(s),i=Math.sin(s);return{real:r,imag:i}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dx="->",bW=/->/g,B$=",",V$="...";function iw(n,t){n=n.replace(/\s/g,"");const e=(n.length-n.replace(bW,"").length)/dx.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${dx}").`);const[s,r]=n.split(dx);M(s.indexOf(V$)===-1,()=>`The ellipsis notation ("${V$}") is not supported yet.`);const i=s.split(B$),a=i.length;if(t!==a)throw new Error(`Expected ${a} input tensors, received ${t}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let m=0;m<r.length;++m){const y=r[m];if(!i.some(x=>x.indexOf(y)!==-1))throw new Error(`Output subscripts contain the label ${y} not present in the input subscripts.`);o.indexOf(y)===-1&&o.push(y)}for(let m=0;m<s.length;++m){const y=s[m];o.indexOf(y)===-1&&y!==B$&&o.push(y)}const u=new Array(i.length);for(let m=0;m<a;++m){if(new Set(i[m].split("")).size!==i[m].length)throw new Error(`Found duplicate axes in input component ${i[m]}. Support for duplicate axes in input is not implemented yet.`);u[m]=[];for(let y=0;y<i[m].length;++y)u[m].push(o.indexOf(i[m][y]))}const h=o.length,d=r.length,f=[];for(let m=d;m<h;++m)f.push(m);return{allDims:o,summedDims:f,idDims:u}}function aw(n,t){let e=new Array(n);e.fill(-1);for(let r=0;r<t.length;++r)e[t[r]]=r;const s=[];for(let r=0;r<n;++r)e[r]===-1&&s.push(r);return e=e.filter(r=>r!==-1),{permutationIndices:e,expandDims:s}}function ow(n,t,e){const s=new Array(n);for(let r=0;r<e.length;++r){const i=e[r].shape;for(let a=0;a<t[r].length;++a)s[t[r][a]]===void 0?s[t[r][a]]=i[a]:M(s[t[r][a]]===i[a],()=>`Expected dimension ${s[t[r][a]]} at axis ${a} of input shaped ${JSON.stringify(i)}, but got dimension ${i[a]}`)}}function lw(n,t){const e=n,s=[];let r=0;n.length===0&&e.push(-1),r=n.length+1;for(let a=0;a<r;++a)s.push([]);const i=[];for(let a=0;a<e.length;++a){const o=e[a],u=vW(t,o);for(const h of u)i.indexOf(h)===-1&&(s[a].push(h),i.push(h))}return{path:e,steps:s}}function uw(n){return n.every((t,e)=>t===e)}function vW(n,t){const e=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(t)!==-1||t===-1)&&e.push(s);return e}function cw(n,t,e=0){let s=[];if(typeof t=="number")M(n.shape[e]%t===0,()=>"Number of splits must evenly divide the axis."),s=new Array(t).fill(n.shape[e]/t);else{const r=t.reduce((a,o)=>(o===-1&&(a+=1),a),0);M(r<=1,()=>"There should be only one negative value in split array.");const i=t.indexOf(-1);if(i!==-1){const a=t.reduce((o,u)=>u>0?o+u:o);t[i]=n.shape[e]-a}M(n.shape[e]===t.reduce((a,o)=>a+o),()=>"The sum of sizes must match the size of the axis dimension."),s=t}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZE(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function JE(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function tR(n,t,e){return`indices(${n}, 0) is invalid: ${t} >= ${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eR(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function nR(n,t){return`size ${n} must be non-negative, not ${t}`}function sR(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function rR(n,t){const e=ht(n),s=ht(t);return`Input to reshape is a SparseTensor with ${e}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${t}`}function iR(n,t){const e=ht(n),s=ht(t);return`Input to reshape is a tensor with ${e} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n0(){return"segment ids must be >= 0"}function aR(){return"segment ids are not increasing"}function oR(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function lR(n,t,e){return`Bad: indices[${n}] == ${t} out of range [0, ${e})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uR(n,t){let e=!1,s;for(n<=Xv?(s=n,e=!0):s=Lx(n,Math.floor(Math.sqrt(n)));!e;)s>t||s===n?e=!0:s=Lx(n,s+1);return s}function hw(n,t,e){const s=[],r=n.length;for(let i=0;i<r;i++)i!==t?s.push(n[i]):s.push(e);return s}function dw(n,t,e,s){const r=t.shape.length,i=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${i}).`);if(e<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${e}).`);for(let f=0;f<s;++f)if(n.shape[f]!==t.shape[f])throw new Error(`x.shape[${f}]: ${n.shape[f]} should be equal to indices.shape[${f}]: ${t.shape[f]}.`);const a=n.shape[e],o=[];let u=1,h=1,d=1;for(let f=0;f<s;++f)o.push(n.shape[f]),u*=n.shape[f];for(let f=s;f<e;f++)o.push(n.shape[f]),h*=n.shape[f];for(let f=s;f<r;f++)o.push(t.shape[f]);for(let f=e+1;f<i;f++)o.push(n.shape[f]),d*=n.shape[f];return{batchSize:u,sliceSize:d,outerSize:h,dimSize:a,outputShape:o}}const wW=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:dw,computeOutShape:hw,segOpComputeOptimalWindowSize:uR},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function no(n){try{return n.map(t=>ea(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function cR(n){return n.map(t=>Ka(t))}const SW=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:tw,ERF_A2:ew,ERF_A3:nw,ERF_A4:sw,ERF_A5:rw,ERF_P:Jv,PARALLELIZE_THRESHOLD:Xv,get RowPartitionType(){return Zr},SELU_SCALE:Zv,SELU_SCALEALPHA:Qv,applyActivation:Em,assertAndGetBroadcastShape:ne,assertAxesAreInnerMostDims:Qs,assertParamsConsistent:jv,assignToTypedArray:gW,axesAreInnerMostDims:Cv,calculateShapes:$l,checkEinsumDimSizes:ow,checkPadOnDimRoundingMode:zr,combineLocations:tE,combineRaggedTensorToTensorShapes:qE,complexWithEvenIndex:fW,complexWithOddIndex:pW,computeConv2DInfo:vn,computeConv3DInfo:oo,computeDefaultPad:wv,computeDilation2DInfo:vd,computeOptimalWindowSize:Im,computeOutAndReduceShapes:mr,computeOutShape:Fr,computePool2DInfo:Mr,computePool3DInfo:la,convertConv2DDataFormat:ri,decodeEinsumEquation:iw,eitherStridesOrDilationsAreOne:ps,expandShapeToKeepDim:Ys,exponent:xW,exponents:yW,fromStringArrayToUint8:cR,fromUint8ToStringArray:no,getAxesPermutation:ts,getBroadcastDims:Wu,getComplexWithIndex:mW,getEinsumComputePath:lw,getEinsumPermutation:aw,getFusedBiasGradient:Nm,getFusedDyActivation:_m,getImageCenter:qv,getInnerMostAxes:es,getPermuted:$d,getRaggedRank:YE,getReductionAxes:QN,getReshaped:Cd,getReshapedPermuted:Td,getRowPartitionTypesHelper:KE,getSliceBeginCoords:Kv,getSliceSize:Yv,getSparseFillEmptyRowsIndicesDenseShapeMismatch:ZE,getSparseFillEmptyRowsNegativeIndexErrorMessage:JE,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:tR,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:sR,getSparseReshapeInputOutputMismatchErrorMessage:iR,getSparseReshapeInputOutputMultipleErrorMessage:rR,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:eR,getSparseReshapeNegativeOutputDimErrorMessage:nR,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:lR,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:n0,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:aR,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:oR,getUndoAxesPermutation:Sd,isIdentityPermutation:uw,log:wO,mergeRealAndImagArrays:rd,prepareAndValidate:zv,prepareSplitSize:cw,segment_util:wW,shouldFuse:Rm,slice_util:uW,splitRealAndImagArrays:dW,stridesOrDilationsArePositive:gl,tupleValuesAreOne:Qh,upcastType:Ns,validateDefaultValueShape:QE,validateInput:Iv,validateUpdateShape:TE,warn:Jr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zU();/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CW=tt();CW.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Us;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(Us||(Us={}));var U$;(function(n){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(U$||(U$={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $W={};function hR(n){return $W[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _(n,t,e,s,r){const i=t.inputParams[n];if(i&&i.inputIndexStart!==void 0){const o=i.inputIndexStart,u=i.inputIndexEnd===0?void 0:i.inputIndexEnd===void 0?o+1:i.inputIndexEnd,h=o<0?t.inputNames.length+o:o;if(i.type==="tensor")return Mn(t.inputNames[h],e,s,r);if(i.type==="tensors"){const m=t.inputs.slice(o,u);return t.inputNames.slice(o,u).filter((x,w)=>{var S;return((S=m[w])===null||S===void 0?void 0:S.op)!=="NoOp"}).map(x=>Mn(x,e,s,r))}const d=Mn(t.inputNames[h],e,s,r),f=d.dataSync();return i.type==="number"?f[0]:Mx(d.shape,f)}const a=t.attrParams[n];return a&&a.value}function Mn(n,t,e,s){const[r,i]=Ws(n,e);if(s!=null){const o=s.getHashTableHandleByName(r);if(o!=null)return o}const a=e.currentContextIds.find(o=>!!t[Yp(r,o)]);return a!==void 0?t[Yp(r,a)][i]:void 0}function W$(n,t,e){return t[Yp(n,e.currentContextId)]}function qi(n,t){const[e,s,r]=Ws(n,t);return[Yp(e,t&&t.currentContextId),s,r]}function Yp(n,t){return t?`${n}-${t}`:n}function Ws(n,t){if(n==="")return["",0,void 0];const e=t!=null&&t.parseNodeNameCache!=null;if(e){const i=t.parseNodeNameCache.get(n);if(i!=null)return i}const s=n.split(":");let r;if(s.length===1)r=[n,0,void 0];else{const i=s[0],a=s.length===3?s[1]:void 0,o=Number(s[s.length-1]);r=[i,o,a]}return e&&t.parseNodeNameCache.set(n,r),r}function Np(n,t,e){let s=_("pad",n,t,e);if(s==="explicit"){s=_("explicitPaddings",n,t,e);const r=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)r[i][0]=s[i*2],r[i][1]=s[i*2+1];return r}return s}function Ki(n){return n.kept?n:Ya(n)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TW=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],kW=Object.freeze(Object.defineProperty({__proto__:null,json:TW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _W=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],NW=Object.freeze(Object.defineProperty({__proto__:null,json:_W},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EW=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],RW=Object.freeze(Object.defineProperty({__proto__:null,json:EW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IW=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],AW=Object.freeze(Object.defineProperty({__proto__:null,json:IW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DW=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],OW=Object.freeze(Object.defineProperty({__proto__:null,json:DW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PW=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],FW=Object.freeze(Object.defineProperty({__proto__:null,json:PW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LW=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],MW=Object.freeze(Object.defineProperty({__proto__:null,json:LW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zW=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],BW=Object.freeze(Object.defineProperty({__proto__:null,json:zW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VW=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],UW=Object.freeze(Object.defineProperty({__proto__:null,json:VW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WW=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],GW=Object.freeze(Object.defineProperty({__proto__:null,json:WW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HW=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],jW=Object.freeze(Object.defineProperty({__proto__:null,json:HW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XW=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],qW=Object.freeze(Object.defineProperty({__proto__:null,json:XW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KW=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],YW=Object.freeze(Object.defineProperty({__proto__:null,json:KW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QW=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],ZW=Object.freeze(Object.defineProperty({__proto__:null,json:QW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JW=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],tG=Object.freeze(Object.defineProperty({__proto__:null,json:JW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eG=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],nG=Object.freeze(Object.defineProperty({__proto__:null,json:eG},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sG=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],rG=Object.freeze(Object.defineProperty({__proto__:null,json:sG},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iG=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],aG=Object.freeze(Object.defineProperty({__proto__:null,json:iG},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oG=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],lG=Object.freeze(Object.defineProperty({__proto__:null,json:oG},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class G${static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[kW,NW,RW,AW,OW,FW,MW,BW,UW,GW,jW,qW,YW,ZW,tG,nG,rG,aG,lG],e=[].concat(...t.map(s=>s.json));this.opMappers=e.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(t,e={}){const s=t.node,r=[],i=[],a=[],o=s.reduce((w,S)=>(w[S.name]=this.mapNode(S),S.op.startsWith("Placeholder")?r.push(w[S.name]):S.op==="Const"?i.push(w[S.name]):(S.input==null||S.input.length===0)&&a.push(w[S.name]),w),{});let u=[];const h=[];let d={},f={};e!=null&&(d=this.mapSignatureEntries(e.inputs),f=this.mapSignatureEntries(e.outputs));const m=Object.keys(o);m.forEach(w=>{const S=o[w];S.inputNames.forEach((C,k)=>{const[E,,R]=qi(C),A=o[E];if(A.outputs!=null){const L=A.outputs.indexOf(R);if(L!==-1){const V=`${E}:${L}`;S.inputNames[k]=V}}S.inputs.push(A),A.children.push(S)})}),Object.keys(f).length===0?m.forEach(w=>{const S=o[w];S.children.length===0&&h.push(S)}):Object.keys(f).forEach(w=>{const[S]=qi(w),C=o[S];C!=null&&(C.signatureKey=f[w],h.push(C))}),Object.keys(d).length>0?Object.keys(d).forEach(w=>{const[S]=qi(w),C=o[S];C&&(C.signatureKey=d[w],u.push(C))}):u=r;let y={};t.library!=null&&t.library.function!=null&&(y=t.library.function.reduce((w,S)=>(w[S.signature.name]=this.mapFunction(S),w),{}));const x={nodes:o,inputs:u,outputs:h,weights:i,placeholders:r,signature:e,functions:y};return a.length>0&&(x.initNodes=a),x}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,s)=>(e[t[s].name]=s,e),{})}mapNode(t){const e=hR(t.op)||this.opMappers[t.op]||{};t.attr==null&&(t.attr={});const s={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return e.inputs!=null&&(s.inputParams=e.inputs.reduce((r,i)=>(r[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},r),{})),e.attrs!=null&&(s.attrParams=e.attrs.reduce((r,i)=>{const a=i.type;let o;switch(i.type){case"string":o=s0(t.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=s0(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":o=c0(t.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=c0(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":o=i0(t.attr,i.tfName,i.defaultValue||0),o===void 0&&i.tfDeprecatedName&&(o=i0(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":o=u0(t.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=u0(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":o=r0(t.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=r0(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":o=d0(t.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=d0(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":o=l0(t.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=l0(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":o=h0(t.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=h0(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":o=a0(t.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=a0(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":o=o0(t.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=o0(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":o=H$(t.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=H$(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${t.op}`)}return r[i.name]={value:o,type:a},r},{})),s}mapFunction(t){const e=t.nodeDef,s=[],r=[];let i={};e!=null&&(i=e.reduce((f,m)=>(f[m.name]=this.mapNode(m),m.op==="Const"&&r.push(f[m.name]),f),{}));const a=[],o=[];t.signature.inputArg.forEach(f=>{const[m]=qi(f.name),y={name:m,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:fw(f.type),type:"dtype"}},children:[]};y.signatureKey=f.name,a.push(y),i[m]=y}),Object.keys(i).forEach(f=>{const m=i[f];m.inputNames.forEach((y,x)=>{const[w,,S]=qi(y),C=i[w];if(C.outputs!=null){const k=C.outputs.indexOf(S);if(k!==-1){const E=`${w}:${k}`;m.inputNames[x]=E}}m.inputs.push(C),C.children.push(m)})});const h=t.ret;t.signature.outputArg.forEach(f=>{const[m,y]=qi(h[f.name]),x=i[m];x!=null&&(x.defaultOutput=y,o.push(x))});const d=this.mapArgsToSignature(t);return{nodes:i,inputs:a,outputs:o,weights:r,placeholders:s,signature:d}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,s)=>(e[s.name]=this.mapArgToTensorInfo(s),e),{}),outputs:t.signature.outputArg.reduce((e,s)=>(e[s.name]=this.mapArgToTensorInfo(s,t.ret),e),{})}}mapArgToTensorInfo(t,e){let s=t.name;return e!=null&&(s=e[s]),{name:s,dtype:t.type}}}function uG(n){const t=tt().global;if(typeof t.atob<"u")return t.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function dR(n,t){const e=Array.isArray(n)?String.fromCharCode.apply(null,n):uG(n);return t?e:e.toLowerCase()}function s0(n,t,e,s=!1){const r=n[t];return r!=null?dR(r.s,s):e}function r0(n,t,e){const s=n[t];return s?s.b:e}function i0(n,t,e){const s=n[t]||{},r=s.i!=null?s.i:s.f!=null?s.f:e;return typeof r=="number"?r:parseInt(r,10)}function fw(n){switch(typeof n=="string"&&(n=Us[n]),n){case Us.DT_FLOAT:case Us.DT_HALF:return"float32";case Us.DT_INT32:case Us.DT_INT64:case Us.DT_INT8:case Us.DT_UINT8:return"int32";case Us.DT_BOOL:return"bool";case Us.DT_DOUBLE:return"float32";case Us.DT_STRING:return"string";case Us.DT_COMPLEX64:case Us.DT_COMPLEX128:return"complex64";default:return null}}function H$(n,t,e){const s=n[t];return s&&s.func?s.func.name:e}function a0(n,t,e){const s=n[t];return s&&s.type?fw(s.type):e}function o0(n,t,e){const s=n[t];return s&&s.list&&s.list.type?s.list.type.map(r=>fw(r)):e}function fR(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function l0(n,t,e){const s=n[t];return s&&s.shape?fR(s.shape):e}function u0(n,t,e){const s=n[t];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):e}function c0(n,t,e,s=!1){const r=n[t];return r&&r.list&&r.list.s?r.list.s.map(i=>dR(i,s)):e}function h0(n,t,e){const s=n[t];return s&&s.list&&s.list.shape?s.list.shape.map(r=>fR(r)):e}function d0(n,t,e){const s=n[t];return s&&s.list&&s.list.b?s.list.b:e}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cG{constructor(t,e,s){this.node=t,this.tensorMap=e,this.context=s,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(r=>this.getInput(r)),t.rawAttrs!=null&&(this.attrs=Object.keys(t.rawAttrs).reduce((r,i)=>(r[i]=this.getAttr(i),r),{}))}getInput(t){return Mn(t,this.tensorMap,this.context)}getAttr(t,e){const s=this.node.rawAttrs[t];if(s.tensor!=null)return Mn(t,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return i0(this.node.rawAttrs,t,e);if(s.s!=null)return s0(this.node.rawAttrs,t,e);if(s.b!=null)return r0(this.node.rawAttrs,t,e);if(s.shape!=null)return l0(this.node.rawAttrs,t,e);if(s.type!=null)return a0(this.node.rawAttrs,t,e);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return u0(this.node.rawAttrs,t,e);if(s.list.s!=null)return c0(this.node.rawAttrs,t,e);if(s.list.shape!=null)return h0(this.node.rawAttrs,t,e);if(s.list.b!=null)return d0(this.node.rawAttrs,t,e);if(s.list.type!=null)return o0(this.node.rawAttrs,t,e)}return e}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bn=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:EN,abs:ur,acos:MP,acosh:BP,add:zt,addN:UP,all:GP,any:jP,argMax:HN,argMin:KP,asin:QP,asinh:JP,atan:eF,atan2:sF,atanh:iF,avgPool:jN,avgPool3d:fF,basicLSTMCell:vF,batchNorm:wm,batchNorm2d:TF,batchNorm3d:_F,batchNorm4d:EF,batchToSpaceND:XN,bincount:qN,bitwiseAnd:AF,booleanMaskAsync:y4,broadcastArgs:OF,broadcastTo:Bh,buffer:Re,cast:Ue,ceil:LF,clipByValue:KN,clone:Ya,complex:Ja,concat:Rn,concat1d:BF,concat2d:UF,concat3d:GF,concat4d:jF,conv1d:KF,conv2d:Sm,conv2dTranspose:ZF,conv3d:tL,conv3dTranspose:rL,cos:aL,cosh:lL,cosineWindow:Av,cumprod:cL,cumsum:dL,denseBincount:pL,depthToSpace:gL,depthwiseConv2d:Sv,diag:bL,dilation2d:wL,div:ae,divNoNan:kL,dot:NL,dropout:R4,einsum:Au,elu:JN,enclosingPowerOfTwo:NE,ensureShape:AL,equal:ZN,erf:OL,euclideanNorm:WL,exp:ra,expandDims:cr,expm1:XL,eye:nE,fft:Ev,fill:wd,floor:sE,floorDiv:GN,fused:H4,gather:rE,gatherND:_4,greater:$m,greaterEqual:iE,ifft:Kp,imag:Tm,image:ll,inTopKAsync:A4,irfft:wE,isFinite:nM,isInf:rM,isNaN:aM,leakyRelu:aE,less:Zx,lessEqual:$v,linalg:$U,linspace:cM,localResponseNormalization:dM,log:Jh,log1p:oE,logSigmoid:bM,logSoftmax:SM,logSumExp:uE,logicalAnd:Xp,logicalNot:cE,logicalOr:hE,logicalXor:NM,losses:TU,lowerBound:RM,matMul:Pe,max:Lu,maxPool:dE,maxPool3d:DM,maxPoolWithArgmax:PM,maximum:fE,mean:qp,meshgrid:MM,min:Qx,minimum:td,mirrorPad:pE,mod:UM,moments:GM,movingAverage:v4,mul:wt,multiRNNCell:jM,multinomial:qM,neg:bi,norm:Cm,notEqual:mE,oneHot:QM,ones:rl,onesLike:JM,op:q,outerProduct:ez,pad:eo,pad1d:rz,pad2d:az,pad3d:lz,pad4d:cz,pool:mz,pow:Zh,prelu:yE,print:WN,prod:xz,raggedGather:vz,raggedRange:Sz,raggedTensorToTensor:$z,rand:kz,randomGamma:qz,randomNormal:xE,randomStandardNormal:Qz,randomUniform:Nv,randomUniformInt:tB,range:ed,real:nd,reciprocal:sB,relu:km,relu6:bE,reshape:ft,reverse:yl,reverse1d:lB,reverse2d:cB,reverse3d:dB,reverse4d:pB,rfft:Rv,round:vE,rsqrt:yB,scalar:ie,scatterND:S4,searchSorted:Tv,selu:bB,separableConv2d:wB,setdiff1dAsync:CB,sigmoid:Zi,sign:TB,signal:CU,sin:_B,sinh:EB,slice:re,slice1d:IB,slice2d:DB,slice3d:PB,slice4d:LB,softmax:zB,softplus:lE,spaceToBatchND:gE,sparse:kU,sparseToDense:T4,spectral:SU,split:sd,sqrt:sa,square:Dr,squaredDifference:SE,squeeze:De,stack:oa,step:CE,stridedSlice:YB,string:_U,sub:Jt,sum:Ke,tan:ZB,tanh:Yx,tensor:xi,tensor1d:Jn,tensor2d:Or,tensor3d:$E,tensor4d:JB,tensor5d:t4,tensor6d:e4,tensorScatterUpdate:s4,tile:Vh,topk:i4,transpose:Jx,truncatedNormal:o4,unique:u4,unsortedSegmentSum:h4,unstack:Tl,upperBound:f4,variable:p4,where:Qa,whereAsync:_E,zeros:aa,zerosLike:fr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hG=(n,t,e,s=Bn)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(_("a",n,t,e),_("b",n,t,e))];case"AddN":return[s.addN(_("tensors",n,t,e))];case"FloorMod":case"Mod":return[s.mod(_("a",n,t,e),_("b",n,t,e))];case"Mul":return[s.mul(_("a",n,t,e),_("b",n,t,e))];case"RealDiv":case"Div":return[s.div(_("a",n,t,e),_("b",n,t,e))];case"DivNoNan":return[s.divNoNan(_("a",n,t,e),_("b",n,t,e))];case"FloorDiv":return[s.floorDiv(_("a",n,t,e),_("b",n,t,e))];case"Sub":return[s.sub(_("a",n,t,e),_("b",n,t,e))];case"Minimum":return[s.minimum(_("a",n,t,e),_("b",n,t,e))];case"Maximum":return[s.maximum(_("a",n,t,e),_("b",n,t,e))];case"Pow":return[s.pow(_("a",n,t,e),_("b",n,t,e))];case"SquaredDifference":return[s.squaredDifference(_("a",n,t,e),_("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dG=(n,t,e,s=Bn)=>{switch(n.op){case"Abs":case"ComplexAbs":return[s.abs(_("x",n,t,e))];case"Acos":return[s.acos(_("x",n,t,e))];case"Acosh":return[s.acosh(_("x",n,t,e))];case"Asin":return[s.asin(_("x",n,t,e))];case"Asinh":return[s.asinh(_("x",n,t,e))];case"Atan":return[s.atan(_("x",n,t,e))];case"Atan2":return[s.atan2(_("x",n,t,e),_("y",n,t,e))];case"Atanh":return[s.atanh(_("x",n,t,e))];case"Ceil":return[s.ceil(_("x",n,t,e))];case"Complex":return[s.complex(_("real",n,t,e),_("imag",n,t,e))];case"Cos":return[s.cos(_("x",n,t,e))];case"Cosh":return[s.cosh(_("x",n,t,e))];case"Elu":return[s.elu(_("x",n,t,e))];case"Erf":return[s.erf(_("x",n,t,e))];case"Exp":return[s.exp(_("x",n,t,e))];case"Expm1":return[s.expm1(_("x",n,t,e))];case"Floor":return[s.floor(_("x",n,t,e))];case"Log":return[s.log(_("x",n,t,e))];case"Log1p":return[s.log1p(_("x",n,t,e))];case"Imag":return[s.imag(_("x",n,t,e))];case"Neg":return[s.neg(_("x",n,t,e))];case"Reciprocal":return[s.reciprocal(_("x",n,t,e))];case"Real":return[s.real(_("x",n,t,e))];case"Relu":return[s.relu(_("x",n,t,e))];case"Round":return[s.round(_("x",n,t,e))];case"Selu":return[s.selu(_("x",n,t,e))];case"Sigmoid":return[s.sigmoid(_("x",n,t,e))];case"Sin":return[s.sin(_("x",n,t,e))];case"Sign":return[s.sign(_("x",n,t,e))];case"Sinh":return[s.sinh(_("x",n,t,e))];case"Softplus":return[s.softplus(_("x",n,t,e))];case"Sqrt":return[s.sqrt(_("x",n,t,e))];case"Square":return[s.square(_("x",n,t,e))];case"Tanh":return[s.tanh(_("x",n,t,e))];case"Tan":return[s.tan(_("x",n,t,e))];case"ClipByValue":return[s.clipByValue(_("x",n,t,e),_("clipValueMin",n,t,e),_("clipValueMax",n,t,e))];case"Relu6":return[s.relu6(_("x",n,t,e))];case"Rsqrt":return[s.rsqrt(Mn(n.inputNames[0],t,e))];case"LeakyRelu":return[s.leakyRelu(_("x",n,t,e),_("alpha",n,t,e))];case"Prelu":return[s.prelu(_("x",n,t,e),_("alpha",n,t,e))];case"IsNan":return[s.isNaN(Mn(n.inputNames[0],t,e))];case"IsInf":return[s.isInf(Mn(n.inputNames[0],t,e))];case"IsFinite":return[s.isFinite(Mn(n.inputNames[0],t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ir(n,t,e=""){if(!(typeof n=="number"||typeof t=="number")){M(n.length===t.length,()=>e+` Shapes ${n} and ${t} must match`);for(let s=0;s<n.length;s++){const r=n[s],i=t[s];M(r<0||i<0||r===i,()=>e+` Shapes ${n} and ${t} must match`)}}}function j$(n){return!(typeof n=="number"||n.some(t=>t<0))}function xh(n,t,e){let s=f0(n,e);const r=!j$(s);if(r&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&t.forEach(i=>{s=f0(i.shape,s)}),!j$(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function f0(n,t){if(typeof n=="number")return t;if(typeof t=="number")return n;if(n.length!==t.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${t}`);const e=[];for(let s=0;s<n.length;++s){const r=n[s],i=t[s];if(r>=0&&i>=0&&r!==i)throw new Error(`Incompatible shape during merge: ${n} vs. ${t}`);e[s]=r>=0?r:i}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fG{constructor(t,e,s,r,i,a,o){this.name=t,this.dtype=e,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=i,this.dynamicSize=a,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=ie(0),gi(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},
          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=e.shape),Ir(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);s.tensor=e,gi(e),s.written=!0,this.tensors[t]=s}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((s,r)=>this.write(s,e[r]))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let r=0;r<this.size();r++)t.push(r)}if(t.length===0)return xi([],[0].concat(this.elementShape));const s=this.readMany(t);return Ir(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),oa(s,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(this.size()===0)return xi([],[0].concat(this.elementShape));const e=[];for(let r=0;r<this.size();r++)e.push(r);const s=this.readMany(e);return Ir(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),Rn(s,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const s=Math.max(...t);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(t,Tl(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let s=0;const r=t.map(u=>(s+=u,s));if(s!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const i=s===0?0:e.size/s,a=[];Yt(()=>{e=ft(e,[1,s,i]);for(let u=0;u<t.length;++u){const d=[0,u===0?0:r[u-1],0],f=[1,t[u],i];a[u]=ft(re(e,d,f),this.elementShape)}return a});const o=[];for(let u=0;u<t.length;u++)o[u]=u;this.writeMany(o,a)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bl{get id(){return this.idTensor.id}constructor(t,e,s,r=-1){this.tensors=t,this.elementShape=e,this.elementDtype=s,t?.forEach(i=>{if(s!==i.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${i.dtype}`);Ir(e,i.shape,"TensorList shape mismatch: "),gi(i)}),this.idTensor=ie(0),this.maxNumElements=r,gi(this.idTensor)}copy(){return new bl([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,s=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);Ir(t,this.elementShape,"TensorList shape mismatch: ");const r=xh(this.elementShape,this.tensors,t);return Yt(()=>{const i=this.tensors.map(a=>ft(a,r));return oa(i,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=xh(this.elementShape,this.tensors,t),r=this.tensors.pop();return r.kept=!1,Ir(r.shape,t,"TensorList shape mismatch: "),ft(r,s)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Ir(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");gi(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const e=new bl([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let s=0;s<Math.min(this.tensors.length,t);++s)e.tensors[s]=this.tensors[s];return e}getItem(t,e,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);Ir(this.tensors[t].shape,e,"TensorList shape mismatch: ");const r=xh(this.elementShape,this.tensors,e);return ft(this.tensors[t],r)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Ir(this.elementShape,e.shape,"TensorList shape mismatch: "),gi(e),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=e}gather(t,e,s){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);Ir(this.elementShape,s,"TensorList shape mismatch: "),t=t.slice(0,this.size());const r=xh(this.elementShape,this.tensors,s);return t.length===0?xi([],[0].concat(r)):Yt(()=>{const i=t.map(a=>ft(this.tensors[a],r));return oa(i,0)})}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Ir(this.elementShape,e,"TensorList shape mismatch: ");const s=xh(this.elementShape,this.tensors,e);return this.size()===0?xi([],[0].concat(s)):Yt(()=>{const r=this.tensors.map(i=>ft(i,s));return Rn(r,0)})}}function pG(n,t,e){const s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==e)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${e}`);const r=n.shape.slice(1);Ir(r,t,"TensorList shape mismatch: ");const i=Tl(n);return new bl(i,t,s)}function mG(n,t,e,s){return new bl([],n,t,s)}function gG(n,t,e,s){if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);const r=Math.max(...t);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const i=new bl([],e,n.dtype,s),a=Tl(n,0);return t.forEach((o,u)=>{i.setItem(o,a[u])}),i}function yG(n,t,e){let s=0;const r=t.map(d=>(s+=d,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);const i=n.shape.slice(1),a=f0(i,e),o=s===0?0:n.size/s,u=Yt(()=>{const d=[];n=ft(n,[1,s,o]);for(let f=0;f<t.length;++f){const y=[0,f===0?0:r[f-1],0],x=[1,t[f],o];d[f]=ft(re(n,y,x),a)}return n.dispose(),d}),h=new bl([],e,n.dtype,t.length);for(let d=0;d<u.length;d++)h.setItem(d,u[d]);return h}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xG=async(n,t,e)=>{switch(n.op){case"If":case"StatelessIf":{const s=_("thenBranch",n,t,e),r=_("elseBranch",n,t,e),i=_("cond",n,t,e),a=_("args",n,t,e);return(await i.data())[0]?e.functionMap[s].executeFunctionAsync(a,e.tensorArrayMap,e.tensorListMap):e.functionMap[r].executeFunctionAsync(a,e.tensorArrayMap,e.tensorListMap)}case"While":case"StatelessWhile":{const s=_("body",n,t,e),r=_("cond",n,t,e),i=_("args",n,t,e),a=await e.functionMap[r].executeFunctionAsync(i,e.tensorArrayMap,e.tensorListMap),o=i.map(d=>d.id);let u=await a[0].data();a.forEach(d=>{!d.kept&&o.indexOf(d.id)===-1&&d.dispose()});let h=i;for(;u[0];){const d=h;h=await e.functionMap[s].executeFunctionAsync(h,e.tensorArrayMap,e.tensorListMap);const f=h.map(y=>y.id);d.forEach(y=>{!y.kept&&o.indexOf(y.id)===-1&&f.indexOf(y.id)===-1&&y.dispose()});const m=await e.functionMap[r].executeFunctionAsync(h,e.tensorArrayMap,e.tensorListMap);u=await m[0].data(),m.forEach(y=>{!y.kept&&o.indexOf(y.id)===-1&&f.indexOf(y.id)===-1&&y.dispose()})}return h}case"LoopCond":{const s=_("pred",n,t,e);return[Ki(s)]}case"Switch":{const s=_("pred",n,t,e);let r=_("data",n,t,e);return r.kept||(r=Ki(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=n.inputNames.find(r=>Mn(r,t,e)!==void 0);if(s){const r=Mn(s,t,e);return[Ki(r)]}return}case"Enter":{const s=_("frameName",n,t,e),r=_("tensor",n,t,e);return e.enterFrame(s),[Ki(r)]}case"Exit":{const s=_("tensor",n,t,e);return e.exitFrame(),[Ki(s)]}case"NextIteration":{const s=_("tensor",n,t,e);return e.nextIteration(),[Ki(s)]}case"TensorArrayV3":{const s=_("size",n,t,e),r=_("dtype",n,t,e),i=_("elementShape",n,t,e),a=_("dynamicSize",n,t,e),o=_("clearAfterRead",n,t,e),u=_("identicalElementShapes",n,t,e),h=_("name",n,t,e),d=new fG(h,r,s,i,u,a,o);return e.addTensorArray(d),[d.idTensor,ie(1)]}case"TensorArrayWriteV3":{const s=_("tensorArrayId",n,t,e),r=_("index",n,t,e),i=_("tensor",n,t,e),a=e.getTensorArray(s.id);return a.write(r,i),[a.idTensor]}case"TensorArrayReadV3":{const s=_("tensorArrayId",n,t,e),r=_("index",n,t,e);return[e.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=_("tensorArrayId",n,t,e),r=_("indices",n,t,e),i=_("dtype",n,t,e);return[e.getTensorArray(s.id).gather(r,i)]}case"TensorArrayScatterV3":{const s=_("tensorArrayId",n,t,e),r=_("indices",n,t,e),i=_("tensor",n,t,e),a=e.getTensorArray(s.id);return a.scatter(r,i),[a.idTensor]}case"TensorArrayConcatV3":{const s=_("tensorArrayId",n,t,e),r=e.getTensorArray(s.id),i=_("dtype",n,t,e);return[r.concat(i)]}case"TensorArraySplitV3":{const s=_("tensorArrayId",n,t,e),r=_("tensor",n,t,e),i=_("lengths",n,t,e),a=e.getTensorArray(s.id);return a.split(i,r),[a.idTensor]}case"TensorArraySizeV3":{const s=_("tensorArrayId",n,t,e),r=e.getTensorArray(s.id);return[ie(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=_("tensorArrayId",n,t,e),r=e.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=_("tensorListId",n,t,e),r=_("index",n,t,e),i=_("tensor",n,t,e),a=e.getTensorList(s.id);return a.setItem(r,i),[a.idTensor]}case"TensorListGetItem":{const s=_("tensorListId",n,t,e),r=_("index",n,t,e),i=_("elementShape",n,t,e),a=_("elementDType",n,t,e);return[e.getTensorList(s.id).getItem(r,i,a)]}case"TensorListScatterV2":case"TensorListScatter":{const s=_("indices",n,t,e),r=_("tensor",n,t,e),i=_("elementShape",n,t,e),a=_("numElements",n,t,e),o=gG(r,s,i,a);return e.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=_("elementShape",n,t,e),r=_("elementDType",n,t,e);let i;n.op==="TensorListReserve"?i="numElements":i="maxNumElements";const a=_(i,n,t,e),o=n.op==="TensorListReserve"?-1:a,u=mG(s,r,a,o);return e.addTensorList(u),[u.idTensor]}case"TensorListGather":{const s=_("tensorListId",n,t,e),r=_("indices",n,t,e),i=_("elementShape",n,t,e),a=_("elementDType",n,t,e);return[e.getTensorList(s.id).gather(r,a,i)]}case"TensorListStack":{const s=_("tensorListId",n,t,e),r=_("elementShape",n,t,e),i=_("elementDType",n,t,e),a=_("numElements",n,t,e);return[e.getTensorList(s.id).stack(r,i,a)]}case"TensorListFromTensor":{const s=_("tensor",n,t,e),r=_("elementShape",n,t,e),i=_("elementDType",n,t,e),a=pG(s,r,i);return e.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=_("tensorListId",n,t,e),r=e.getTensorList(s.id),i=_("dtype",n,t,e),a=_("elementShape",n,t,e);return[r.concat(i,a)]}case"TensorListPushBack":{const s=_("tensorListId",n,t,e),r=_("tensor",n,t,e),i=e.getTensorList(s.id);return i.pushBack(r),[i.idTensor]}case"TensorListPopBack":{const s=_("tensorListId",n,t,e),r=_("elementShape",n,t,e),i=_("elementDType",n,t,e);return[e.getTensorList(s.id).popBack(r,i)]}case"TensorListSplit":{const s=_("tensor",n,t,e),r=_("elementShape",n,t,e),i=_("lengths",n,t,e),a=yG(s,i,r);return e.addTensorList(a),[a.idTensor]}case"TensorListLength":{const s=_("tensorListId",n,t,e),r=e.getTensorList(s.id);return[ie(r.size(),"int32")]}case"TensorListResize":{const s=_("tensorListId",n,t,e),r=_("size",n,t,e),a=e.getTensorList(s.id).resize(r);return e.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X$(n,t,e){const[s,r]=_("fusedOps",n,t,e),i=s==="biasadd",a=!i,o=r==="prelu",u=s==="fusedbatchnorm",h=_("numArgs",n,t,e);if(i){if(o&&h!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&i&&h!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const d=_("strides",n,t,e),f=Np(n,t,e),m=_("dataFormat",n,t,e).toUpperCase(),y=_("dilations",n,t,e);let[x,w]=_("args",n,t,e);a&&(w=x,x=void 0);const S=_("leakyreluAlpha",n,t,e);return{stride:d,pad:f,dataFormat:m,dilations:y,biasArg:x,preluArg:w,activationFunc:r,leakyreluAlpha:S}}const bG=(n,t,e,s=Bn)=>{switch(n.op){case"Conv1D":{const r=_("stride",n,t,e),i=_("pad",n,t,e),a=_("dataFormat",n,t,e).toUpperCase(),o=_("dilation",n,t,e);return[s.conv1d(_("x",n,t,e),_("filter",n,t,e),r,i,a,o)]}case"Conv2D":{const r=_("strides",n,t,e),i=Np(n,t,e),a=_("dataFormat",n,t,e).toUpperCase(),o=_("dilations",n,t,e);return[s.conv2d(_("x",n,t,e),_("filter",n,t,e),[r[1],r[2]],i,a,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:r,pad:i,dataFormat:a,dilations:o,biasArg:u,preluArg:h,activationFunc:d,leakyreluAlpha:f}=X$(n,t,e);return[s.fused.conv2d({x:_("x",n,t,e),filter:_("filter",n,t,e),strides:[r[1],r[2]],pad:i,dataFormat:a,dilations:[o[1],o[2]],bias:u,activation:d,preluActivationWeights:h,leakyreluAlpha:f})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:i,dataFormat:a,dilations:o,biasArg:u,preluArg:h,activationFunc:d,leakyreluAlpha:f}=X$(n,t,e);return[s.fused.depthwiseConv2d({x:_("x",n,t,e),filter:_("filter",n,t,e),strides:[r[1],r[2]],pad:i,dataFormat:a,dilations:[o[1],o[2]],bias:u,activation:d,preluActivationWeights:h,leakyreluAlpha:f})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=_("outputShape",n,t,e),i=_("strides",n,t,e),a=Np(n,t,e);return[s.conv2dTranspose(_("x",n,t,e),_("filter",n,t,e),r,[i[1],i[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=_("strides",n,t,e),i=Np(n,t,e),a=_("dilations",n,t,e),o=_("dataFormat",n,t,e).toUpperCase();return[s.depthwiseConv2d(_("input",n,t,e),_("filter",n,t,e),[r[1],r[2]],i,o,[a[1],a[2]])]}case"Conv3D":{const r=_("strides",n,t,e),i=_("pad",n,t,e),a=_("dataFormat",n,t,e).toUpperCase(),o=_("dilations",n,t,e);return[s.conv3d(_("x",n,t,e),_("filter",n,t,e),[r[1],r[2],r[3]],i,a,[o[1],o[2],o[3]])]}case"AvgPool":{const r=_("strides",n,t,e),i=_("pad",n,t,e),a=_("kernelSize",n,t,e);return[s.avgPool(_("x",n,t,e),[a[1],a[2]],[r[1],r[2]],i)]}case"MaxPool":{const r=_("strides",n,t,e),i=_("pad",n,t,e),a=_("kernelSize",n,t,e);return[s.maxPool(_("x",n,t,e),[a[1],a[2]],[r[1],r[2]],i)]}case"MaxPoolWithArgmax":{const r=_("strides",n,t,e),i=_("pad",n,t,e),a=_("kernelSize",n,t,e),o=_("includeBatchInIndex",n,t,e),{result:u,indexes:h}=s.maxPoolWithArgmax(_("x",n,t,e),[a[1],a[2]],[r[1],r[2]],i,o);return[u,h]}case"AvgPool3D":{const r=_("strides",n,t,e),i=_("pad",n,t,e),a=_("kernelSize",n,t,e);return[s.avgPool3d(_("x",n,t,e),[a[1],a[2],a[3]],[r[1],r[2],r[3]],i)]}case"MaxPool3D":{const r=_("strides",n,t,e),i=_("pad",n,t,e),a=_("kernelSize",n,t,e);return[s.maxPool3d(_("x",n,t,e),[a[1],a[2],a[3]],[r[1],r[2],r[3]],i)]}case"Dilation2D":{const r=_("strides",n,t,e),i=_("pad",n,t,e),a=_("dilations",n,t,e),o=r[1],u=r[2],h=a[1],d=a[2];return[s.dilation2d(_("x",n,t,e),_("filter",n,t,e),[o,u],i,[h,d],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vG=(n,t,e,s=Bn)=>{switch(n.op){case"Fill":{const r=_("shape",n,t,e),i=_("dtype",n,t,e),a=_("value",n,t,e);return[s.fill(r,a,i)]}case"LinSpace":{const r=_("start",n,t,e),i=_("stop",n,t,e),a=_("num",n,t,e);return[s.linspace(r,i,a)]}case"Multinomial":{const r=_("logits",n,t,e),i=_("numSamples",n,t,e),a=_("seed",n,t,e);return[s.multinomial(r,i,a)]}case"OneHot":{const r=_("indices",n,t,e),i=_("depth",n,t,e),a=_("onValue",n,t,e),o=_("offValue",n,t,e),u=_("dtype",n,t,e);return[s.oneHot(r,i,a,o,u)]}case"Ones":return[s.ones(_("shape",n,t,e),_("dtype",n,t,e))];case"OnesLike":return[s.onesLike(_("x",n,t,e))];case"RandomStandardNormal":return[s.randomStandardNormal(_("shape",n,t,e),_("dtype",n,t,e),_("seed",n,t,e))];case"RandomUniform":return[s.randomUniform(_("shape",n,t,e),_("minval",n,t,e),_("maxval",n,t,e),_("dtype",n,t,e))];case"RandomUniformInt":return[s.randomUniformInt(_("shape",n,t,e),_("minval",n,t,e),_("maxval",n,t,e),_("seed",n,t,e))];case"Range":{const r=_("start",n,t,e),i=_("stop",n,t,e),a=_("step",n,t,e);return[s.range(r,i,a,_("dtype",n,t,e))]}case"TruncatedNormal":{const r=_("shape",n,t,e),i=_("mean",n,t,e),a=_("stdDev",n,t,e),o=_("seed",n,t,e);return[s.truncatedNormal(r,i,a,_("dtype",n,t,e),o)]}case"Zeros":return[s.zeros(_("shape",n,t,e),_("dtype",n,t,e))];case"ZerosLike":return[s.zerosLike(_("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fx(n,t,e){const s=_("boxes",n,t,e),r=_("scores",n,t,e),i=_("maxOutputSize",n,t,e),a=_("iouThreshold",n,t,e),o=_("scoreThreshold",n,t,e),u=_("softNmsSigma",n,t,e);return{boxes:s,scores:r,maxOutputSize:i,iouThreshold:a,scoreThreshold:o,softNmsSigma:u}}const wG=async(n,t,e,s,r=Bn)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:i,scores:a,maxOutputSize:o,iouThreshold:u,scoreThreshold:h,softNmsSigma:d}=fx(n,t,e),f=await r.image.nonMaxSuppressionWithScoreAsync(i,a,o,u,h,d);return[f.selectedIndices,f.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:i,scores:a,maxOutputSize:o,iouThreshold:u,scoreThreshold:h}=fx(n,t,e),d=_("padToMaxOutputSize",n,t,e),f=await r.image.nonMaxSuppressionPaddedAsync(i,a,o,u,h,d);return[f.selectedIndices,f.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:i,scores:a,maxOutputSize:o,iouThreshold:u,scoreThreshold:h}=fx(n,t,e);return[await r.image.nonMaxSuppressionAsync(i,a,o,u,h)]}case"Where":{const i=r.cast(_("condition",n,t,e),"bool"),a=[await r.whereAsync(i)];return i.dispose(),a}case"ListDiff":return r.setdiff1dAsync(_("x",n,t,e),_("y",n,t,e));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SG=(n,t,e,s=Bn)=>{switch(n.op){case"LowerBound":{const r=_("sortedSequence",n,t,e),i=_("values",n,t,e);return[s.lowerBound(r,i)]}case"TopKV2":{const r=_("x",n,t,e),i=_("k",n,t,e),a=_("sorted",n,t,e),o=s.topk(r,i,a);return[o.values,o.indices]}case"UpperBound":{const r=_("sortedSequence",n,t,e),i=_("values",n,t,e);return[s.upperBound(r,i)]}case"Unique":{const r=_("x",n,t,e),i=s.unique(r);return[i.values,i.indices]}case"UniqueV2":{const r=_("x",n,t,e),i=_("axis",n,t,e),a=s.unique(r,i);return[a.values,a.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CG=(n,t,e,s=Bn)=>{switch(n.op){case"Const":return t[n.name];case"PlaceholderWithDefault":const r=_("default",n,t,e);return[Mn(n.name,t,e)||r];case"Placeholder":return[Mn(n.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const d=_("x",n,t,e);return[Ki(d)]}case"IdentityN":return _("x",n,t,e).map(d=>Ki(d));case"Snapshot":const i=_("x",n,t,e);return[Ki(i)];case"Shape":return[s.tensor1d(_("x",n,t,e).shape,"int32")];case"ShapeN":return _("x",n,t,e).map(d=>s.tensor1d(d.shape));case"Size":return[s.scalar(_("x",n,t,e).size,"int32")];case"Rank":return[s.scalar(_("x",n,t,e).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const a=_("x",n,t,e),o=_("data",n,t,e),u=_("message",n,t,e),h=_("summarize",n,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let d=0;d<o.length;d++)console.log(Array.prototype.slice.call(o[d].dataSync()).slice(0,h));return[a];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $G{get id(){return this.handle.id}constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=ie(0),this.tensorMap=new Map,gi(this.handle)}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return ie(this.size(),"int32")}async import(t,e){this.checkKeyAndValueTensor(t,e);const s=await t.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),Yt(()=>{const r=Tl(e),i=s.length,a=r.length;M(i===a,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${a} elements.`);for(let o=0;o<i;o++){const u=s[o],h=r[o];gi(h),this.tensorMap.set(u,h)}return this.handle})}async find(t,e){this.checkKeyAndValueTensor(t,e);const s=await t.data();return Yt(()=>{const r=[];for(let i=0;i<s.length;i++){const a=s[i],o=this.findWithDefault(a,e);r.push(o)}return oa(r)})}findWithDefault(t,e){const s=this.tensorMap.get(t);return s??e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TG=async(n,t,e,s)=>{switch(n.op){case"HashTable":case"HashTableV2":{const r=s.getHashTableHandleByName(n.name);if(r!=null)return[r];{const i=_("keyDType",n,t,e),a=_("valueDType",n,t,e),o=new $G(i,a);return s.addHashTable(n.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=_("tableHandle",n,t,e,s),i=_("keys",n,t,e),a=_("values",n,t,e);return[await s.getHashTableById(r.id).import(i,a)]}case"LookupTableFind":case"LookupTableFindV2":{const r=_("tableHandle",n,t,e,s),i=_("keys",n,t,e),a=_("defaultValue",n,t,e);return[await s.getHashTableById(r.id).find(i,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=_("tableHandle",n,t,e,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kG=(n,t,e,s=Bn)=>{switch(n.op){case"ResizeBilinear":{const r=_("images",n,t,e),i=_("size",n,t,e),a=_("alignCorners",n,t,e),o=_("halfPixelCenters",n,t,e);return[s.image.resizeBilinear(r,[i[0],i[1]],a,o)]}case"ResizeNearestNeighbor":{const r=_("images",n,t,e),i=_("size",n,t,e),a=_("alignCorners",n,t,e),o=_("halfPixelCenters",n,t,e);return[s.image.resizeNearestNeighbor(r,[i[0],i[1]],a,o)]}case"CropAndResize":{const r=_("image",n,t,e),i=_("boxes",n,t,e),a=_("boxInd",n,t,e),o=_("cropSize",n,t,e),u=_("method",n,t,e),h=_("extrapolationValue",n,t,e);return[s.image.cropAndResize(r,i,a,o,u,h)]}case"ImageProjectiveTransformV3":{const r=_("images",n,t,e),i=_("transforms",n,t,e),a=_("outputShape",n,t,e),o=_("fillValue",n,t,e),u=_("interpolation",n,t,e),h=_("fillMode",n,t,e);return[s.image.transform(r,i,u.toLowerCase(),h.toLowerCase(),o,a)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _G=(n,t,e,s=Bn)=>{switch(n.op){case"Equal":return[s.equal(_("a",n,t,e),_("b",n,t,e))];case"NotEqual":return[s.notEqual(_("a",n,t,e),_("b",n,t,e))];case"Greater":return[s.greater(_("a",n,t,e),_("b",n,t,e))];case"GreaterEqual":return[s.greaterEqual(_("a",n,t,e),_("b",n,t,e))];case"Less":return[s.less(_("a",n,t,e),_("b",n,t,e))];case"LessEqual":return[s.lessEqual(_("a",n,t,e),_("b",n,t,e))];case"LogicalAnd":return[s.logicalAnd(_("a",n,t,e),_("b",n,t,e))];case"LogicalNot":return[s.logicalNot(_("a",n,t,e))];case"LogicalOr":return[s.logicalOr(_("a",n,t,e),_("b",n,t,e))];case"Select":case"SelectV2":return[s.where(_("condition",n,t,e),_("a",n,t,e),_("b",n,t,e))];case"BitwiseAnd":return[s.bitwiseAnd(_("a",n,t,e),_("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NG=(n,t,e,s=Bn)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(_("a",n,t,e),_("b",n,t,e),_("transposeA",n,t,e),_("transposeB",n,t,e))];case"Einsum":return[s.einsum(_("equation",n,t,e),..._("tensors",n,t,e))];case"Transpose":return[s.transpose(_("x",n,t,e),_("perm",n,t,e))];case"_FusedMatMul":const[r,i]=_("fusedOps",n,t,e),a=r==="biasadd",o=i==="prelu",u=_("numArgs",n,t,e),h=_("leakyreluAlpha",n,t,e);if(a){if(o&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[d,f]=_("args",n,t,e);return[s.fused.matMul({a:_("a",n,t,e),b:_("b",n,t,e),transposeA:_("transposeA",n,t,e),transposeB:_("transposeB",n,t,e),bias:d,activation:i,preluActivationWeights:f,leakyreluAlpha:h})];case"MatrixBandPart":return[s.linalg.bandPart(_("a",n,t,e),_("numLower",n,t,e),_("numUpper",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EG=(n,t,e,s=Bn)=>{switch(n.op){case"EuclideanNorm":return[s.euclideanNorm(_("x",n,t,e),_("axis",n,t,e),_("keepDims",n,t,e))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(_("x",n,t,e),_("mean",n,t,e),_("variance",n,t,e),_("offset",n,t,e),_("scale",n,t,e),_("epsilon",n,t,e))];case"FusedBatchNormV3":return[s.batchNorm(_("x",n,t,e),_("mean",n,t,e),_("variance",n,t,e),_("offset",n,t,e),_("scale",n,t,e),_("epsilon",n,t,e))];case"LRN":return[s.localResponseNormalization(_("x",n,t,e),_("radius",n,t,e),_("bias",n,t,e),_("alpha",n,t,e),_("beta",n,t,e))];case"Softmax":return[s.softmax(_("x",n,t,e))];case"LogSoftmax":return[s.logSoftmax(_("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RG=(n,t,e,s=Bn)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:i}=s.raggedGather(_("paramsNestedSplits",n,t,e),_("paramsDenseValues",n,t,e),_("indices",n,t,e),_("outputRaggedRank",n,t,e));return r.concat(i)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:i}=s.raggedRange(_("starts",n,t,e),_("limits",n,t,e),_("splits",n,t,e));return[r,i]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(_("shape",n,t,e),_("values",n,t,e),_("defaultValue",n,t,e),_("rowPartitionTensors",n,t,e),_("rowPartitionTypes",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IG=(n,t,e,s=Bn)=>{switch(n.op){case"Max":{const o=_("axis",n,t,e),u=_("keepDims",n,t,e);return[s.max(_("x",n,t,e),o,u)]}case"Mean":{const o=_("axis",n,t,e),u=_("keepDims",n,t,e);return[s.mean(_("x",n,t,e),o,u)]}case"Min":{const o=_("axis",n,t,e),u=_("keepDims",n,t,e);return[s.min(_("x",n,t,e),o,u)]}case"Sum":{const o=_("axis",n,t,e),u=_("keepDims",n,t,e);return[s.sum(_("x",n,t,e),o,u)]}case"All":{const o=_("axis",n,t,e),u=_("keepDims",n,t,e);return[s.all(_("x",n,t,e),o,u)]}case"Any":{const o=_("axis",n,t,e),u=_("keepDims",n,t,e);return[s.any(_("x",n,t,e),o,u)]}case"ArgMax":{const o=_("axis",n,t,e);return[s.argMax(_("x",n,t,e),o)]}case"ArgMin":{const o=_("axis",n,t,e);return[s.argMin(_("x",n,t,e),o)]}case"Prod":{const o=_("axis",n,t,e),u=_("keepDims",n,t,e);return[s.prod(_("x",n,t,e),o,u)]}case"Cumprod":{const o=_("axis",n,t,e),u=_("exclusive",n,t,e),h=_("reverse",n,t,e);return[s.cumprod(_("x",n,t,e),o,u,h)]}case"Cumsum":{const o=_("axis",n,t,e),u=_("exclusive",n,t,e),h=_("reverse",n,t,e);return[s.cumsum(_("x",n,t,e),o,u,h)]}case"Bincount":const r=_("x",n,t,e),i=_("weights",n,t,e),a=_("size",n,t,e);return[s.bincount(r,i,a)];case"DenseBincount":{const o=_("x",n,t,e),u=_("weights",n,t,e),h=_("size",n,t,e),d=_("binaryOutput",n,t,e);return[s.denseBincount(o,u,h,d)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AG=(n,t,e,s=Bn)=>{switch(n.op){case"ConcatV2":case"Concat":{const r=_("n",n,t,e),i=_("axis",n,t,e);let a=_("tensors",n,t,e);return a=a.slice(0,r),[s.concat(a,i)]}case"Gather":{const r=_("x",n,t,e),i=_("indices",n,t,e);return[s.gather(r,s.cast(i,"int32"),0)]}case"GatherV2":{const r=_("axis",n,t,e),i=_("batchDims",n,t,e),a=_("x",n,t,e),o=_("indices",n,t,e);return[s.gather(a,s.cast(o,"int32"),r,i)]}case"Reverse":{const r=_("dims",n,t,e),i=[];for(let o=0;o<r.length;o++)r[o]&&i.push(o);const a=_("x",n,t,e);return[s.reverse(a,i)]}case"ReverseV2":{const r=_("axis",n,t,e),i=_("x",n,t,e);return[s.reverse(i,r)]}case"Slice":{const r=_("begin",n,t,e),i=_("size",n,t,e);return[s.slice(_("x",n,t,e),r,i)]}case"StridedSlice":{const r=_("begin",n,t,e),i=_("end",n,t,e),a=_("strides",n,t,e),o=_("beginMask",n,t,e),u=_("endMask",n,t,e),h=_("ellipsisMask",n,t,e),d=_("newAxisMask",n,t,e),f=_("shrinkAxisMask",n,t,e),m=_("x",n,t,e);return[s.stridedSlice(m,r,i,a,o,u,h,d,f)]}case"Pack":return Yt(()=>{const r=_("axis",n,t,e),i=_("tensors",n,t,e),a=i[0].shape,o=s.squeeze(i[0]).shape,u=i.map(h=>{const d=Ee(h.shape,a);if(!d&&!Ee(s.squeeze(h).shape,o))throw new Error("the input tensors shape does not match");return d?h:s.reshape(h,a)});return[s.stack(u,r)]});case"Unpack":{const r=_("axis",n,t,e),i=_("tensor",n,t,e);return s.unstack(i,r)}case"Tile":{const r=_("reps",n,t,e);return[s.tile(_("x",n,t,e),r)]}case"Split":case"SplitV":{const r=_("axis",n,t,e),i=_("numOrSizeSplits",n,t,e),a=_("x",n,t,e);return s.split(a,i,r)}case"ScatterNd":{const r=_("indices",n,t,e),i=_("values",n,t,e),a=_("shape",n,t,e);return[s.scatterND(r,i,a)]}case"GatherNd":{const r=_("x",n,t,e),i=_("indices",n,t,e);return[s.gatherND(r,i)]}case"SparseToDense":{const r=_("sparseIndices",n,t,e),i=_("outputShape",n,t,e),a=_("sparseValues",n,t,e),o=_("defaultValue",n,t,e);return[s.sparseToDense(r,a,i,a.dtype===o.dtype?o:s.cast(o,a.dtype))]}case"TensorScatterUpdate":{const r=_("indices",n,t,e),i=_("values",n,t,e),a=_("tensor",n,t,e);return[s.tensorScatterUpdate(a,r,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DG=(n,t,e,s=Bn)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:i,emptyRowIndicator:a,reverseIndexMap:o}=s.sparse.sparseFillEmptyRows(_("indices",n,t,e),_("values",n,t,e),_("denseShape",n,t,e),_("defaultValue",n,t,e));return[r,i,a,o]}case"SparseReshape":{const{outputIndices:r,outputShape:i}=s.sparse.sparseReshape(_("inputIndices",n,t,e),_("inputShape",n,t,e),_("newShape",n,t,e));return[r,i]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(_("data",n,t,e),_("indices",n,t,e),_("segmentIds",n,t,e))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(_("data",n,t,e),_("indices",n,t,e),_("segmentIds",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OG=(n,t,e,s=Bn)=>{switch(n.op){case"FFT":return[s.fft(_("x",n,t,e))];case"IFFT":return[s.ifft(_("x",n,t,e))];case"RFFT":return[s.rfft(_("x",n,t,e))];case"IRFFT":return[s.irfft(_("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PG=(n,t,e,s=Bn)=>{switch(n.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(_("input",n,t,e),_("pattern",n,t,e),_("rewrite",n,t,e),_("replaceGlobal",n,t,e))];case"StringNGrams":{const{nGrams:r,nGramsSplits:i}=s.string.stringNGrams(_("data",n,t,e),_("dataSplits",n,t,e),_("separator",n,t,e),_("nGramWidths",n,t,e),_("leftPad",n,t,e),_("rightPad",n,t,e),_("padWidth",n,t,e),_("preserveShortSequences",n,t,e));return[r,i]}case"StringSplit":{const{indices:r,values:i,shape:a}=s.string.stringSplit(_("input",n,t,e),_("delimiter",n,t,e),_("skipEmpty",n,t,e));return[r,i,a]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(_("input",n,t,e),_("numBuckets",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FG=(n,t,e,s=Bn)=>{switch(n.op){case"Cast":return[s.cast(_("x",n,t,e),_("dtype",n,t,e))];case"ExpandDims":{const r=_("axis",n,t,e);return[s.expandDims(_("x",n,t,e),r)]}case"Squeeze":{const r=_("axis",n,t,e);return[s.squeeze(_("x",n,t,e),r)]}case"Reshape":return[s.reshape(_("x",n,t,e),_("shape",n,t,e))];case"EnsureShape":return[s.ensureShape(_("x",n,t,e),_("shape",n,t,e))];case"MirrorPad":return[s.mirrorPad(_("x",n,t,e),_("padding",n,t,e),_("mode",n,t,e))];case"PadV2":case"Pad":return[s.pad(_("x",n,t,e),_("padding",n,t,e),_("constantValue",n,t,e))];case"SpaceToBatchND":{const r=_("blockShape",n,t,e),i=_("paddings",n,t,e);return[s.spaceToBatchND(_("x",n,t,e),r,i)]}case"BatchToSpaceND":{const r=_("blockShape",n,t,e),i=_("crops",n,t,e);return[s.batchToSpaceND(_("x",n,t,e),r,i)]}case"DepthToSpace":{const r=_("blockSize",n,t,e),i=_("dataFormat",n,t,e).toUpperCase();return[s.depthToSpace(_("x",n,t,e),r,i)]}case"BroadcastTo":return[s.broadcastTo(_("x",n,t,e),_("shape",n,t,e))];case"BroadcastArgs":return[s.broadcastArgs(_("s0",n,t,e),_("s1",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q$(n,t,e,s,r=Yt){const i=((a,o,u)=>{switch(a.category){case"arithmetic":return r(()=>hG(a,o,u));case"basic_math":return r(()=>dG(a,o,u));case"control":return xG(a,o,u);case"convolution":return r(()=>bG(a,o,u));case"creation":return r(()=>vG(a,o,u));case"dynamic":return wG(a,o,u);case"evaluation":return r(()=>SG(a,o,u));case"image":return r(()=>kG(a,o,u));case"graph":return r(()=>CG(a,o,u));case"logical":return r(()=>_G(a,o,u));case"matrices":return r(()=>NG(a,o,u));case"normalization":return r(()=>EG(a,o,u));case"ragged":return r(()=>RG(a,o,u));case"reduction":return r(()=>IG(a,o,u));case"slice_join":return r(()=>AG(a,o,u));case"sparse":return r(()=>DG(a,o,u));case"spectral":return r(()=>OG(a,o,u));case"string":return r(()=>PG(a,o,u));case"transformation":return r(()=>FG(a,o,u));case"hash_table":return TG(a,o,u,s);case"custom":const h=hR(a.op);if(h&&h.customExecutor)return h.customExecutor(new cG(a,o,u));throw TypeError(`Custom op ${a.op} is not registered.`);default:throw TypeError(`Unknown op '${a.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,t,e);return dl(i)?i.then(a=>[].concat(a)):[].concat(i)}class K${constructor(t={},e={},s={},r={},i){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=s,this.functionMap=r,this.parseNodeNameCache=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const s=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(s))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>e.id===0&&e.iterationId===0?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y$(n,t,e,s){const r=new Set,i=[];let a=null,o=null;const u=new Set,h=new Set(Object.keys(n).map(m=>Ws(m)[0]));s=s||[];const d=new Set(s.map(m=>Ws(m.name)[0])),f=[...t];for(;f.length>0;){const m=f.pop();if((tl(m)||GG(m)||HG(m))&&a==null&&(a=m,o=a.children.map(y=>y.name).filter(y=>r.has(y))),r.add(m.name),e[m.name]==null&&!h.has(m.name)&&!d.has(m.name)){if(m.inputs.length===0){i.push(m.name);continue}m.inputs.forEach(y=>{u.has(y.name)||(u.add(y.name),f.push(y))})}}return{inputs:n,outputs:t,usedNodes:r,missingInputs:i,dynamicNode:a,syncInputs:o}}function LG(n,t){const{usedNodes:e,inputs:s}=t,r=Object.keys(s).map(S=>Ws(S)[0]).map(S=>n.nodes[S]),i=n.initNodes||[],a=S=>e.has(typeof S=="string"?S:S.name);function o(S){return[...new Map(S.map(C=>[C.name,C])).values()]}const u=o([...r,...n.weights,...i]).filter(a),h=o([...u,...Object.values(n.nodes)]).filter(a),d=new Map(h.map(S=>[S.name,S])),f={};for(const S of h){f[S.name]=f[S.name]||0;for(const C of S.children)a(C)||(f[C.name]=Number.POSITIVE_INFINITY),f[C.name]=(f[C.name]||0)+1}const m=Object.entries(f).filter(([,S])=>S===0).map(([S])=>S),y=[...m];for(;m.length>0;){const S=m.pop(),C=d.get(S);for(const k of C.children.filter(a))--f[k.name]===0&&(y.push(k.name),m.push(k.name))}const x=y.map(S=>d.get(S)),w=MG(x,u);return zG(w,u),w}function MG(n,t){const e=new Map(n.map(a=>[a.name,a])),s=t.map(a=>a.name),r=new Set(s);for(;s.length>0;){const a=s.pop(),o=e.get(a);for(const u of o.children)!e.has(u.name)||r.has(u.name)||(r.add(u.name),s.push(u.name))}return n.filter(a=>r.has(a.name))}class Zf extends Error{constructor(t){super(`NodesExecutionOrderError: ${t}`)}}function zG(n,t){const e=new Map(n.map((o,u)=>[o.name,u])),s=new Set(t.map(o=>o.name)),r=o=>s.has(typeof o=="string"?o:o.name),i=new Set(n.map(o=>o.name)),a=o=>i.has(typeof o=="string"?o:o.name);for(const o of n){for(const u of o.children.filter(a)){if(!e.has(u.name))throw new Zf(`Child ${u.name} of node ${o.name} is unreachable.`);if(e.get(o.name)>e.get(u.name))throw new Zf(`Node ${o.name} is scheduled to run after its child ${u.name}.`)}if(!r(o))for(const u of o.inputs){if(!e.has(u.name))throw new Zf(`Input ${u.name} of node ${o.name} is unreachable.`);if(e.get(u.name)>e.get(o.name))throw new Zf(`Node ${o.name} is scheduled to run before its input ${u.name}.`)}}}function BG(n){const t=new Map(n.map((o,u)=>[o.name,u])),e=Number.MAX_SAFE_INTEGER,s=n.map((o,u)=>tl(o)?e:u),r=o=>{const u=s[t.get(o.name)];return u??-1},i=n.map((o,u)=>o.children.map(r).reduce((h,d)=>Math.max(h,d),s[u])),a=new Map;for(let o=0;o<n.length;++o){const u=i[o];if(u===e)continue;const h=n[o],d=n[u];a.has(d.name)||a.set(d.name,[]),a.get(d.name).push(h)}return a}const VG=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),UG=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),WG=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function tl(n){return VG.has(n.op)}function GG(n){return UG.has(n.op)}function HG(n){return WG.has(n.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qp{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map(s=>t[s].map(r=>r.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(s=>{this._functionExecutorMap[s]=new Qp(t.functions[s],this)})}getCompilationKey(t,e){const s=t.map(i=>i.name).sort(),r=e.map(i=>i.name).sort();return s.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(t,e){const s=Y$(t,e,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:i,syncInputs:a}=s;if(i!=null)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){const h=e.map(f=>f.name),d=Object.keys(t);throw new Error(`Cannot compute the outputs [${h}] from the provided inputs [${d}]. Missing the following inputs: [${r}]`)}const o=LG(this.graph,s),u=BG(o);return{orderedNodes:o,nodeLiveUntilMap:u}}cloneAndKeepTensor(t){if(t==null)return null;const e=t.clone();return gi(e),e}cloneTensorList(t){return t?t.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([e,s])=>[e,this.cloneTensorList(s)]))}execute(t,e){this.disposeIntermediateTensors(),t=this.mapInputs(t);const s=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const r=s.map(m=>this.graph.nodes[Ws(m)[0]]),i=e.map(m=>Ws(m)[0]),a=new Set(i);let o=i.map(m=>this.graph.nodes[m]);o.length===0&&(o=this._outputs);const u=this.getCompilationKey(r,o);let h=this.compiledMap.get(u);h==null&&(h=this.compile(t,o),this.compiledMap.set(u,h));try{this.keepIntermediateTensors=tt().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}const d={},f={};return Yt(()=>{const m=new K$(this.weightMap,d,f,this.functionExecutorMap,this.parseNodeNameCache),y=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(C=>{const[k,E]=Ws(C,m),R=[];R[E]=t[C],y[k]=R,this.keepIntermediateTensors&&(this.clonedTensorsMap[k]=this.cloneTensorList(R))});const x=this.getFrozenTensorIds(y),{orderedNodes:w,nodeLiveUntilMap:S}=h;for(const C of w){if(y[C.name])continue;const k=q$(C,y,m,this._resourceManager);if(dl(k))throw new Error(`The execution of the op '${C.op}' returned a promise. Please use model.executeAsync() instead.`);y[C.name]=k,this.keepIntermediateTensors&&(this.clonedTensorsMap[C.name]=this.cloneTensorList(k)),this.checkTensorForDisposalWithNodeLiveUntilInfo(C,y,m,x,a,S.get(C.name))}return this.parent==null&&m.dispose(x),e.map(C=>Mn(C,y,m))})}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map(s=>t[s]).map(s=>s.map(r=>r.id)));return new Set(e)}checkTensorForDisposal(t,e,s,r,i,a,o){if(!(tl(e)||a.has(t))){for(const u of s[t])u!=null&&(o[u.id]=(o[u.id]||0)+e.children.length);for(const u of e.inputs){if(tl(u))continue;const h=W$(u.name,s,r);if(h!=null)for(const d of h){if(!d||d.kept||i.has(d.id))continue;const f=o[d.id];f===1?(d.dispose(),delete o[d.id]):f!=null&&o[d.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,e,s,r,i,a){function o(u){return tl(u)||i.has(u.name)}if(!(tl(t)||a==null))for(const u of a){if(o(u))continue;const h=W$(u.name,e,s);for(const d of h)!d||d.kept||r.has(d.id)||d.dispose()}}async executeAsync(t,e){return this._executeAsync(t,e)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(const e of t)e&&!e.isDisposed&&e.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,e,s=!1,r={},i={}){this.disposeIntermediateTensors(),s||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e));try{this.keepIntermediateTensors=tt().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}const a=new K$(this.weightMap,r,i,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const o=await this.executeWithControlFlow(t,a,e,s),u=e.map(m=>Mn(m,o,a)),h=u.map(m=>m.id),d=Object.keys(t).map(m=>t[m].id),f=new Set([...h,...d,...this.weightIds]);return Object.values(o).forEach(m=>{m.forEach(y=>{y&&!y.isDisposed&&!f.has(y.id)&&y.dispose()})}),this.parent==null&&a.dispose(f),u}async executeFunctionAsync(t,e,s){const r=t.reduce((i,a,o)=>(i[this.inputs[o].name]=a,i),{});return this._executeAsync(r,this.outputNodes,!0,e,s)}async executeWithControlFlow(t,e,s,r){const i=Object.keys(t),a=i.map(R=>this.graph.nodes[Ws(R)[0]]),o=s.map(R=>Ws(R)[0]),u=new Set(o);let h=o.map(R=>this.graph.nodes[R]);h.length===0&&(h=this._outputs);const{usedNodes:d,missingInputs:f,dynamicNode:m,syncInputs:y}=Y$(t,h,this.weightMap,this._initNodes),x=[...a,...this.graph.weights,...this._initNodes||[]].map(R=>({node:R,contexts:e.currentContext})),w=Object.assign({},this.weightMap);Object.keys(t).forEach(R=>{const[A,L]=Ws(R),V=[];V[L]=t[R],w[A]=V});const S={},C=this.getFrozenTensorIds(w),k={};for(;x.length>0;){const R=this.processStack(a,x,e,w,k,C,u,S,d);await Promise.all(R)}m==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const E=h.filter(R=>!tl(R)&&!Mn(R.name,w,e)).map(R=>R.name);if(E.length>0){let R="";throw m!=null&&(R=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${y}]`),new Error(`Cannot compute the outputs [${E}] from the provided inputs [${i}]. Consider providing the following inputs: [${f}]. ${R}`)}return w}processStack(t,e,s,r,i,a,o,u,h){const d=[];for(;e.length>0;){const f=e.pop();s.currentContext=f.contexts;let m="";if(f.node.op==="Enter"&&_("isConstant",f.node,r,s)&&([m]=qi(f.node.name,s)),r[f.node.name]==null){const y=q$(f.node,r,s,this._resourceManager);m||([m]=qi(f.node.name,s));const x=s.currentContext;dl(y)?d.push(y.then(w=>(r[m]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(w)),s.currentContext=x,this.checkTensorForDisposal(m,f.node,r,s,a,o,u),this.processChildNodes(f.node,e,s,r,i,h),w))):(r[m]=y,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(y)),this.checkTensorForDisposal(m,f.node,r,s,a,o,u),this.processChildNodes(f.node,e,s,r,i,h))}else this.processChildNodes(f.node,e,s,r,i,h)}return d}processChildNodes(t,e,s,r,i,a){t.children.forEach(o=>{const[u]=qi(o.name,s);i[u]||!a.has(o.name)||(o.op==="Merge"?o.inputNames.some(h=>!!Mn(h,r,s))&&(i[u]=!0,e.push({contexts:s.currentContext,node:o})):o.inputNames.every(h=>!!Mn(h,r,s))&&(i[u]=!0,e.push({contexts:s.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{const s=t[e],[r]=Ws(e),i=this.graph.nodes[r];if(i.attrParams.shape&&i.attrParams.shape.value){const a=i.attrParams.shape.value,o=a.length===s.shape.length&&s.shape.every((u,h)=>a[h]===-1||a[h]===u);M(o,()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${a}], but was [${s.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&M(s.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(t){var e,s;const r={};for(const i in t){const a=(s=(e=this._signature)===null||e===void 0?void 0:e.inputs)===null||s===void 0?void 0:s[i];a!=null?r[a.name]=t[i]:r[i]=t[i]}return r}checkInputs(t){const e=Object.keys(t).filter(s=>{const[r]=Ws(s);return this.graph.nodes[r]==null});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>{var s,r;const i=(r=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||r===void 0?void 0:r[e];return i!=null?i.name:e},{})}checkOutputs(t){t.forEach(e=>{const[s]=Ws(e);if(!this.graph.nodes[s])throw new Error(`The output '${e}' is not found in the graph`)})}}class jG{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XG="?tfjs-format=file",qG="model.json";class KG{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,e={},s=ME){this.modelUrl=t,this.loadOptions=e,this.version="n/a",this.io=s,e==null&&(this.loadOptions={}),this.resourceManager=new jG}findIOHandler(){const t=this.modelUrl;if(t.load!=null)this.handler=t;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const e=this.io.getLoadHandlers(t,this.loadOptions);if(e.length===0)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return dl(t)?t.then(e=>e.getWeightStream==null?this.loadSync(e):this.loadStreaming(e)):this.loadSync(t)}loadSync(t){const e=this.io.decodeWeights(t.weightData,t.weightSpecs);return this.loadWithWeightMap(t,e)}async loadStreaming(t){if(t.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const e=await DN(t.getWeightStream(),t.weightSpecs);return this.loadWithWeightMap(t,e)}loadWithWeightMap(t,e){this.artifacts=t;const s=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const i=this.artifacts.userDefinedMetadata;i.signature!=null&&(r=i.signature),i.structuredOutputKeys!=null&&(this.structuredOutputKeys=i.structuredOutputKeys)}if(this.signature=r,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new Qp(G$.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(e),this.executor.resourceManager=this.resourceManager,t.modelInitializer!=null&&t.modelInitializer.node!=null){const i=G$.Instance.transformGraph(t.modelInitializer);this.initializer=new Qp(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}async save(t,e){if(typeof t=="string"){const s=this.io.getSaveHandlers(t);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${t}'`);t=s[0]}if(t.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}addStructuredOutputNames(t){if(this.structuredOutputKeys){const e=t instanceof un?[t]:t,s={};return e.forEach((r,i)=>s[this.structuredOutputKeys[i]]=r),s}return t}predict(t,e){const s=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(t,e){const s=await this.executeAsync(t,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(t){var e;if(!(t instanceof un)&&!Array.isArray(t)){const i=(e=this.signature)===null||e===void 0?void 0:e.inputs;if(i!=null)for(const a in i){const o=i[a];o.resourceId!=null&&(t[a]=this.resourceIdToCapturedInput[o.resourceId])}return t}t=Array.isArray(t)?t:[t];const s=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${t.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((i,a)=>{var o,u,h;const d=(h=(u=(o=this.signature)===null||o===void 0?void 0:o.inputs)===null||u===void 0?void 0:u[a])===null||h===void 0?void 0:h.resourceId;return d!=null?i[a]=this.resourceIdToCapturedInput[d]:i[a]=t[r++],i},{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){const e=this.initializerSignature.outputs,s=Object.keys(e);for(let r=0;r<s.length;r++){const i=s[r],a=e[i];this.resourceIdToCapturedInput[a.resourceId]=t[r]}}}execute(t,e){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const s=this.executor.execute(t,e);return s.length>1?s:s[0]}async executeAsync(t,e){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const s=await this.executor.executeAsync(t,e);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,s)=>(e[s]=[t[s]],e),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Ne(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Gu(n,t={},e=ME){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof n=="string"&&(n=YG(n));const s=new KG(n,t,e);return await s.load(),s}function YG(n){return n.endsWith("/")||(n=n+"/"),`${n}${qG}${XG}`}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gr=tt();gr.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);gr.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);gr.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);gr.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0);gr.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);gr.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);gr.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);gr.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);gr.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);gr.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1);gr.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);gr.registerFlag("WEBGPU_PRINT_SHADER",()=>"");gr.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QG{constructor(t){t&&(this.vendor=t.vendor,this.architecture=t.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZG{constructor(t){this.device=t,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(t,e,s=!1,r=!0){let i;const a=Q$(t,e);return r?(this.freeBuffers.has(a)||this.freeBuffers.set(a,[]),this.freeBuffers.get(a).length>0?(i=this.freeBuffers.get(a).pop(),this.numFreeBuffers--):(i=this.device.createBuffer({size:t,usage:e,mappedAtCreation:s}),this.numBytesAllocated+=t)):(i=this.device.createBuffer({size:t,usage:e,mappedAtCreation:s}),this.numBytesAllocated+=t),this.usedBuffers.has(a)||this.usedBuffers.set(a,[]),this.usedBuffers.get(a).push(i),this.numUsedBuffers++,this.numBytesUsed+=t,i}releaseBuffer(t,e=!0){if(this.freeBuffers.size===0)return;const s=t.size,r=t.usage,i=Q$(s,r),a=this.usedBuffers.get(i),o=a.indexOf(t);if(o<0)throw new Error("Cannot find the buffer in buffer manager");a[o]=a[a.length-1],a.pop(),this.numUsedBuffers--,this.numBytesUsed-=s,e?(this.freeBuffers.get(i).push(t),this.numFreeBuffers++):(t.destroy(),this.numBytesAllocated-=s)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((t,e)=>{t.forEach(s=>{s.destroy()})}),this.usedBuffers.forEach((t,e)=>{t.forEach(s=>{s.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function Q$(n,t){return`${n}_${t}`}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let JG=class{constructor(t){this.device=t,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(t,e,s,r){const i=J$(s),a=t*e*i,o=Z$(t,e,s,r);if(this.freeTextures.has(o)||this.freeTextures.set(o,[]),this.usedTextures.has(o)||this.usedTextures.set(o,[]),this.numBytesUsed+=a,this.numUsedTextures++,this.freeTextures.get(o).length>0){this.numFreeTextures--;const h=this.freeTextures.get(o).shift();return this.usedTextures.get(o).push(h),h}this.numBytesAllocated+=a;const u=this.device.createTexture({size:[t,e],format:s,usage:r});return this.usedTextures.get(o).push(u),u}releaseTexture(t){if(this.freeTextures.size===0)return;const e=t.width,s=t.height,r=t.format,i=t.usage,a=Z$(e,s,r,i);this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.freeTextures.get(a).push(t),this.numFreeTextures++,this.numUsedTextures--;const o=this.usedTextures.get(a),u=o.indexOf(t);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");o.splice(u,1);const h=J$(r),d=e*s*h;this.numBytesUsed-=d}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((t,e)=>{t.forEach(s=>{s.destroy()})}),this.usedTextures.forEach((t,e)=>{t.forEach(s=>{s.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}};function Z$(n,t,e,s){return`${n}_${t}_${e}_${s}`}function J$(n){if(n==="rgba8unorm")return 16;throw new Error(`${n} is not supported!`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tH(n,t){if(Math.max(...n)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const e=n.length,s="xyzwuv",r=n.map(a=>`${t}.${s[a]}`),i=new Array(e-1);i[e-2]=r[e-1];for(let a=e-3;a>=0;--a)i[a]=`(${i[a+1]} * ${r[a+1]})`;return i}const lo=(n,t,e)=>e==="int32"?`atomicAdd(${n}, bitcast<i32>(${t}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${t});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${n}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Hu;(function(n){n[n.FROM_PIXELS=0]="FROM_PIXELS",n[n.DRAW=1]="DRAW"})(Hu||(Hu={}));const eH=(n,t,e,s,r)=>{const i={dtype:s.dtype,shape:s.shape},a=sH(e,i,t),o=n.createShaderModule({code:a,label:t.constructor.name});let u=tt().get("WEBGPU_PRINT_SHADER");if(u!==""){u=u.toLowerCase();const h=u.split(",");(u==="all"||h.some(d=>t.shaderKey.toLowerCase().includes(d)))&&(console.group(t.shaderKey),console.debug(a),console.groupEnd())}return r?n.createComputePipelineAsync({compute:{module:o,entryPoint:"_start"},label:t.constructor.name,layout:"auto"}):n.createComputePipeline({compute:{module:o,entryPoint:"_start"},label:t.constructor.name,layout:"auto"})},ee=(n,t="f32")=>{switch(n){case 1:return`${t}`;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${n}-component ${t} is not supported.`)}};function mn(n){if(n<=1)return"i32";if(n===2)return"vec2<i32>";if(n===3)return"vec3<i32>";if(n===4)return"vec4<i32>";if(n===5)return"vec5";if(n===6)return"vec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Ji(n){if(n===0)return"x";if(n===1)return"y";if(n===2)return"z";if(n===3)return"w";if(n===4)return"u";if(n===5)return"v";throw Error(`Index ${n} is not yet supported`)}function Tt(...n){let t;switch(n.length){case 0:t=`
        fn main()
      `;break;case 1:t=`
        fn main(${n[0]} : i32)
      `;break;default:throw Error("Unreachable")}return t}function tT(n,t){let e;return e=`
     ${nH(t)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${n?"main(getGlobalIndex());":"main();"};
      }
    `,e}function nH(n){return`
  @compute @workgroup_size(${n.workgroupSize[0]}, ${n.workgroupSize[1]}, ${n.workgroupSize[2]})
`}function sH(n,t,e){const s=[],r=e.workgroupSize[0]*e.workgroupSize[1]*e.workgroupSize[2];if(e.outputComponent=e.outputComponent?e.outputComponent:1,s.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${pR(e)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${r}u +
                localIndex);
        `}
      }
    `),e.pixelsOpType!=null){const x=e.pixelsOpType===Hu.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${el(t.dtype,e.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${el(n[0].dtype,e.outputComponent)}>;`,w=t.shape.length===3?"vec2<i32>":"i32";s.push(`
        struct Uniform {
          outShapeStrides : ${w},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${x}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const S=nT(e);return[eT,s.join(`
`),Ep(t.shape),e.getUserCode(),tT(S,e)].join(`
`)}let i,a,o="struct Uniforms { NAN : f32, INFINITY : f32, ";e.variableNames.forEach((x,w)=>{const S=mn(n[w].shape.length);o+=`${x.charAt(0).toLowerCase()+x.slice(1)}Shape : ${S}, `,i=n[w].shape.length-1,a=mn(i),o+=`${x.charAt(0).toLowerCase()+x.slice(1)}ShapeStrides: ${a}, `});const u=mn(t.shape.length);o+=`outShape : ${u}, `,i=t.shape.length-1,a=mn(i),o+=`
         outShapeStrides: ${a}, `,e.size&&(o+="size : i32, "),e.uniforms&&(o+=e.uniforms),o+="};",o=dH(o),s.push(o),e.atomic?s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${el(t.dtype,e.outputComponent)}>;
    `),e.variableNames.forEach((x,w)=>{s.push(`
      @group(0) @binding(${1+w}) var<storage, read> ${x}: array<${e.variableComponents?el(n[w].dtype,e.variableComponents[w]):el(n[w].dtype,e.outputComponent)}>;
        `)}),o!==""&&s.push(`
      @group(0) @binding(${1+e.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const h=uH(t.shape,e.dispatchLayout),d=[eT,s.join(`
`)+iH,Ep(t.shape),h,cH(t.shape.length)];e.atomic||d.push(hH(t.shape,t.dtype,e.outputComponent)),e.variableNames.forEach((x,w)=>{d.push(`${Ep(n[w].shape,x)}`)});const f=n.map((x,w)=>lH(x,t.shape,e.variableComponents?e.variableComponents[w]:e.outputComponent,e.dispatchLayout.x.length===t.shape.length)).join(`
`);d.push(f),d.push(e.getUserCode());const m=nT(e);return d.push(tT(m,e)),d.join(`
`)}function rH(n,t,e){let s=n.shaderKey;if(n.pixelsOpType!=null)return s;const r=[],i=[];t.forEach(d=>{r.push(d.shape),i.push(d.dtype)}),r.push(e.shape),i.push(e.dtype);const a=t.map(d=>Wu(d.shape,e.shape)),o=t.map(d=>Ee(d.shape,e.shape)).join("_"),u=a.map(d=>d.join("_")).join(";"),h=pR(n)?"flatDispatch":"";return s+="_"+(n.workgroupSize?n.workgroupSize.join(","):"")+r.map(d=>d.length).join(",")+i.join(",")+n.variableNames.join(",")+u+o+h,s}const eT=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,iH=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function Ep(n,t=""){const e=n.length,s=t!==""?`get${t.charAt(0).toUpperCase()+t.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",r=t!==""?`${t.charAt(0).toLowerCase()+t.slice(1)}ShapeStrides`:"outShapeStrides";if(e<=1)return`fn ${s}(index : i32) -> i32 { return index; }`;const i=cn(n),a=mn(e),o=[];for(let h=0;h<e;h++)o.push(`d${h}`);if(i.length===1)return`    fn ${s}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${r}; let d1 = index - d0 * uniforms.${r};
      return vec2<i32>(d0, d1);
    }`;let u;return u="var index2 = index;"+i.map((h,d)=>{const f=`let ${o[d]} = index2 / uniforms.${r}.${Ji(d)}`,m=d===i.length-1?`let ${o[d+1]} = index2 - ${o[d]} * uniforms.${r}.${Ji(d)}`:`index2 = index2 - ${o[d]} * uniforms.${r}.${Ji(d)}`;return`${f}; ${m};`}).join(""),`
    fn ${s}(index : i32) -> ${a} {
      ${u}
      return ${a}(${o.join(",")});
    }
  `}function aH(n,t){const e=n.name,s=n.shape.length,r=mn(s),i="get"+e.charAt(0).toUpperCase()+e.slice(1),a=["d0","d1","d2","d3","d4","d5"].slice(0,s),o=a.map(d=>`${d} : i32`).join(", ");if(s<1)return`
      fn ${i}() -> ${ee(t)} {
        return ${ee(t)}(${e}[0]);
      }
    `;const u=`uniforms.${e.charAt(0).toLowerCase()+e.slice(1)}Shape`;let h=`${s}D`;return s===0&&(h="1D"),`
    fn ${i}(${o}) -> ${ee(t)} {
      return ${ee(t)}(${e}[getIndexFromCoords${h}(${r}(${a.join(",")}),
        ${u})${t===1?"":` / ${t}`}]);
    }
   `}function oH(n,t,e,s){const r=n.name,i=r.charAt(0).toUpperCase()+r.slice(1),a="get"+i+"ByOutput",o=n.shape.length,u=t.length,h=mn(u);if(Ee(n.shape,t)&&s)return`
    fn ${a}Index(globalIndex : i32) -> ${ee(e)} {
      return ${ee(e)}(${r}[globalIndex]);
    }

    fn ${a}Coords(coords : ${h}) -> ${ee(e)} {
      return ${ee(e)}(${r}[${u>1?"getOutputIndexFromCoords(coords)":"coords"}${e===1?"":` / ${e}`}]);
    }
    `;const d=Wu(n.shape,t),f=u-o;let m="";if(o===0)return`
    fn ${a}Index(globalIndex : i32) -> ${ee(e)}{
      return get${i}();
    }

    fn ${a}Coords(coords : ${h}) -> ${ee(e)}{
      return get${i}();
    }
  `;u<2&&d.length>=1?m="coords = 0;":m=d.map(S=>`coords.${Ji(S+f)} = 0;`).join(`
`);let y="";if(u<2&&o>0)y="coords";else if(u>1){const S=mn(o),C=n.shape.map((k,E)=>`coords.${Ji(E+f)}`).join(", ");y=`${S}(${C})`}else y="coords";const x=`uniforms.${r.charAt(0).toLowerCase()+r.slice(1)}Shape`,w=`${o}D`;return`
  fn ${a}Index(globalIndex : i32) -> ${ee(e)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${m}
    return ${ee(e)}(${r}[getIndexFromCoords${w}(${y}, ${x})${e===1?"":` / ${e}`}]);
  }

  fn ${a}Coords(coordsIn : ${h}) -> ${ee(e)} {
    var coords = coordsIn;
    ${m}
    return ${ee(e)}(${r}[getIndexFromCoords${w}(${y}, ${x})${e===1?"":` / ${e}`}]);
  }
`}function lH(n,t,e,s){let r=aH(n,e);return n.shape.length<=t.length&&(r+=oH(n,t,e,s)),r}function uH(n,t){const{x:e,y:s=[],z:r=[]}=t,i=n.length,a=e.length+s.length+r.length;if(a!==i)return"";if(e.length===i)return`fn getOutputCoords() -> ${mn(i)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let o="";const u=[e,s,r];for(let m=0;m<u.length;m++){const y=u[m];if(y.length!==0)if(y.length===1)o+=`let d${y[0]} = i32(globalId[${m}]);`;else{const x=tH(y,"uniforms.outShape");o+=`var index${m} = i32(globalId[${m}]);`;for(let w=0;w<x.length;w++)o+=`let d${y[w]} = index${m} / ${x[w]};`,w===x.length-1?o+=`let d${y[w+1]} = index${m} - d${y[w]} * ${x[w]};`:o+=`index${m} = index${m} - d${y[w]} * ${x[w]};`}}const h=[];for(let m=0;m<a;m++)h.push(`d${m}`);const d=mn(a);let f=`fn getOutputCoords() -> ${d} {
  ${o}
`;return h.length===0?f+=`return ${d}(0); }`:f+=`return ${d}(${h.join(",")}); }`,f}function cH(n){let t="";switch(n){case 0:case 1:t+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:t+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:t+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:t+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:t+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:t+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:M(!1,()=>`Unsupported ${n}D shape`);break}return t}function pR(n){return n.dispatch[1]===1&&n.dispatch[2]===1}function el(n,t=1){if(n==="float32")return ee(t,"f32");if(n==="int32"||n==="bool")return ee(t,"i32");throw new Error(`type ${n} is not supported.`)}function hH(n,t,e){const s=n.length,r=el(t,e);let i=`fn setOutputAtIndex(flatIndex : i32, value : ${ee(e)}) {
      result[flatIndex] = ${r}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${ee(e,"i32")}) {
      result[flatIndex] = ${r}(value);
    }
    `;if(s>=2){const a=["d0","d1","d2","d3","d4","d5"].slice(0,s),o=mn(s);i+=`
      fn setOutputAtCoords(${a.map(u=>`${u} : i32`).join(", ")}, value : ${ee(e)}) {
        let flatIndex = getOutputIndexFromCoords(${o}(${a.join(", ")}));
        setOutputAtIndex(flatIndex${e===1?"":` / ${e}`}, value);
      }
      fn setOutputAtCoordsI32(${a.map(u=>`${u} : i32`).join(", ")}, value : ${ee(e,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${o}(${a.join(", ")}));
        setOutputAtIndexI32(flatIndex${e===1?"":` / ${e}`}, value);
      }
    `}return i}function dH(n){const t=/(\w+)\s*:\s*vec(5|6)/g;n=n.replace(t,s=>"@align(16) "+s);const e=/vec(5|6)\s*,\s*(\w+)/g;return n=n.replace(e,(s,r,i)=>`vec${r}, @align(16) ${i}`),n}function nT(n){return!(n.dispatchLayout.hasOwnProperty("y")&&n.dispatchLayout.y.length!==0||n.dispatchLayout.hasOwnProperty("z")&&n.dispatchLayout.z.length!==0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ul=n=>{let t=1;for(let e=0;e<n.length;e++)t*=n[e];return t};function kt(n,t,e=[1,1,1],s=[1,1,1]){const[r,i,a]=[Math.ceil(ul(n.x.map(o=>t[o]))/(e[0]*s[0])),n.y?Math.ceil(ul(n.y.map(o=>t[o]))/(e[1]*s[1])):1,n.z?Math.ceil(ul(n.z.map(o=>t[o]))/(e[2]*s[2])):1];return[r,i,a]}function fH(n,t,e,s=!1){const r=[8,8,1],i=[4,4,1];return s||(n<=8&&(i[1]=1),t<=16&&e<=16&&(r[0]=4)),{workgroupSize:r,elementsPerThread:i}}function mR(n,t,e=!1){if(e)return[8,8,1];const s=ul(n.x.map(i=>t[i])),r=ul(n.y.map(i=>t[i]));return s<=4?[4,16,1]:r<=4?[16,4,1]:[16,16,1]}function gR(n,t,e=!1){if(e)return[4,4,1];const s=ul(n.x.map(i=>t[i])),r=ul(n.y.map(i=>t[i]));return s<=4?[1,2,1]:r<=4?[2,1,1]:[2,2,1]}function At(n){return{x:n.map((t,e)=>e)}}function sT(n){if(n==="float32"||n==="int32"||n==="bool"||n==="string")return 4;if(n==="complex64")return 8;throw new Error(`Unknown dtype ${n}`)}function yR(){return!!(typeof globalThis<"u"&&globalThis.navigator&&globalThis.navigator.gpu)}function xR(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&M(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGPU backend.`)})}var pi;(function(n){n[n.MatMulReduceProgram=0]="MatMulReduceProgram",n[n.MatMulSplitKProgram=1]="MatMulSplitKProgram",n[n.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",n[n.MatMulPackedProgram=3]="MatMulPackedProgram",n[n.MatMulMax=4]="MatMulMax"})(pi||(pi={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pH=tt().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),mH=(n,t)=>{const e=n.limits.maxComputeWorkgroupsPerDimension,s=t.dispatchLayout,r=t.dispatch;if(r.every(a=>a<=e))return r;M(r[0]>e&&s.y===void 0&&s.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let i=Math.ceil(Math.sqrt(r[0]));return i>e?(i=Math.ceil(Math.cbrt(r[0])),M(i<=e,()=>"Total dispatch size exceeds WebGPU maximum."),[i,i,i]):[i,i,1]};class tc extends L0{nextDataId(){return tc.nextDataId++}constructor(t,e){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!yR())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=t,this.queue=t.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new QG(e),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new ZG(this.device),this.textureManager=new JG(this.device),this.tensorMap=new F_(this,Gs()),tt().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:t,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(t,e=!1){if(!this.tensorMap.has(t))return!0;const s=this.tensorMap.get(t);return e?s.refCount=0:s.refCount--,s.refCount>0?!1:(s.complexTensorInfos!=null&&(this.disposeData(s.complexTensorInfos.real.dataId),this.disposeData(s.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(t)?(this.tensorDataPendingDisposal.push(t),!0):(this.releaseResource(t),this.tensorMap.delete(t),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(t){const e=this.tensorMap.get(t);if(!(!e||!e.resource)){if(e.external){e.resource=null;return}e.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(e.resource):e.resource instanceof GPUTexture&&this.textureManager.releaseTexture(e.resource),e.resource=null}}refCount(t){return this.tensorMap.has(t)?this.tensorMap.get(t).refCount:0}incRef(t){const e=this.tensorMap.get(t);e.refCount++}decRef(t){if(this.tensorMap.has(t)){const e=this.tensorMap.get(t);e.refCount--}}write(t,e,s){if(s==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.tensorMap.set(r,{dtype:s,shape:e,values:t,refCount:1}),r}move(t,e,s,r,i){if(r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(t,{dtype:r,shape:s,values:e,refCount:i})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(t=>{this.releaseResource(t),this.tensorMap.delete(t)}),this.uniformPendingDisposal.forEach(t=>this.bufferManager.releaseBuffer(t)),this.stagingPendingDisposal.forEach(t=>this.bufferManager.releaseBuffer(t,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let t;try{t=await Promise.all(Object.values(this.pipelineCache))}catch(e){throw new Error(e.message)}Object.keys(this.pipelineCache).map((e,s)=>{this.pipelineCache[e]=t[s]})}async getBufferData(t){if(tt().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const e=t.size,s=this.bufferManager.acquireBuffer(e,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(t,0,s,0,e),this.submitQueue(),await s.mapAsync(GPUMapMode.READ);const r=s.getMappedRange().slice(0);return s.unmap(),s!=null&&this.bufferManager.releaseBuffer(s),tt().getBool("WEBGPU_USE_PROFILE_TOOL")&&(M(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),r}convertAndCacheOnCPU(t,e){const s=this.tensorMap.get(t);return s.values=e,s.values}readSync(t){const e=this.tensorMap.get(t),{values:s,complexTensorInfos:r}=e;if(s!=null||e.dtype==="string")return s;if(e.dtype==="complex64"){const w=this.readSync(r.real.dataId),S=this.readSync(r.imag.dataId),C=rx(rd(w,S).buffer,"float32");return this.convertAndCacheOnCPU(t,C),C}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const i=["opaque","premultiplied"],a=e.resource,o=a.size;M(o%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const u=o/4,h=new ArrayBuffer(o),d=256,f=256,m=i.map(w=>new OffscreenCanvas(d,f)),y=new OffscreenCanvas(d,f);this.endComputePassEncoder(),m.map((w,S)=>{const C=w.getContext("webgpu");return C.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:i[S]}),C.getCurrentTexture()}).map((w,S)=>{const C=d*4,k=(B,z,U)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:a,bytesPerRow:C,offset:U},{texture:w},{width:B,height:z}),this.submitQueue();const D=y.getContext("2d",{willReadFrequently:!0});D.clearRect(0,0,B,z),D.drawImage(m[S],0,0);const Y=D.getImageData(0,0,B,z).data,nt=i[S],dt=new Uint8ClampedArray(h,U,B*z*4);for(let at=0;at<dt.length;at+=4)if(nt==="premultiplied")dt[at+3]=Y[at+3];else{const K=Y[at];dt[at]=Y[at+2],dt[at+1]=Y[at+1],dt[at+2]=K}},E=Math.floor(u/(d*f));let R=d,A=f,L=0;for(let B=0;B<E;B++)k(R,A,L),L+=d*f*4;const V=u%(d*f);A=Math.floor(V/d),A>0&&(k(R,A,L),L+=A*(d*4)),R=V%d,R>0&&k(R,1,L)});const x=rx(h,e.dtype);return this.convertAndCacheOnCPU(t,x),x}async read(t){if(!this.tensorMap.has(t))throw new Error(`Tensor ${t} was not registered!`);const e=this.tensorMap.get(t),{values:s}=e;if(s!=null)return s;let r;if(e.dtype==="complex64"){const i=await Promise.all([this.read(e.complexTensorInfos.real.dataId),this.read(e.complexTensorInfos.imag.dataId)]),a=i[0],o=i[1];r=rd(a,o)}else{const i=await this.getBufferData(e.resource);r=rx(i,e.dtype)}return this.convertAndCacheOnCPU(t,r),r}copyBuffer(t){const e=t.size,s=t.usage,r=this.bufferManager.acquireBuffer(e,s);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(t,0,r,0,e),this.submitQueue(),r}createTensorFromGPUData(t,e,s){let r=t.buffer;if(s==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const i={id:this.nextDataId()};this.tensorMap.set(i,{dtype:s,shape:e,values:null,refCount:1,external:t.zeroCopy});const a=this.tensorMap.get(i),o=sT(a.dtype)*ht(a.shape);if(t.buffer.size<o)throw new Error(`GPUBuffer size(${t.buffer.size}) is smaller than tensor size(${o})!`);if((t.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return t.zeroCopy!==!0&&(r=this.copyBuffer(r)),a.resource=r,Gs().makeTensorFromDataId(i,e,s,this)}readToGPU(t){const e=this.tensorMap.get(t),{values:s,dtype:r,shape:i,resource:a}=e;if(r==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(a==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const o=a,u=o.size,h=o.usage,d=this.bufferManager.acquireBuffer(u,h);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(a,0,d,0,u),this.submitQueue();const f=this.makeTensorInfo(i,r),m=Gs().makeTensorFromTensorInfo(f),y=this.tensorMap.get(f.dataId);return y.resource=d,{tensorRef:m,buffer:d}}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const s=e.map(r=>ea(r));return Re(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Re(t.shape,t.dtype,e)}async time(t){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const e=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,t();const i=na(this.activeTimers.map(h=>h.query)).filter(h=>h!=null),a=na(this.activeTimers.map(h=>h.name)).filter(h=>h!=null);this.activeTimers=e,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},u=await Promise.all(i);return o.kernelMs=L_(u),o.getExtraProfileInfo=()=>u.map((h,d)=>({name:a[d],ms:h})).map(h=>`${h.name}: ${h.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,o}makeTensorInfo(t,e,s){return e==="string"&&s!=null&&s.length>0&&xd(s[0])&&(s=s.map(i=>Ka(i))),{dataId:this.write(s,t,e),shape:t,dtype:e}}tensorToBinding(t){if(!t)return null;const s=this.tensorMap.get(t.dataId).resource;return s instanceof GPUBuffer?{buffer:s}:s instanceof GPUTexture?s.createView():s}uploadToGPU(t){const e=this.tensorMap.get(t);if(e.resource!=null)return;const s=sT(e.dtype)*ht(e.shape);let r;const i=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(e.values){if(r=this.bufferManager.acquireBuffer(s,i,!0),r.mapState==="unmapped"){const a=this.bufferManager.acquireBuffer(s,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),o=a.getMappedRange();e.dtype==="int32"||e.dtype==="bool"?new Int32Array(o).set(e.values):new Float32Array(o).set(e.values),a.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(a,0,r,0,s),this.stagingPendingDisposal.push(a)}else{const a=r.getMappedRange();e.dtype==="int32"||e.dtype==="bool"?new Int32Array(a).set(e.values):new Float32Array(a).set(e.values),r.unmap()}e.values=null}else r=this.bufferManager.acquireBuffer(s,i);e.resource=r}makeUniforms(t){let e=0,s=0;const r=[];let i=1;t.forEach(u=>{u.data.length===0&&(u.data=[1]);let h;switch(u.data.length){case 1:h=4;break;case 2:h=8;break;case 3:h=16;break;case 4:h=16;break;case 5:h=16;break;case 6:h=16;break;default:M(!1,()=>`Unsupported ${u.data.length}D shape`)}(s===5||s===6)&&(h=16),h>i&&(i=h),e=Math.ceil(e/h)*h,s=u.data.length,r.push(e),e+=u.data.length*4}),e=Math.ceil(e/i)*i;const a=new ArrayBuffer(e);t.forEach((u,h)=>{const d=r[h];u.type==="int32"?new Int32Array(a,d,u.data.length).set(u.data):u.type==="uint32"?new Uint32Array(a,d,u.data.length).set(u.data):new Float32Array(a,d,u.data.length).set(u.data)});const o=this.bufferManager.acquireBuffer(e,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(o,0,a,0,e),this.uniformPendingDisposal.push(o),{offset:0,size:e,buffer:o}}runWebGPUProgram(t,e,s,r,i){if(i||(i=this.makeTensorInfo(t.outputShape,s)),ht(i.shape)===0)return this.tensorMap.get(i.dataId).values=Si(i.dtype,0),i;this.uploadToGPU(i.dataId),t.dispatch=mH(this.device,t);const a=e.map((u,h)=>{if(u.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(u.dataId),{dtype:this.tensorMap.get(u.dataId).dtype,shape:u.shape,name:t.variableNames[h]}});t.shaderKey=rH(t,a,i);const o=tt().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return t.shaderKey in this.pipelineCache||(this.pipelineCache[t.shaderKey]=eH(this.device,t,a,i,o)),t.pipeline=this.pipelineCache[t.shaderKey],o||this.recordAndSubmit(t,i,e,r),i}recordAndSubmit(t,e,s,r){if(t.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let i=[],a=[];const o="int32";if(t.pixelsOpType==null){i.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),a=s.concat(e).map(y=>y.shape);const m="int32";a.map(y=>{i.push({type:m,data:y});const x=cn(y);i.push({type:m,data:x})})}else{const m=cn(e.shape);i.push({type:o,data:m})}if(t.size){const m=ht(t.outputShape);i.push({type:o,data:[t.outputComponent?m/t.outputComponent:m]})}r&&(i=[...i,...r]);const u=[this.tensorToBinding(e),...s.map(m=>this.tensorToBinding(m)),this.makeUniforms(i)];s.forEach(m=>{this.commandQueueOwnedIds.add(m.dataId)}),this.commandQueueOwnedIds.add(e.dataId);const h=this.device.createBindGroup({layout:t.pipeline.getBindGroupLayout(0),entries:u.map((m,y)=>({binding:y,resource:m}))}),d=this.activeTimers!=null;this.ensureCommandEncoderReady();const f={};d&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),f.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(f)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(f)),this.computePassEncoder.setPipeline(t.pipeline),this.computePassEncoder.setBindGroup(0,h),this.computePassEncoder.dispatchWorkgroups(t.dispatch[0],t.dispatch[1],t.dispatch[2]),this.dispatchCountInPass++,(d||tt().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||t.pixelsOpType===Hu.DRAW)&&(this.endComputePassEncoder(),d?this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const t=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,this.querySetCount*8),this.submitQueue(),await t.mapAsync(GPUMapMode.READ);const e=new BigUint64Array(t.getMappedRange()),s=Number(e[1]-e[0])/1e6;return t.unmap(),this.bufferManager.releaseBuffer(t),s}shouldExecuteOnCPU(t,e=pH){return tt().getBool("WEBGPU_CPU_FORWARD")&&t.every(s=>this.tensorMap.get(s.dataId).resource==null&&ht(s.shape)<e)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}tc.nextDataId=0;/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */yR()&&RN("webgpu",async()=>{const n={powerPreference:tt().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},t=await navigator.gpu.requestAdapter(n),e={},s=[];t.features.has("timestamp-query")&&s.push("timestamp-query"),t.features.has("bgra8unorm-storage")&&s.push(["bgra8unorm-storage"]),e.requiredFeatures=s;const r=t.limits;e.requiredLimits={maxComputeWorkgroupStorageSize:r.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.maxStorageBufferBindingSize,maxBufferSize:r.maxBufferSize,maxComputeWorkgroupSizeX:r.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:r.maxComputeInvocationsPerWorkgroup};const i=await t.requestDevice(e),a="info"in t?t.info:"requestAdapterInfo"in t?await t.requestAdapterInfo():void 0;return new tc(i,a)},3);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var qt;(function(n){n[n.ADD=0]="ADD",n[n.ATAN2=1]="ATAN2",n[n.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",n[n.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",n[n.DIV=4]="DIV",n[n.ELU_DER=5]="ELU_DER",n[n.EQUAL=6]="EQUAL",n[n.FLOOR_DIV=7]="FLOOR_DIV",n[n.GREATER=8]="GREATER",n[n.GREATER_EQUAL=9]="GREATER_EQUAL",n[n.LESS=10]="LESS",n[n.LESS_EQUAL=11]="LESS_EQUAL",n[n.LOGICAL_AND=12]="LOGICAL_AND",n[n.LOGICAL_OR=13]="LOGICAL_OR",n[n.MAX=14]="MAX",n[n.MIN=15]="MIN",n[n.MOD=16]="MOD",n[n.MUL=17]="MUL",n[n.NOT_EQUAL=18]="NOT_EQUAL",n[n.POW=19]="POW",n[n.PRELU=20]="PRELU",n[n.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",n[n.SUB=22]="SUB"})(qt||(qt={}));const gH="let resultTemp = a + b;",yH="let resultTemp = atan2(a, b);",xH="let resultTemp = areal * breal - aimag * bimag;",bH="let resultTemp = areal * bimag + aimag * breal;",vH="let resultTemp = a / b;",wH="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",SH=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,CH=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,$H=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,TH=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,kH=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,_H=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,NH="return f32(a >= 1.0 && b >= 1.0);",EH=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,RH="return f32(a >= 1.0 || b >= 1.0);",IH=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,AH="let resultTemp = max(a, b);",DH="let resultTemp = min(a, b);",OH=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,PH=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,FH="let resultTemp = a * b;",LH=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,MH=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,zH=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,BH=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,VH="if (a < 0.0) { return b * a; }  return a;",UH=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,WH="let resultTemp = (a - b) * (a - b);",GH="let resultTemp = a - b;";function pw(n,t){let e;do{switch(n){case qt.ATAN2:e=yH;break;case qt.MAX:e=AH;break;case qt.MIN:e=DH;break;case qt.MOD:e=t?PH:OH;break;case qt.NOT_EQUAL:e=t?MH:LH;break;case qt.POW:e=t?BH:zH;break;default:continue}let s,r,i;return t?(s="isnanVec4",r="vec4<f32>",i="vec4<bool>"):(s="isnan",r="f32",i="bool"),`
      let aIsNaN = ${s}(a);
      let aPostLegalization = select(a, ${r}(42), aIsNaN);
      let bIsNaN = ${s}(b);
      let bPostLegalization = select(b, ${r}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${e}
        return select(
            resultTemp, ${r}(valueForNaN),
            ${i}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(n){case qt.ADD:e=gH;break;case qt.COMPLEX_MULTIPLY_IMAG:e=bH;break;case qt.COMPLEX_MULTIPLY_REAL:e=xH;break;case qt.DIV:e=vH;break;case qt.ELU_DER:e=wH;break;case qt.EQUAL:e=SH;break;case qt.FLOOR_DIV:e=CH;break;case qt.GREATER:e=$H;break;case qt.GREATER_EQUAL:e=TH;break;case qt.LESS:e=kH;break;case qt.LESS_EQUAL:e=_H;break;case qt.LOGICAL_AND:return t?EH:NH;case qt.LOGICAL_OR:return t?IH:RH;case qt.MUL:e=FH;break;case qt.PRELU:return t?UH:VH;case qt.SQUARED_DIFFERENCE:e=WH;break;case qt.SUB:e=GH;break}return`
    ${e}
    return resultTemp;
  `}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ct;(function(n){n[n.ABS=0]="ABS",n[n.ACOS=1]="ACOS",n[n.ACOSH=2]="ACOSH",n[n.ASIN=3]="ASIN",n[n.ASINH=4]="ASINH",n[n.ATAN=5]="ATAN",n[n.ATANH=6]="ATANH",n[n.CEIL=7]="CEIL",n[n.COS=8]="COS",n[n.COSH=9]="COSH",n[n.ELU=10]="ELU",n[n.ERF=11]="ERF",n[n.EXP=12]="EXP",n[n.EXPM1=13]="EXPM1",n[n.FLOOR=14]="FLOOR",n[n.IS_FINITE=15]="IS_FINITE",n[n.IS_INF=16]="IS_INF",n[n.IS_NAN=17]="IS_NAN",n[n.LINEAR=18]="LINEAR",n[n.LOG=19]="LOG",n[n.LOG1P=20]="LOG1P",n[n.LOGICAL_NOT=21]="LOGICAL_NOT",n[n.NEG=22]="NEG",n[n.RELU=23]="RELU",n[n.RELU6=24]="RELU6",n[n.LEAKYRELU=25]="LEAKYRELU",n[n.RECIPROCAL=26]="RECIPROCAL",n[n.ROUND=27]="ROUND",n[n.RSQRT=28]="RSQRT",n[n.SELU=29]="SELU",n[n.SIGMOID=30]="SIGMOID",n[n.SIGN=31]="SIGN",n[n.SIN=32]="SIN",n[n.SINH=33]="SINH",n[n.SOFTPLUS=34]="SOFTPLUS",n[n.SQRT=35]="SQRT",n[n.SQUARE=36]="SQUARE",n[n.STEP=37]="STEP",n[n.TAN=38]="TAN",n[n.TANH=39]="TANH",n[n.TO_INT=40]="TO_INT"})(Ct||(Ct={}));const HH="return abs(a);",jH=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,XH=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,qH=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,KH="return asinh(a);",YH=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,QH=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,ZH="return ceil(a);",JH="return cos(a);",t6=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,e6="return exp(a) - 1.0;",n6="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",s6=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,r6=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${Jv};
  let a1 = ${tw};
  let a2 = ${ew};
  let a3 = ${nw};
  let a4 = ${sw};
  let a5 = ${rw};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,i6="return exp(a);",a6="return floor(a);",o6="return f32(!isnan(a) && !isinf(a));",l6="return f32(isinf(a));",u6="return f32(isnan(a));",c6="return a;",h6=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,d6=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,f6="return f32(!(a >= 1.0));",p6="return -a;",m6="if (a < 0.0) { return uniforms.alpha * a; } return a;",g6=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,y6="return 1.0 / a;",x6="return select(a, 0.0, a < 0.0);",b6="return clamp(a, 0.0, 6.0);",v6="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",w6=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,S6="return round(a);",C6="return inverseSqrt(a);",$6=`
  if (a >= 0.0) {
    return ${Zv} * a;
  } else {
    return ${Qv} * (exp(a) - 1.0);
  }
`,T6="return 1.0 / (1.0 + exp(-1.0 * a));",k6="return sign(a);",_6="return sin(a);",N6=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,E6=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,R6="return sqrt(a);",I6="return a * a;",A6=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,D6="return tan(a);",O6=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,P6="return f32(i32((a)));";function Ko(n,t){switch(n){case Ct.ABS:return HH;case Ct.ACOS:return jH;case Ct.ACOSH:return XH;case Ct.ASIN:return qH;case Ct.ASINH:return KH;case Ct.ATAN:return YH;case Ct.ATANH:return QH;case Ct.COS:return JH;case Ct.COSH:return t6;case Ct.CEIL:return ZH;case Ct.ELU:return t?s6:n6;case Ct.ERF:return r6;case Ct.EXP:return i6;case Ct.EXPM1:return e6;case Ct.FLOOR:return a6;case Ct.IS_FINITE:return o6;case Ct.IS_INF:return l6;case Ct.IS_NAN:return u6;case Ct.LINEAR:return c6;case Ct.LOG:return h6;case Ct.LOG1P:return d6;case Ct.LOGICAL_NOT:return f6;case Ct.NEG:return p6;case Ct.LEAKYRELU:return t?g6:m6;case Ct.RECIPROCAL:return y6;case Ct.RELU:return t?w6:x6;case Ct.RELU6:return t?v6:b6;case Ct.ROUND:return S6;case Ct.RSQRT:return C6;case Ct.SELU:return $6;case Ct.SIGMOID:return T6;case Ct.SIGN:return k6;case Ct.SIN:return _6;case Ct.SINH:return N6;case Ct.SOFTPLUS:return E6;case Ct.SQRT:return R6;case Ct.SQUARE:return I6;case Ct.STEP:return A6;case Ct.TAN:return D6;case Ct.TANH:return O6;case Ct.TO_INT:return P6;default:throw new Error(`BinaryType ${n} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ca(n,t=!1,e=!1,s=3){if(n===null)return"";let r="";if(n==="linear")r=Ko(Ct.LINEAR);else if(n==="relu")r=Ko(Ct.RELU,e);else if(n==="elu")r=Ko(Ct.ELU,e);else if(n==="relu6")r=Ko(Ct.RELU6,e);else if(n==="prelu")r=pw(qt.PRELU,e);else if(n==="sigmoid")r=Ko(Ct.SIGMOID,e);else if(n==="leakyrelu")r=Ko(Ct.LEAKYRELU,e);else throw new Error(`Activation ${n} has not been implemented for the WebGPU backend.`);const a=ee(e?4:1);let o="";return t?o=`
      fn activation(a : ${a}, coords : vec${s}<i32>) -> ${a} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${r}
      }`:o=`
      fn activation(a : ${a}, coords : vec${s}<i32>) -> ${a} {
        ${r}
      }`,o}function _l(n,t){return`
      ${n?"value = value + getBiasByOutputCoords(coords);":""}
      ${t?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bR(n,t,e=!1,s=!1,r=!1,i=1){M(n&&i===1||!n,()=>`transposeA ${n} is not compatible with component size ${i}`);const a=`
      ${n?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,o=t?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${ee(i)} {
    var value = ${ee(i)}(0.0);
    ${e&&r?a:`
    ${n?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${a}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${ee(i)} {
    var value = ${ee(i)}(0.0);
    ${o}
    return value;
  }
  `}function mw(n,t,e,s,r=!1,i=!1,a=!1,o=1){return`
  ${bR(e,s,r,i,a,o)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${ee(o)}) {
    ${r&&i?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${_l(n,t)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}const F6=(n,t)=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${t});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${t});
        `,L6=(n,t,e,s)=>{if(n)return`
      for (var k = 0; k < ${s}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${e}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let r="",i="";for(let a=0;a<t;a++)r+=`let BCached${a} = mm_Bsub[k * ${t} + ${a}][tileCol];`,i+=`acc[i] = fma(BCached${a}, vec4<f32>(ACached[${a}]), acc[i]);`;return`
      for (var k = 0; k < ${s/t}; k++) {
        ${r}
        for (var i = 0; i < ${e}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${i}
        }
      }`}};function Am(n,t,e=!1,s=32,r=!1,i=32,a=!1){const o=t[1]*n[1],u=t[0]*n[0],h=e?o:s,d=e?s:o,f=h/t[0],m=s/t[1],y=n[1],x=n[0];return M((e&&f===4&&n[1]===4||!e&&(f===3||f===4))&&h%t[0]===0&&s%t[1]===0&&n[0]===4,()=>`If transposeA ${e} is true, innerElementSize ${f} and workPerThread[1] ${n[1]} must be 4.
          Otherwise, innerElementSize ${f} must be 3 or 4.
      tileAWidth ${h} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${n[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${f}<f32>, ${h/f}>, ${d}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${u/n[0]}>, ${s}>;

  ${Tt()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${y};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${y};
    let globalCol = i32(globalId.x) * ${x};
    let batch = ${r?"0":"i32(globalId.z)"};
    let batchA = ${r||!a?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${r||!a?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${o};

    let numTiles = ${r?`${Math.ceil(i/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
    var kStart = ${r?`i32(globalId.z) * ${i}`:"0"};

    var acc: array<vec4<f32>, ${y}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${m};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${y}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${F6(e,f)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${m}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${L6(e,f,y,s)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${y}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const rT=n=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,M6=n=>n?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function Dm(n,t,e=!1,s=32,r=!1,i=32,a=!1,o=!1){const u=n[1]*t[1],h=n[0]*t[0],d=e?u:s,f=e?s:u;M(f%t[1]===0&&d%t[0]===0&&s%t[1]===0,()=>`tileAHight ${f} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`);const m=f/t[1],y=d/t[0],x=s/t[1],w=n[1],S=n[0],C=a?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${u};
      let globalColStart = i32(workgroupId.x) * ${h};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${f}; inputRow = inputRow + ${t[1]}) {
          for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${t[0]}) {
            ${rT(e)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {
              for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${t[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${S}>;
        for (var k = 0; k < ${s}; k++) {
          for (var inner = 0; inner < ${S}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];
          }
          for (var innerRow = 0; innerRow < ${w}; innerRow++) {
            let ACached = ${e?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}
            for (var innerCol = 0; innerCol < ${S}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${w}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${t[1]};
        for (var innerCol = 0; innerCol < ${S}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${t[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${w};
  let tileCol = i32(localId.x) * ${S};

  let globalRow = i32(globalId.y) * ${w};
  let globalCol = i32(globalId.x) * ${S};
  let globalRowStart = i32(workgroupId.y) * ${u};

  let tileRowA = i32(localId.y) * ${m};
  let tileColA = i32(localId.x) * ${y};
  let tileRowB = i32(localId.y) * ${x};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${m}; innerRow++) {
      for (var innerCol = 0; innerCol < ${y}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${rT(e)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${x}; innerRow++) {
      for (var innerCol = 0; innerCol < ${S}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${s};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${S}>;
    for (var k = 0; k < ${s}; k++) {
      for (var inner = 0; inner < ${S}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${w}; innerRow++) {
        ${M6(e)}
        for (var innerCol = 0; innerCol < ${S}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${w}; innerRow++) {
    for (var innerCol = 0; innerCol < ${S}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${d}>, ${f}>;
    var<workgroup> mm_Bsub : array<array<f32, ${h}>, ${s}>;

    ${Tt()} {
      let batch = ${r?"0":"i32(globalId.z)"};
      let batchA = ${r||!o?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${r||!o?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${r?`${Math.ceil(i/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
      var kStart = ${r?`i32(globalId.z) * ${i}`:"0"};

      var acc : array<array<f32, ${S}>, ${w}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${w}; innerRow++) {
        for (var innerCol = 0; innerCol < ${S}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${C}
    }
  `}const z6=n=>n?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function B6(n,t=!1){M(n[1]===1&&n[2]===1,()=>`A linear work group size is required. But got ${n}.`);const e=n[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${n[0]}>;

    ${Tt()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${e} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${e} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${z6(t)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${e/4}; k++) {
          let rowB = t * ${e} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}let V6=class{constructor(t,e,s=!1,r=!1,i=null,a=null,o=null,u=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0]};const h=s?t[1]:t[2];if(this.isVec4=(h%4===0&&!s||e[1]%4===0&&s)&&e[2]%4===0&&!r,this.outputComponent=this.isVec4?4:1,this.isVectorA=e[1]===1&&!s,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const m=fH(e[1],h,e[2],s);this.workgroupSize=m.workgroupSize,this.elementsPerThread=m.elementsPerThread}this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const d=i!=null,f=o!=null;d&&this.variableNames.push("bias"),f&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=u,this.transposeA=s,this.transposeB=r,this.addBias=d,this.activation=a,this.hasPreluActivationWeights=f,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(e[1],e[2],h),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${s}_${r}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(t,e,s){const r=this.workgroupSize[1]*this.elementsPerThread[1],i=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=i;const a=t%r===0,o=e%i===0,u=s%this.tileInner===0;return[a,o,u]}getUserCode(){return`
      ${ca(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${mw(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?Am(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?B6(this.workgroupSize,this.transposeA):Dm(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U6(n){return`
    var<workgroup> sumValues : array<f32, ${n}>;
    ${Tt()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${n}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${n/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}class W6{constructor(t,e=!1,s=!1,r=null,i=null,a=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=t,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize);const o=r!=null,u=a!=null;o&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),this.transposeA=e,this.transposeB=s,this.addBias=o,this.activation=i,this.hasPreluActivationWeights=u,this.shaderKey=`matMulReduce_${this.activation}_${e}_${s}`}getUserCode(){return`
      ${ca(this.activation,this.hasPreluActivationWeights)}
      ${mw(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${U6(this.workgroupSize[0])}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G6(n){const t=n[1],e=n[0],s=t>e?t:e;return`
  var<workgroup> mm_Asub : array<array<f32, ${s}>, ${t}>;
  var<workgroup> mm_Bsub : array<array<f32, ${e}>, ${s}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${Tt()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${s} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${s};
    globalRowB = globalRowB + ${s};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${s};
      globalRowB = globalRowB + ${s};

      for (var k = 0; k < ${s}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}class H6{constructor(t,e,s,r=!1,i=!1,a=null,o=null,u=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=s,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(s[2]/this.workgroupSize[0]),Math.ceil(s[1]/this.workgroupSize[1]),s[0]];const h=a!=null;h&&this.variableNames.push("bias");const d=u!=null;d&&this.variableNames.push("preluActivationWeights"),this.transposeA=r,this.transposeB=i,this.addBias=h,this.activation=o,this.hasPreluActivationWeights=d,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${r}_${i}`}getUserCode(){return`
      ${ca(this.activation,this.hasPreluActivationWeights)}
      ${mw(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${G6(this.workgroupSize)}
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class j6{constructor(t,e,s=!1,r=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,M(t[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const i=(s&&this.outputShape[1]%4===0||!s&&e%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=i?4:1,i||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=kt(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],e],this.workgroupSize,this.elementsPerThread),this.transposeA=s,this.transposeB=r,this.shaderKey=`matMulSplitK_${s}_${r}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const t=this.outputComponent;return`
      ${bR(!1,this.transposeB,!1,!1,!1,t)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${ee(t)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${t}; i = i + 1) {
            ${lo("&result[flatIndex + i]",`${t>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${t===4?Am(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):Dm(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class X6{constructor(t,e=null,s=null,r=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=e!=null,this.hasPreluActivationWeights=r!=null,this.activation=s,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${s}`}getUserCode(){return`
    ${ca(this.activation,this.hasPreluActivationWeights)}
    ${Tt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${_l(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let q6=class{constructor(t){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${Tt("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _s(n){const{backend:t,attrs:e}=n,{shape:s,value:r}=e;let{dtype:i}=e;if(i=i||Qu(r),i==="string"){const a=kn(i,ht(s));return a.fill(r),t.makeTensorInfo(s,i,a)}else{const a=new q6(s),o=[{type:"float32",data:[r]}];return t.runWebGPUProgram(a,[],i,o)}}const K6={kernelName:Lb,backendName:"webgpu",kernelFunc:_s};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pt(n){const{inputs:t,attrs:e}=n,{x:s}=t,{shape:r}=e,i=ht(s.shape),a=M_(r,i),o=ht(a);return M(i===o,()=>`The new shape (${a}) has ${o} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.backend.incRef(s.dataId),{dataId:s.dataId,shape:a,dtype:s.dtype}}const Y6={kernelName:O1,backendName:"webgpu",kernelFunc:Pt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Om({a:n,b:t,transposeA:e,transposeB:s,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:u=null}){const h=n.shape.length,d=t.shape.length,f=e?n.shape[h-2]:n.shape[h-1],m=s?t.shape[d-1]:t.shape[d-2],y=e?n.shape[h-1]:n.shape[h-2],x=s?t.shape[d-2]:t.shape[d-1],w=n.shape.slice(0,-2),S=t.shape.slice(0,-2),C=ht(w),k=ht(S),R=ne(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([y,x]);M(f===m,()=>`Error in matMul: inner shapes (${f}) and (${m}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${s} must match.`);const A=e?[C,f,y]:[C,y,f],L=s?[k,x,m]:[k,m,x],V=Pt({inputs:{x:n},backend:r,attrs:{shape:A}}),B=Pt({inputs:{x:t},backend:r,attrs:{shape:L}}),z=[V,B],U=Math.max(C,k),D=[V,B],Y=[{type:"int32",data:[y]},{type:"int32",data:[x]},{type:"int32",data:[f]}];let nt,dt;const at=[U,y,x];let K=tt().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(K<0){const yt=tt().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),$t=yt>0?yt:r.thresholdToIncreaseWorkgroups,H=U*Math.ceil(y/32)*Math.ceil(x/32);H<=$t||y<=8&&H<=$t*2?U*y*x<=128?K=pi.MatMulReduceProgram:U===1&&m>=2e3?K=pi.MatMulSplitKProgram:K=pi.MatMulSmallOutputSizeProgram:K=pi.MatMulPackedProgram}switch(K){case pi.MatMulReduceProgram:nt=new W6(at,e,s,i,u,a);break;case pi.MatMulSplitKProgram:{if(dt=_s({backend:r,attrs:{shape:at,value:0,dtype:n.dtype}}),nt=new j6(at,m,e,s),i||u){dt=r.runWebGPUProgram(nt,D,n.dtype,Y,dt);const $t=new X6(dt.shape,i,u,a);let H=null;const ut=[dt];i&&ut.push(i),a&&ut.push(a),u==="leakyrelu"&&(H=[{type:"float32",data:[o]}],$t.uniforms+=" alpha : f32,");const xt=r.runWebGPUProgram($t,ut,dt.dtype,H);z.push(dt);const bt=Pt({inputs:{x:xt},backend:r,attrs:{shape:R}});z.push(xt);for(const _t of z)r.disposeData(_t.dataId);return bt}break}case pi.MatMulSmallOutputSizeProgram:nt=new H6(A,L,at,e,s,i,u,a);break;case pi.MatMulPackedProgram:const yt=r.adapterInfo.isIntel();nt=new V6(A,at,e,s,i,u,a,yt);break;default:throw new Error(`Unsupported MatMulProgramType ${K}.`)}i&&D.push(i),a&&D.push(a),u==="leakyrelu"&&(Y.push({type:"float32",data:[o]}),nt.uniforms+=" alpha : f32,"),dt=r.runWebGPUProgram(nt,D,n.dtype,Y,dt);const ct=Pt({inputs:{x:dt},backend:r,attrs:{shape:R}});z.push(dt);for(const yt of z)r.disposeData(yt.dataId);return ct}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q6(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:i,bias:a,preluActivationWeights:o}=t,{transposeA:u,transposeB:h,activation:d,leakyreluAlpha:f}=s;return Om({a:r,b:i,transposeA:u,transposeB:h,backend:e,bias:a,preluActivationWeights:o,leakyreluAlpha:f,activation:d})}const Z6={kernelName:Bp,backendName:"webgpu",kernelFunc:Q6};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let iT=class{constructor(t,e,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=ne(e,s),this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${t}`,this.op=t}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${pw(this.op,!1)}
      }

      ${Tt("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Zp=class{constructor(t,e,s){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=ne(e,s),this.dispatchLayout=At(this.outputShape),this.op=t,this.useSharedMemoryWithA=e.length<=1&&s.length>1&&e[0]<128,this.useSharedMemoryWithB=s.length<=1&&e.length>1&&s[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?s[0]:e[0],this.shaderKey=`binary_${t}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const r=e.length>0&&e[e.length-1]%4===0,i=s.length>0&&s[s.length-1]%4===0;r&&i?(this.outputComponent=4,this.variableComponents=[4,4]):r&&(d$(s)||s[s.length-1]===1)||i&&(d$(e)||e[e.length-1]===1)?(this.outputComponent=4,this.variableComponents=r?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${t}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let t;const e=this.outputComponent===4?"vec4<f32>":"f32",s=`
    fn binaryOperation(a : ${e}, b : ${e}) -> ${e} {
      ${pw(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){const r=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",i=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${r}];`:`let a = sharedBuf[${r}];
          let b = getBByOutputIndex(index);`;t=`
        ${s}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${Tt("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${i}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else t=`
       ${s}
       ${Tt("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${e}(getAByOutputCoords(coords));
           let b = ${e}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return t}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xs(n){const{inputs:t}=n,{x:e}=t;return n.backend.incRef(e.dataId),{dataId:e.dataId,shape:e.shape,dtype:e.dtype}}const J6={kernelName:gm,backendName:"webgpu",kernelFunc:Xs};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nl(n){const{inputs:t,backend:e}=n,{real:s,imag:r}=t,i=e.makeTensorInfo(s.shape,"complex64"),a=e.tensorMap.get(i.dataId),o=Xs({inputs:{x:s},backend:e}),u=Xs({inputs:{x:r},backend:e});return a.complexTensorInfos={real:o,imag:u},i}const t5={kernelName:lb,backendName:"webgpu",kernelFunc:Nl};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ec=class{constructor(t,e,s=""){this.variableNames=["A"],this.size=!0;const r=128;this.workgroupSize=[r,1,1],this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=e,s!==""&&(this.uniforms=s),this.shaderKey=`unary_${e}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${Ko(this.op,!1)}
      }
      ${Tt("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pe({opType:n,cpuKernelImpl:t,dtype:e}){return({inputs:s,backend:r})=>{const{x:i}=s,a=r,o=e||i.dtype;if(a.shouldExecuteOnCPU([i])&&t!=null){const h=a.tensorMap.get(i.dataId),d=t(h.values,o);return a.makeTensorInfo(i.shape,o,d)}const u=new ec(i.shape,n);return a.runWebGPUProgram(u,[i],o)}}function In({opType:n,cpuKernelImpl:t,supportsComplex:e=!1,dtype:s}){return({inputs:r,backend:i})=>{const{a,b:o}=r,u=i;if(e&&a.dtype==="complex64"){const f=u.tensorMap.get(a.dataId),m=u.tensorMap.get(o.dataId);let y,x;if(n!==qt.MUL)[y,x]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(S=>{const[C,k]=S,E={dataId:C.dataId,dtype:C.dtype,shape:a.shape},R={dataId:k.dataId,dtype:k.dtype,shape:o.shape},A=new Zp(n,a.shape,o.shape);return u.runWebGPUProgram(A,[E,R],Ns(C.dtype,k.dtype))});else{const S=new iT(qt.COMPLEX_MULTIPLY_REAL,a.shape,o.shape),C=new iT(qt.COMPLEX_MULTIPLY_IMAG,a.shape,o.shape),k=[{dataId:f.complexTensorInfos.real.dataId,dtype:f.complexTensorInfos.real.dtype,shape:a.shape},{dataId:f.complexTensorInfos.imag.dataId,dtype:f.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:m.complexTensorInfos.real.dataId,dtype:m.complexTensorInfos.real.dtype,shape:o.shape},{dataId:m.complexTensorInfos.imag.dataId,dtype:m.complexTensorInfos.imag.dtype,shape:o.shape}];y=u.runWebGPUProgram(S,k,"float32"),x=u.runWebGPUProgram(C,k,"float32")}const w=Nl({inputs:{real:y,imag:x},backend:u});return u.disposeData(y.dataId),u.disposeData(x.dataId),w}const h=s||Ns(a.dtype,o.dtype);if((a.dtype==="string"||o.dtype==="string"||u.shouldExecuteOnCPU([a,o]))&&t!=null){const f=u.tensorMap.get(a.dataId).values,m=u.tensorMap.get(o.dataId).values,y=a.dtype==="string"?no(f):f,x=a.dtype==="string"?no(m):m,[w,S]=t(a.shape,o.shape,y,x,h);return u.makeTensorInfo(S,h,w)}const d=new Zp(n,a.shape,o.shape);return u.runWebGPUProgram(d,[a,o],h)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e5(n){const t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rs(n){return(t,e,s,r,i)=>{const a=ne(t,e),o=a.length,u=cn(a),h=ht(a),d=Si(i,h),f=t.length,m=e.length,y=cn(t),x=cn(e),w=Wu(t,a),S=Wu(e,a);if(w.length+S.length===0)for(let C=0;C<d.length;++C)d[C]=n(s[C%s.length],r[C%r.length]);else for(let C=0;C<d.length;++C){const k=z0(C,o,u),E=k.slice(-f);w.forEach(V=>E[V]=0);const R=zx(E,f,y),A=k.slice(-m);S.forEach(V=>A[V]=0);const L=zx(A,m,x);d[C]=n(s[R],r[L])}return[d,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n5(n,t,e,s){if(s==="int32"){const r=Int32Array.from(n);return[t,"int32",r]}if(s==="bool"){const r=bm([0],e),[i,a]=Rs((o,u)=>o!==u?1:0)(t,[],n,r,"bool");return[a,"bool",i]}throw new Error(`Error in Cast: failed to cast ${e} to ${s}`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s5=Rs(((n,t)=>n+t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r5(n,t,e,s,r){const i=ht(s),a=ta(r,e);for(let o=0;o<n.length;o++){const u=n[o];if(u<0)throw new Error("Input x must be non-negative!");u>=r||(i>0?a[u]+=t[o]:a[u]+=1)}return a}function i5(n,t,e,s=!1){const r=n.shape[0],i=n.shape[1],a=Re([r,e],t.dtype);for(let o=0;o<r;o++)for(let u=0;u<i;u++){const h=n.get(o,u);if(h<0)throw new Error("Input x must be non-negative!");h>=e||(s?a.set(1,o,h):t.size>0?a.set(a.get(o,h)+t.get(o,u),o,h):a.set(a.get(o,h)+1,o,h))}return a}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a5=Rs(((n,t)=>n&t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ha(n){return(t,e,s)=>{const r=kn(e,t.length);for(let i=0;i<t.length;++i)r[i]=n(t[i],s);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o5=ha(n=>Math.ceil(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l5(n,t,e,s){const r=kn(e,ht(t));if(s&&e!=="string"){let i=0;n.forEach(a=>{const o=ht(a.shape);r.set(a.vals,i),i+=o})}else{let i=0;n.forEach(a=>{const o=e==="string"?no(a.vals):a.vals;let u=0;for(let h=0;h<a.shape[0];++h){const d=h*t[1]+i;for(let f=0;f<a.shape[1];++f)r[d+f]=o[u++]}i+=a.shape[1]})}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u5=Rs((n,t)=>n===t?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c5=ha(n=>Math.exp(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h5=ha(n=>Math.expm1(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d5=ha(n=>Math.floor(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f5=Rs((n,t)=>Math.floor(n/t));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p5(n,t,e,s,r,i,a,o,u){const h=Re([s,i],e);for(let d=0;d<s;d++){const f=[];let m=0;for(let y=0;y<r;y++){const x=n[d*r+y];m+=x*a[y],f.push(x)}if(m<0||m>=u/i)throw new Error(`Invalid indices: ${f} does not index into ${o}`);for(let y=0;y<i;y++)h.values[d*i+y]=t.get(...t.indexToLoc(m*i+y))}return h}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m5(n,t,e){const s=Re(e,n.dtype);for(let r=0;r<s.size;++r){const a=s.indexToLoc(r).slice(),o=a[0],u=a[2],h=t.locToIndex([o,u]);a[2]=t.values[h];const d=n.locToIndex(a);0<=d&&d<n.values.length&&(s.values[r]=n.values[d])}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g5=Rs((n,t)=>n>t?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y5=Rs((n,t)=>n>=t?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x5=Rs((n,t)=>n<t?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b5=Rs((n,t)=>n<=t?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v5(n,t,e){const s=(t-n)/(e-1),r=ta(e,"float32");r[0]=n;for(let i=1;i<r.length;i++)r[i]=r[i-1]+s;return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w5=ha(n=>Math.log(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S5(n,t,e,s){const r=Si(s,ht(e));for(let i=0;i<r.length;++i){const a=i*t;let o=n[a];for(let u=0;u<t;++u){const h=n[a+u];(Number.isNaN(h)||h>o)&&(o=h)}r[i]=o}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C5=Rs(((n,t)=>Math.max(n,t)));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $5=Rs(((n,t)=>Math.min(n,t)));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vR=Rs(((n,t)=>n*t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T5(n,t,e){const s=Zu(-1,e);return vR([],t,s,n,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k5=Rs(((n,t)=>n!==t?1:0));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _5(n,t,e,s,r){const i=t.length,a=ht(t),o=cn(t),u=cn(r),h=Si(e,ht(r));for(let d=0;d<a;++d){const f=z0(d,i,o),m=new Array(f.length);for(let x=0;x<m.length;x++)m[x]=f[s[x]];const y=zx(m,i,u);h[y]=n[d]}return h}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N5(n,t,e,s){const[r,i]=mr(n,s),a=Ns(t,"int32"),o=ta(ht(r),a),u=ht(i);for(let h=0;h<o.length;++h){const d=h*u;let f=1;for(let m=0;m<u;++m)f*=e[d+m];o[h]=f}return{outVals:o,outShape:r,outDtype:a}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E5(n,t,e){n.forEach((s,r)=>{if(s<0||s>=e){const i=z0(r,t.length,cn(t)).join(",");throw new Error(`indices[${i}] = ${s} is not in [0, ${e})`)}})}function R5(n,t){for(let e=0;e<n.length;++e){const s=n[e],r=e===n.length-1?t:n[e+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let i=1;i<s.length;++i)if(s[i-1]>s[i])throw new Error("Ragged splits must be sorted in ascending order")}}function I5(n,t,e,s){const r=[];let i=0;const a=t.length-1+e.length,o=new Array(a).fill(null).map(()=>[0]);R5(e,s);let u=1;for(let h=0;h<t.length-1;++h){u*=t[h];const d=t[h+1];for(let f=1;f<u+1;++f)o[h].push(f*d)}for(let h=0;h<n.length;++h){let d=n[h],f=n[h]+1;for(let m=0;m<e.length;++m){const y=e[m],x=m+t.length-1;if(x>=0){const w=o[x],S=w[w.length-1]-y[d];for(let C=d;C<f;++C)o[x].push(y[C+1]+S)}d=y[d],f=y[f]}f!==d&&(r.push([d,f]),i+=f-d)}return{outSplits:o,valueSlices:r,numValues:i}}function A5(n){const t=[];for(let e=0;e<n.length;++e){const s=n[e].length,r=kn("int32",s);t.push(r),n[e].forEach((i,a)=>r[a]=i)}return t}function aT(n,t){const e=n.slice(0,t);for(;e.length<t;)e.push(1);for(let s=t;s<n.length;s++)e[t-1]*=n[s];return e}function D5(n,t,e,s,r,i){const a=aT(t,2)[1],o=aT(i,2)[1];let u=0;for(const h of e)for(let d=h[0];d<h[1];++d){for(let f=0;f<s;++f)r[u*o+f]=n[d*a+f];++u}}function O5(n,t,e,s,r){const i=t.slice();i[0]=r;const a=kn(e,ht(i)),o=n.length,u=o===0?0:o/t[0];return D5(n,t,s,u,a,i),[a,i]}function P5(n,t,e,s,r,i,a,o){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");const u=t[0][0]-1;if(E5(i,a,u),s.length===0)throw new Error("params.rank must be nonzero");const h=s[0],{outSplits:d,valueSlices:f,numValues:m}=I5(i,a,n,h),y=A5(d),x=O5(e,s,r,f,m);return[y,x[0],x[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oT=2147483647;function F5(n,t,e,s,r,i,a){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");const o=t.length===0,u=r.length===0,h=a.length===0,d=[];o||d.push(t[0]),u||d.push(r[0]),h||d.push(a[0]);for(let S=1;S<d.length;++S)if(d[S]!==d[S-1])throw new Error("starts, limits, and deltas must have the same shape");const f=d.length===0?1:d[0],m=kn("int32",f+1);m[0]=0;for(let S=0;S<f;++S){const C=o?n[0]:n[S],k=u?s[0]:s[S],E=h?i[0]:i[S];if(E===0)throw new Error("Requires delta != 0");let R;if(E>0&&k<C||E<0&&k>C)R=0;else if(R=Math.ceil(Math.abs((k-C)/E)),R>oT)throw new Error(`Requires ((limit - start) / delta) <= ${oT}`);m[S+1]=m[S]+R}const y=m[f],x=kn(e,y);let w=0;for(let S=0;S<f;++S){const C=m[S+1]-m[S];let k=o?n[0]:n[S];const E=h?i[0]:i[S];for(let R=0;R<C;++R)x[w++]=k,k+=E}return[m,x]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Nr=Zr;class Jp{constructor(t,e,s,r,i,a,o,u,h,d){this.shape=t,this.shapeShape=e,this.values=s,this.valuesShape=r,this.valuesDType=i,this.defaultValue=a,this.defaultValueShape=o,this.rowPartitionValues=u,this.rowPartitionValuesShapes=h,this.rowPartitionTypes=KE(d),this.raggedRank=YE(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Nr.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Nr.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Nr.VALUE_ROWIDS:return Jp.getMaxWidthValueRowID(e);case Nr.ROW_SPLITS:return Jp.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${Nr[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(e===0||e===1)return 0;let s=0;for(let r=0;r<e-1;++r){const i=t[r+1]-t[r];i>s&&(s=i)}return s}static getMaxWidthValueRowID(t){const e=t.length;if(e===0)return 0;let s=0,r=t[0],i=0;for(let a=1;a<e;++a){const o=t[a];o!==r&&(r=o,i=Math.max(a-s,i),s=a)}return Math.max(e-s,i)}tensorShapeFromTensor(t,e,s=!0){if(e.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return uT(t,s)}calculateOutputSize(t){const e=this.valuesShape,s=this.defaultValueShape;QE(s,e);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=qE(this.raggedRank,r,e);a[0]<0&&(a[0]=t);for(let o=1;o<=this.raggedRank;++o)a[o]<0&&(a[o]=this.getMaxWidth(o));return a}calculateFirstParentOutputIndex(t,e,s){const r=Math.min(t,s),i=[];let a=0;for(let o=0;o<r;++o,a+=e)i.push(a);for(let o=r;o<t;++o)i.push(-1);return M(i.length===t,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(t,e,s,r){const i=t.length,a=[];for(let o=0;o<i-1;++o){const u=t[o+1]-t[o];let h=Math.min(r,u),d=e[o];d===-1&&(h=0);for(let f=0;f<h;++f)a.push(d),d+=s;for(let f=0;f<u-h;++f)a.push(-1)}if(i>0&&a.length!==t[i-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(t,e,s,r){const i=t.length,a=[];if(i===0)return[];let o=0,u=t[0];if(u>=e.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${e.length}`);let h=e[u];a.push(h);for(let d=1;d<i;++d){const f=t[d];if(f===u)h>=0&&(++o,o<r?h+=s:h=-1);else{if(o=0,u=f,f>=e.length)throw new Error(`Got nextValueRowId=${f} which is not less than ${e.length}`);h=e[f]}a.push(h)}if(a.length!==t.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(t,e,s,r){const i=this.getRowPartitionTensor(t),a=this.getRowPartitionTypeByDimension(t);switch(a){case Nr.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,e,s,r);case Nr.ROW_SPLITS:if(i.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(i,e,s,r);default:throw new Error(`Unsupported partition type: ${Nr[a]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case Nr.FIRST_DIM_SIZE:return t[0];case Nr.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Nr.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Nr[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),s=this.calculateOutputSize(e),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let u=r.length-2;u>=0;--u)r[u]=r[u+1]*s[u+1];const i=uT(s,!1),a=kn(this.valuesDType,ht(i));if(r[0]*s[0]>0){let u=this.calculateFirstParentOutputIndex(e,r[0],s[0]);for(let h=1;h<=this.raggedRank;++h)u=this.calculateOutputIndex(h-1,u,r[h],s[h]);this.setOutput(this.raggedRank,u,a,i)}return[i,a]}setOutput(t,e,s,r){if(s.length===0)return;const i=this.values,a=s;let o=r.slice();o=o.slice(t+1);const u=ht(o),h=e.length;let d=this.defaultValue;if(d.length!==u&&d.length!==1){const x=this.defaultValueShape;Yt(()=>{const w=ft(d,x);d=Bh(w,o).dataSync()})}let f=0,m=0,y=0;for(let x=0;x<=h;++x){let w=x<h?e[x]:-1;if(w===y){++y;continue}if(m<y){const S=i.subarray(f*u),C=a.subarray(m*u),k=(y-m)*u;lT(C,S,k)}if(x>=h){const S=s.length;w=Math.floor(S/u)}if(w>y)if(this.defaultValue.length===1)a.subarray(y*u,w*u).fill(this.defaultValue[0]),y=w;else for(;w>y;){const S=a.slice(y*u);lT(S,d,u),++y}w<0?(f=x+1,m=y):(f=x,m=y,y=m+1)}}}function lT(n,t,e){for(let s=0;s<e;s++)n[s]=t[s]}function uT(n,t){const e=[];for(let s of n){if(s<0){if(!t)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}e.push(s)}return e}function L5(n,t,e,s,r,i,a,o,u,h){return new Jp(n,t,e,s,r,i,a,o,u,h).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M5(n,t,e,s){const r=n===t,i=n<t&&e<0,a=t<n&&e>1;if(r||i||a)return ta(0,s);const o=Math.abs(Math.ceil((t-n)/e)),u=ta(o,s);t<n&&e===1&&(e=-1),u[0]=n;for(let h=1;h<u.length;h++)u[h]=u[h-1]+e;return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z5=ha(n=>1/Math.sqrt(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B5(n,t,e,s,r,i,a,o,u,h){const d=[s/r,r],f=n.values,m=t.values;if(s===0)return Re(e,t.dtype);const y=u instanceof Bu?u:Re(d,t.dtype);typeof u=="string"||typeof u=="number"?y.values.fill(u):typeof u=="boolean"&&y.values.fill(+u);for(let x=0;x<i;x++){const w=[];let S=0;for(let C=0;C<a;C++){const k=f[x*a+C];w.push(k),S+=k*o[C]}if(S<0||S>=s/r)throw new Error(`Invalid indices: ${w} does not index into ${e}`);for(let C=0;C<r;C++)h?y.values[S*r+C]+=m[x*r+C]:y.values[S*r+C]=t.rank===0?m[0]:m[x*r+C]}return y}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V5=ha(n=>1/(1+Math.exp(-n)));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U5(n,t,e,s,r){const i=Uv(s,t,e),a=ht(e),o=cn(s);if(i){const f=Wv(t,o);return r==="string"?n.slice(f,f+a):n.subarray(f,f+a)}const u=r==="string"?no(n):n,h=Re(s,r,u),d=Re(e,r);for(let f=0;f<d.size;++f){const m=d.indexToLoc(f),y=m.map((x,w)=>x+t[w]);d.set(h.get(...y),...m)}return r==="string"?cR(d.values):d.values}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W5(n,t,e,s,r,i,a){const o=t[0],u=i[0],h=new Array(u),d=new Array(o),f=t[1];if(u===0){if(o!==0)throw new Error(ZE(o));const S=kn(e,0),C=kn(r,0);return[S,[0,f],C,h,d]}let m=!0,y=0;const x=new Array(u).fill(0);for(let S=0;S<o;++S){const C=n[S*f];if(C<0)throw new Error(JE(S,C));if(C>=u)throw new Error(tR(S,C,u));++x[C],m=m&&C>=y,y=C}let w=!0;for(let S=0;S<u;++S){const C=x[S]===0;h[S]=C,w=w&&!C,x[S]=Math.max(x[S],1),S>0&&(x[S]+=x[S-1])}if(w&&m){const S=n,C=s;for(let k=0;k<o;++k)d[k]=k;return[S,[o,f],C,h,d]}else{const S=x[u-1],C=kn(e,S*f),k=kn(r,S),E=new Array(u).fill(0);for(let R=0;R<o;++R){const A=n[R*f],L=E[A],V=(A===0?0:x[A-1])+L;E[A]++;for(let B=0;B<f;++B)C[V*f+B]=n[R*f+B];k[V]=s[R],d[R]=V}for(let R=0;R<u;++R)if(E[R]===0){const L=R===0?0:x[R-1];C[L*f+0]=R;for(let V=1;V<f;++V)C[L*f+V]=0;k[L]=a}return[C,[S,f],k,h,d]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G5(n,t,e,s,r){const i=ht(s),a=t[0],o=r.length,u=[];let h=1,d=-1;for(let S=0;S<o;++S){const C=r[S];if(C===-1){if(d!==-1)throw new Error(eR(d,S));d=S,u.push(1)}else{if(C<0)throw new Error(nR(S,C));h*=C,u.push(C)}}if(d!==-1){if(h<=0)throw new Error(sR());const S=Math.trunc(i/h);if(h*S!==i)throw new Error(rR(s,u));u[d]=S}if(ht(u)!==i)throw new Error(iR(s,u));const m=s.length,y=[];if(m>0){y[m-1]=1;for(let S=m-2;S>=0;--S)y[S]=y[S+1]*s[S+1]}const x=[];if(o>0){x[o-1]=1;for(let S=o-2;S>=0;--S)x[S]=x[S+1]*u[S+1]}const w=kn(e,a*o);for(let S=0;S<a;++S){let C=0;for(let k=0;k<m;++k)C+=n[S*m+k]*y[k];for(let k=0;k<o;++k)w[S*o+k]=Math.trunc(C/x[k]),C%=x[k]}return[w,[a,o],u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H5(n,t,e,s,r,i=!1,a=0){const o=s.length,u=[t[0],n.length/t[0]],h=u[1],f=o>0?r[o-1]+1:0;if(f<0)throw new Error(n0());const m=t.slice();m[0]=f;const y=m.reduce((E,R)=>E*R,1),x=kn(e,y);if(o===0)return f>0&&x.fill(a),[x,m];if(f<=0)throw new Error(n0());let w=0,S=1,C=0,k=r[w];for(;;){let E=0;if(S<o){if(E=r[S],k===E){++S;continue}if(k>=E)throw new Error(aR())}if(k<0||k>=f)throw new Error(oR(k,f));k>C&&x.fill(a,C*h,k*h);for(let R=w;R<S;++R){const A=s[R];if(A<0||A>=u[0])throw new Error(lR(R,s[R],u[0]));for(let L=0;L<h;L++)x[k*h+L]+=n[A*h+L]}if(i)for(let R=0;R<h;R++)x[k*h+R]/=S-w;if(w=S,++S,C=k+1,k=E,S>o)break}return C<f&&x.fill(a,C*h,f*h),[x,m]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j5=ha(n=>Math.sqrt(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X5=Rs(((n,t)=>{const e=n-t;return e*e}));/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q5=ha((n,t)=>{const{pattern:e,replaceGlobal:s,rewrite:r}=t;return n.replace(new RegExp(e,s?"g":""),r)});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K5(n,t,e,s){const r=Re(n,t.dtype);for(let i=0;i<r.size;i++){const a=r.indexToLoc(i),o=new Array(a.length);for(let u=0;u<o.length;u++)o[u]=a[u]*e[u]+s[u];r.set(t.get(...o),...a)}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Y5{constructor(t,e,s,r,i,a){this.separator=Ka(t),this.nGramWidths=e,this.leftPad=Ka(s),this.rightPad=Ka(r),this.padWidth=i,this.preserveShort=a}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const s=this.getPadWidth(e);return Math.max(0,t+2*s-e+1)}createNGrams(t,e,s,r,i,a){for(let o=0;o<i;++o){const u=this.getPadWidth(a),h=Math.max(0,u-o),d=Math.max(0,u-(i-(o+1))),f=a-(h+d),m=e+(h>0?0:o-u);let y=0;y+=h*this.leftPad.length;for(let k=0;k<f;++k)y+=t[m+k].length;y+=d*this.rightPad.length;const x=h+d+f-1;y+=x*this.separator.length,s[r+o]=new Uint8Array(y);const w=s[r+o];let S=0;const C=k=>k.forEach(E=>w[S++]=E);for(let k=0;k<h;++k)C(this.leftPad),C(this.separator);for(let k=0;k<f-1;++k)C(t[m+k]),C(this.separator);if(f>0){C(t[m+f-1]);for(let k=0;k<d;++k)C(this.separator),C(this.rightPad)}else{for(let k=0;k<d-1;++k)C(this.rightPad),C(this.separator);C(this.rightPad)}}}compute(t,e){const s=t.length,r=e.length;if(r>0){let u=e[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let h=1;h<r;++h){let d=e[h]>=u;if(d=d&&e[h]<=s,!d)throw new Error(`Invalid split value ${e[h]}, must be in [${u}, ${s}]`);u=e[h]}if(u!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${u}`)}const i=r-1,a=kn("int32",r);if(s===0||r===0){const u=new Array(s);for(let h=0;h<=i;++h)a[h]=0;return[u,a]}a[0]=0;for(let u=1;u<=i;++u){const h=e[u]-e[u-1];let d=0;this.nGramWidths.forEach(f=>{d+=this.getNumNGrams(h,f)}),this.preserveShort&&h>0&&d===0&&(d=1),a[u]=a[u-1]+d}const o=new Array(a[i]);for(let u=0;u<i;++u){const h=e[u];let d=a[u];if(this.nGramWidths.forEach(f=>{const m=e[u+1]-e[u],y=this.getNumNGrams(m,f);this.createNGrams(t,h,o,d,y,f),d+=y}),this.preserveShort&&d===a[u]){const f=e[u+1]-e[u];if(f===0)continue;const m=f+2*this.padWidth;this.createNGrams(t,h,o,d,1,m)}}return[o,a]}}function Q5(n,t,e,s,r,i,a,o){return new Y5(e,s,r,i,a,o).compute(n,t)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z5(n,t,e,s){if(!n.length)return;if(t.length===0){for(let i=0;i<n.length;++i)s.push(n.subarray(i,i+1));return}if(t.length===1){const i=t[0];let a=n.indexOf(i);for(;a!==-1;){const o=n.subarray(0,a);(!e||o.length!==0)&&s.push(o),n=n.subarray(a+1),a=n.indexOf(i)}(!e||n.length!==0)&&s.push(n);return}let r=0;for(let i=0;i<n.length+1;i++)if(i===n.length||t.indexOf(n[i])!==-1){const a=n.subarray(r,i);(!e||a.length!==0)&&s.push(a),r=i+1}}function J5(n,t,e){const s=n.length,r=[];let i=0,a=0;const o=new Array(s);for(let m=0;m<s;++m){const y=r.length;Z5(n[m],t,e,r);const x=r.length-y;o[m]=x,i+=x,a=Math.max(a,x)}const u=kn("int32",i*2),h=new Array(i),d=[s,a];let f=0;for(let m=0;m<s;++m)for(let y=0;y<o[m];++y)u[f*2]=m,u[f*2+1]=y,h[f]=r[f],++f;return[u,h,d]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tj(n,t){const e=kn("int32",n.length);for(let s=0;s<n.length;++s)e[s]=EO(n[s]).modulo(t).getLowBitsUnsigned();return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ej=Rs(((n,t)=>n-t));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nj(n,t){const e=new Array(n.rank);for(let r=0;r<e.length;r++)e[r]=n.shape[r]*t[r];const s=Re(e,n.dtype);for(let r=0;r<s.values.length;++r){const i=s.indexToLoc(r),a=new Array(n.rank);for(let u=0;u<a.length;u++)a[u]=i[u]%n.shape[u];const o=n.locToIndex(a);s.values[r]=n.values[o]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eh=(n,t)=>{const e=t.value-n.value;return e===0?n.index-t.index:e};function wR(n,t,e=0,s=n.length-1){for(;s>e;){if(s-e>600){const o=s-e+1,u=t-e+1,h=Math.log(o),d=.5*Math.exp(2*h/3),f=.5*Math.sqrt(h*d*(o-d)/o)*Math.sign(u-o/2),m=Math.max(e,Math.floor(t-u*d/o+f)),y=Math.min(s,Math.floor(t+(o-u)*d/o+f));wR(n,t,m,y)}const r=n[t];let i=e,a=s;for(gh(n,e,t),Eh(n[s],r)>0&&gh(n,e,s);i<a;){for(gh(n,i,a),i++,a--;Eh(n[i],r)<0;)i=i+1;for(;Eh(n[a],r)>0;)a=a-1}Eh(n[e],r)===0?gh(n,e,a):(a=a+1,gh(n,a,s)),a<=t&&(e=a+1),t<=a&&(s=a-1)}}function sj(n,t,e,s,r){const i=t[t.length-1],[a,o]=[n.length/i,i],u=Si(e,a*s),h=Si("int32",a*s);for(let f=0;f<a;f++){const m=f*o,y=n.subarray(m,m+o);let x=new Array(y.length);y.forEach((k,E)=>x[E]={value:k,index:E}),s<x.length&&(wR(x,s),x=x.slice(0,s)),r&&x.sort(Eh);const w=f*s,S=u.subarray(w,w+s),C=h.subarray(w,w+s);for(let k=0;k<s;k++)S[k]=x[k].value,C[k]=x[k].index}const d=t.slice();return d[d.length-1]=s,[Re(d,e,u),Re(d,"int32",h)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rj(n,t,e,s){const r=Qe(t,e)[0],i=[1,e[0],1];for(let x=0;x<r;x++)i[0]*=e[x];i[1]=e[r];for(let x=r+1;x<e.length;x++)i[2]*=e[x];const a=new Map,o=new Int32Array(e[r]),u=new Bu(i,s,n),h=[],d=i[0]===1&&i[2]===1;for(let x=0;x<e[r];x++){let w;if(d)w=n[x].toString();else{const C=[];for(let k=0;k<i[0];k++)for(let E=0;E<i[2];E++)C.push(u.get(k,x,E));w=C.join(",")}const S=a.get(w);if(S!=null)o[x]=S;else{const C=a.size;a.set(w,C),o[x]=C,h.push(x)}}const f=i.slice();f[1]=a.size;const m=new Bu(f,s);h.forEach((x,w)=>{for(let S=0;S<i[0];S++)for(let C=0;C<i[2];C++)m.set(u.get(S,x,C),S,w,C)});const y=e.slice();return y[r]=f[1],{outputValues:m.values,outputShape:y,indices:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SR=Object.freeze(Object.defineProperty({__proto__:null,addImpl:s5,bincountImpl:r5,bincountReduceImpl:i5,bitwiseAndImpl:a5,castImpl:n5,ceilImpl:o5,concatImpl:l5,equalImpl:u5,expImpl:c5,expm1Impl:h5,floorDivImpl:f5,floorImpl:d5,gatherNdImpl:p5,gatherV2Impl:m5,greaterEqualImpl:y5,greaterImpl:g5,lessEqualImpl:b5,lessImpl:x5,linSpaceImpl:v5,logImpl:w5,maxImpl:S5,maximumImpl:C5,minimumImpl:$5,multiplyImpl:vR,negImpl:T5,notEqualImpl:k5,prodImpl:N5,raggedGatherImpl:P5,raggedRangeImpl:F5,raggedTensorToTensorImpl:L5,rangeImpl:M5,rsqrtImpl:z5,scatterImpl:B5,sigmoidImpl:V5,simpleAbsImpl:e5,sliceImpl:U5,sparseFillEmptyRowsImpl:W5,sparseReshapeImpl:G5,sparseSegmentReductionImpl:H5,sqrtImpl:j5,squaredDifferenceImpl:X5,staticRegexReplaceImpl:q5,stridedSliceImpl:K5,stringNGramsImpl:Q5,stringSplitImpl:J5,stringToHashBucketFastImpl:tj,subImpl:ej,tileImpl:nj,topKImpl:sj,transposeImpl:_5,uniqueImpl:rj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:ij,castImpl:aj,ceilImpl:oj,concatImpl:lj,equalImpl:uj,expImpl:cj,expm1Impl:hj,floorImpl:dj,floorDivImpl:fj,gatherNdImpl:pj,gatherV2Impl:mj,greaterEqualImpl:gj,greaterImpl:yj,lessEqualImpl:xj,lessImpl:bj,logImpl:vj,maxImpl:wj,maximumImpl:Sj,minimumImpl:Cj,multiplyImpl:$j,negImpl:Tj,notEqualImpl:kj,prodImpl:_j,rangeImpl:Nj,rsqrtImpl:Ej,scatterImpl:Rj,simpleAbsImpl:Ij,sliceImpl:Aj,stridedSliceImpl:Dj,stringNGramsImpl:Oj,subImpl:Pj,tileImpl:Fj,topKImpl:Lj,transposeImpl:Mj}=SR;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zj=pe({opType:Ct.ABS,cpuKernelImpl:Ij}),Bj={kernelName:V0,backendName:"webgpu",kernelFunc:zj};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vj=pe({opType:Ct.ACOS}),Uj={kernelName:U0,backendName:"webgpu",kernelFunc:Vj};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wj=pe({opType:Ct.ACOSH}),Gj={kernelName:W0,backendName:"webgpu",kernelFunc:Wj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hj=In({opType:qt.ADD,cpuKernelImpl:ij,supportsComplex:!0}),jj={kernelName:pm,backendName:"webgpu",kernelFunc:Hj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Xj=class{constructor(t){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t[0],this.variableNames=t.map((e,s)=>`T${s}`),this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const t=[];this.variableNames.forEach(r=>{t.push(`let v${r} = get${r}ByOutputCoords(coords);`)});const e=this.variableNames.map(r=>`v${r}`).join(" + ");return`
      ${Tt("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${t.join(`
        `)}
            setOutputAtIndex(flatIndex, ${e});
          }
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qj(n){const{inputs:t,backend:e}=n,s=t;if(s.length===1)return Xs({inputs:{x:s[0]},backend:e});const r=s.map(o=>o.dtype).reduce((o,u)=>Ns(o,u)),i=s.map(o=>o.shape),a=new Xj(i);return e.runWebGPUProgram(a,s,r)}const Kj={kernelName:G0,backendName:"webgpu",kernelFunc:qj};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yj{constructor(t,e){this.variableNames=["A"],this.workgroupSize=[16,16,1];const s=new Array(t.length);for(let r=0;r<s.length;r++)s[r]=t[e[r]];this.outputShape=s,this.dispatchLayout={x:[0],y:[1]},this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){M(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const t=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${Tt()} {
        var x = i32(workgroupId.x) * ${t} + i32(localId.x);
        var y = i32(workgroupId.y) * ${t} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${t} + i32(localId.x);
        y = i32(workgroupId.x) * ${t} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Qj=class{constructor(t,e){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(t.length);for(let r=0;r<s.length;r++)s[r]=t[e[r]];this.outputShape=s,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=e,this.shaderKey=`transpose_${e}`}getUserCode(){const t=mn(this.outputShape.length),e=CR(this.newDim);return`
      ${Tt("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${t}(${e}), uniforms.aShape)]);
          }
        }
      }
    `}};function CR(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=new Array(t);for(let s=0;s<n.length;s++)e[n[s]]=`coords.${Ji(s)}`;return e.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ci(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{perm:i}=s,a=e,o=r.shape.length,u=new Array(o);for(let d=0;d<u.length;d++)u[d]=r.shape[i[d]];if(e.shouldExecuteOnCPU([r])){const f=a.tensorMap.get(r.dataId).values,m=Mj(f,r.shape,r.dtype,i,u);return e.makeTensorInfo(u,r.dtype,m)}if(r.shape.length===2&&Ee(i,[1,0])){const d=new Yj(r.shape,i);return a.runWebGPUProgram(d,[r],r.dtype)}const h=new Qj(r.shape,i);return a.runWebGPUProgram(h,[r],r.dtype)}const Zj={kernelName:zh,backendName:"webgpu",kernelFunc:Ci};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Jj=class{constructor(t,e,s){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[t.batchSize,t.inSize];const[r]=mr(this.inputShape,[1]);this.outputShape=r.length===0?[1]:r,t.inSize>=32768&&s>=512?this.workgroupSize=[512,1,1]:t.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=e,this.shaderKey=`reduce_${e}`}getUserCode(){let t="",e="0.0";const s=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(t=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,e="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?t=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(t=" bestValue = bestValue * candidate; ",e="1.0"):this.reduceType==="all"?(t=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",e="1.0"):this.reduceType==="any"&&(t=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",e="0.0");const r=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${s}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${Tt("index")} {
         let outputIndex = index / ${s};
         let offset = getOffset(outputIndex);
         var bestValue = ${e};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${s}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${s}) {
           let candidate = f32(x[offset + k]);
           ${t}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${s}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${t}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${r}
        }
       }
     `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t8={mean:"float32",all:"bool",any:"bool"};function El(n,t,e,s,r){const i=n.shape.length,a=[],o=Qe(t,n.shape);let u=o;const h=ts(u,i);let d=n;h!=null&&(d=Ci({inputs:{x:n},attrs:{perm:h},backend:r}),u=es(u.length,i),a.push(d)),Qs(s,u,i);const[f,m]=mr(d.shape,u);let y=f;e&&(y=Ys(f,o));let x;if((s==="max"||s==="prod")&&r.shouldExecuteOnCPU([d])){const w=r.tensorMap.get(d.dataId).values;switch(s){case"max":const S=wj(w,ht(m),y,n.dtype);x=r.makeTensorInfo(y,n.dtype,S);break;case"prod":const{outVals:C,outShape:k,outDtype:E}=_j(d.shape,d.dtype,w,u);x=r.makeTensorInfo(k,E,C);break;default:throw new Error(`${s} CPU implementation is not yet supported.`)}}else{const w=ht(m),C=ht(d.shape)/w,k={windowSize:w,inSize:w,batchSize:C,outSize:1},E=t8[s]||vm(n.dtype),R=[{type:"int32",data:[w]}],A=new Jj(k,s,r.device.limits.maxComputeWorkgroupSizeX),L=r.runWebGPUProgram(A,[d],E,R);a.push(L),x=Pt({inputs:{x:L},attrs:{shape:y},backend:r})}return a.forEach(w=>r.disposeData(w.dataId)),x}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e8(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{keepDims:i,axis:a}=s;return El(r,a,i,"all",e)}const n8={kernelName:H0,backendName:"webgpu",kernelFunc:e8};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s8(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{keepDims:i,axis:a}=s;return El(r,a,i,"any",e)}const r8={kernelName:j0,backendName:"webgpu",kernelFunc:s8};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let $R=class{constructor(t,e,s){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const r=[e];this.op=s==="min"?"<":">";const[i,a]=mr(t,r);this.outputShape=i.length===0?[1]:i,this.dispatchLayout=At(this.outputShape),ht(a)<32?(this.type="plain",this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=kt(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=t,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const t=this.workgroupSize[0],e=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${Ji(this.inputShape.length-1)}`,s=()=>{let r="";if(this.outputShape.length===1)this.inputShape.length!==1&&(r+="outputCoords,");else for(let i=0;i<this.outputShape.length;i++)r+=`outputCoords.${Ji(i)},`;return r};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${t}>;
      var<workgroup> xBestValues : array<f32, ${t}>;
    `}

      ${Tt("index")} {
        let outputIndex = index / ${t};
        let reduceLength = ${e()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${t}) {
          let candidate = getX(${s()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${t}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${Tt("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${s()} 0);
          let reduceLength = ${e()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${s()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i8(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i}=s;let a=Qe(i,r.shape);const o=ts(a,r.shape.length);let u=r;const h=[];o!=null&&(u=Ci({inputs:{x:r},backend:e,attrs:{perm:o}}),h.push(u),a=es(a.length,u.shape.length)),Qs("argMax",[a[0]],u.shape.length);const d=new $R(u.shape,a[0],"max"),f=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],m=e.runWebGPUProgram(d,[u],"int32",f);return h.forEach(y=>e.disposeData(y.dataId)),m}const a8={kernelName:X0,backendName:"webgpu",kernelFunc:i8};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o8(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i}=s;let a=Qe(i,r.shape);const o=ts(a,r.shape.length);let u=r;const h=[];o!=null&&(u=Ci({inputs:{x:r},backend:e,attrs:{perm:o}}),h.push(u),a=es(a.length,u.shape.length)),Qs("argMin",[a[0]],u.shape.length);const d=new $R(u.shape,a[0],"min"),f=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],m=e.runWebGPUProgram(d,[u],"int32",f);return h.forEach(y=>e.disposeData(y.dataId)),m}const l8={kernelName:q0,backendName:"webgpu",kernelFunc:o8};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u8=pe({opType:Ct.ASIN}),c8={kernelName:K0,backendName:"webgpu",kernelFunc:u8};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h8=pe({opType:Ct.ASINH}),d8={kernelName:Y0,backendName:"webgpu",kernelFunc:h8};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f8=pe({opType:Ct.ATAN}),p8={kernelName:Q0,backendName:"webgpu",kernelFunc:f8};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m8=In({opType:qt.ATAN2}),g8={kernelName:J0,backendName:"webgpu",kernelFunc:m8};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y8=pe({opType:Ct.ATANH}),x8={kernelName:Z0,backendName:"webgpu",kernelFunc:y8};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class b8{constructor(t){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${Tt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let id=class{constructor(t,e,s=!1,r=!1,i=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=t.outShape,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=e,this.computePositions=s,this.flattenPositions=r,this.includeBatchIndex=i,this.shaderKey=`pool2D_${e}_${s}_${r}_${i}`}getUserCode(){let t;this.poolType==="avg"?t="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?t=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:t="resultValue = max(value, resultValue);";let e="resultValue";return this.poolType==="avg"&&(e="resultValue / max(count, 1.0)"),`
      ${Tt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${t}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${e});`}
        }
      }
    `}},gw=class{constructor(t,e,s=!1,r=!1,i=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=t.outShape,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=e,this.computePositions=s,this.flattenPositions=r,this.includeBatchIndex=i,this.shaderKey=`pool3D_${e}_${s}_${r}_${i}`}getUserCode(){let t;this.poolType==="avg"?t="resultValue += value; count += 1.0;":this.computePositions?t=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:t="resultValue = max(value, resultValue);";let e="resultValue";return this.poolType==="avg"&&(e="resultValue / max(count, 1.0)"),`
      ${Tt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${t}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${e});`}
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TR(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reductionIndices:i,keepDims:a}=s;return El(r,i,a,"max",e)}const v8={kernelName:o1,backendName:"webgpu",kernelFunc:TR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kR(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{keepDims:i,axis:a}=s;return El(r,a,i,"mean",e)}const w8={kernelName:d1,backendName:"webgpu",kernelFunc:kR};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _R(n,t,e,s){if(t.filterWidth===1&&t.filterHeight===1&&Ee(t.inShape,t.outShape))return Xs({inputs:{x:n},backend:s});if(t.filterWidth===t.inWidth&&t.filterHeight===t.inHeight&&t.batchSize===1&&t.padInfo.type==="VALID"){const a=n.shape.length,o=Pt({inputs:{x:n},backend:s,attrs:{shape:[n.shape[a-3]*n.shape[a-2],n.shape[a-1]]}});let u;e==="avg"?u=kR({inputs:{x:o},backend:s,attrs:{axis:0,keepDims:!1}}):(M(e==="max",()=>`Invalid pool type ${e}`),u=TR({inputs:{x:o},backend:s,attrs:{reductionIndices:0,keepDims:!1}}));const h=Pt({inputs:{x:u},backend:s,attrs:{shape:t.outShape}});return s.disposeData(o.dataId),s.disposeData(u.dataId),h}let r;const i=[{type:"int32",data:[t.strideHeight,t.strideWidth]}];return t.filterHeight===1&&t.filterWidth===1?r=new b8(t):(e==="avg"?r=new id(t,"avg"):(M(e==="max",()=>`Invalid pool type ${e}`),r=new id(t,"max")),i.push({type:"int32",data:[t.padInfo.top,t.padInfo.left]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]},{type:"int32",data:[t.inHeight,t.inWidth]},{type:"int32",data:[t.effectiveFilterHeight,t.effectiveFilterWidth]})),s.runWebGPUProgram(r,[n],n.dtype,i)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S8(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:i,strides:a,pad:o,dimRoundingMode:u}=s,d=Mr(r.shape,i,a,1,o,u);return _R(r,d,"avg",e)}const C8={kernelName:tb,backendName:"webgpu",kernelFunc:S8};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $8(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:i,strides:a,pad:o,dataFormat:u,dimRoundingMode:h}=s,d=[1,1,1],f=la(r.shape,i,a,d,o,h,u),m=new gw(f,"avg"),y=[{type:"int32",data:[f.strideDepth,f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.front,f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inDepth,f.inHeight,f.inWidth]},{type:"int32",data:[f.effectiveFilterDepth,f.effectiveFilterHeight,f.effectiveFilterWidth]}];return e.runWebGPUProgram(m,[r],r.dtype,y)}const T8={kernelName:eb,backendName:"webgpu",kernelFunc:$8};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let k8=class{constructor(t){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${Tt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}},_8=class{constructor(t){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${Tt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N8(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,a=i,{filterSize:o,strides:u,pad:h,dimRoundingMode:d}=s,f=la(a.shape,o,u,1,h,d),m=new _8(f),y=1/(f.filterDepth*f.filterHeight*f.filterWidth),x=[{type:"int32",data:[f.strideDepth,f.strideHeight,f.strideWidth]},{type:"int32",data:[f.effectiveFilterDepth-1-f.padInfo.front,f.effectiveFilterHeight-1-f.padInfo.top,f.effectiveFilterWidth-1-f.padInfo.left]},{type:"int32",data:[f.effectiveFilterDepth,f.effectiveFilterHeight,f.effectiveFilterWidth]},{type:"int32",data:[f.outDepth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"float32",data:[y]}];return e.runWebGPUProgram(m,[r],a.dtype,x)}const E8={kernelName:H_,backendName:"webgpu",kernelFunc:N8};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R8(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,a=i;xR([r,i],"avgPoolGrad");const{filterSize:o,strides:u,pad:h}=s,d=Mr(a.shape,o,u,1,h),f=new k8(d),m=1/(d.filterHeight*d.filterWidth),y=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"float32",data:[m]}];return e.runWebGPUProgram(f,[r],a.dtype,y)}const I8={kernelName:G_,backendName:"webgpu",kernelFunc:R8};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A8(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:i}=t,{transposeA:a,transposeB:o}=s;return Om({a:r,b:i,transposeA:a,transposeB:o,backend:e})}const D8={kernelName:nb,backendName:"webgpu",kernelFunc:A8};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let O8=class{constructor(t,e){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.rank=e.length,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=t,this.uniforms=`start : ${mn(t.length)}, `,this.shaderKey="slice"}getUserCode(){const t=mn(this.rank),e=P8(this.rank);let s;return this.start.length===1?s=this.outputShape.map((i,a)=>"sourceLoc = uniforms.start + coords;"):s=this.outputShape.map((i,a)=>`sourceLoc.${p0[a]} = uniforms.start.${Ji(a)} + coords.${p0[a]};`),`
      ${Tt("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${t};
          let coords = getCoordsFromIndex(index);
          ${s.join(`
`)}
          setOutputAtIndex(index, getSource(${e}));
        }
      }
    `}};const p0=["x","y","z","w","u","v"];function P8(n){if(n===1)return"sourceLoc";if(n<=6)return p0.slice(0,n).map(t=>`sourceLoc.${t}`).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nc(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:i,size:a}=s,[o,u]=Gv(r,i,a);if(Bv(r,o,u),e.shouldExecuteOnCPU([r])||r.dtype==="string"){const f=e.tensorMap.get(r.dataId),m=Aj(f.values,o,u,r.shape,r.dtype);return e.makeTensorInfo(u,r.dtype,m)}if(ht(u)===0)return e.makeTensorInfo(u,r.dtype,[]);const h=new O8(o,u),d=[{type:"int32",data:o}];return e.runWebGPUProgram(h,[r],r.dtype,d)}const F8={kernelName:j1,backendName:"webgpu",kernelFunc:nc};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L8=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:i,crops:a}=s;M(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const o=i.reduce((k,E)=>k*E),u=Cd(r.shape,i,o),h=$d(u.length,i.length),d=Td(r.shape,i,o),f=Kv(a,i.length),m=Yv(d,a,i.length),y=[],x=Pt({inputs:{x:r},backend:e,attrs:{shape:u}}),w=Ci({inputs:{x},backend:e,attrs:{perm:h}}),S=Pt({inputs:{x:w},backend:e,attrs:{shape:d}}),C=nc({inputs:{x:S},backend:e,attrs:{begin:f,size:m}});return y.push(x),y.push(w),y.push(S),y.forEach(k=>e.disposeData(k.dataId)),C},M8={kernelName:sb,backendName:"webgpu",kernelFunc:L8};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z8=`
  fn bincount_write(index: i32, value: f32) {
    ${lo("&result[index]","value","float32")}
  }
`,B8=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;class NR{constructor(t,e,s=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=t,this.rank=t.length,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=s,s&&(this.atomic=!1),this.hasWeights=e,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?B8:z8}
  ${Tt("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V8(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:i}=t,{size:a}=s,o=ht(r.shape),h=ht(i.shape)>0,d=[a],f=i.dtype,m=_s({backend:e,attrs:{shape:d,value:0,dtype:f}}),y=new NR([o],h),x=[{type:"int32",data:[a]}],w=h?[r,i]:[r];return e.runWebGPUProgram(y,w,f,x,m)}const U8={kernelName:rb,backendName:"webgpu",kernelFunc:V8};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class W8{constructor(t){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t],this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${Tt("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G8(n){const{inputs:t,backend:e}=n,{s0:s,s1:r}=t;if(e.shouldExecuteOnCPU([s,r])){const d=e.tensorMap.get(s.dataId),f=e.tensorMap.get(r.dataId),m=d.values,y=f.values,x=ne(Array.from(m),Array.from(y));return e.makeTensorInfo([x.length],"int32",Int32Array.from(x))}const i=ht(s.shape),a=ht(r.shape),o=Math.max(i,a),u=new W8(o),h=[{type:"int32",data:[i]},{type:"int32",data:[a]}];return e.runWebGPUProgram(u,[s,r],"int32",h)}const H8={kernelName:ib,backendName:"webgpu",kernelFunc:G8};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ER=In({opType:qt.NOT_EQUAL,dtype:"bool",cpuKernelImpl:kj}),j8={kernelName:v1,backendName:"webgpu",kernelFunc:ER};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kd(n){const{inputs:t,backend:e}=n,{input:s}=t,r=e.tensorMap.get(s.dataId);return Xs({inputs:{x:r.complexTensorInfos.real},backend:e})}const X8={kernelName:I1,backendName:"webgpu",kernelFunc:kd};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q8(n,t){const e=new ec(n.shape,Ct.TO_INT),s=t.runWebGPUProgram(e,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m0(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return Xs({inputs:{x:r},backend:e});const a=aa(r.shape),o=m0({inputs:{x:r},backend:e,attrs:{dtype:"float32"}}),u=Nl({inputs:{real:o,imag:a},backend:e});return a.dispose(),e.disposeData(o.dataId),u}if(r.dtype==="complex64"){const a=kd({inputs:{input:r},backend:e}),o=m0({inputs:{x:a},backend:e,attrs:{dtype:i}});return e.disposeData(a.dataId),o}if(!z_(r.dtype,i)){const a=Xs({inputs:{x:r},backend:e});return{dataId:a.dataId,shape:a.shape,dtype:i}}if(e.shouldExecuteOnCPU([r])){const a=e.tensorMap.get(r.dataId).values,[o,u,h]=aj(a,r.shape,r.dtype,i);return e.makeTensorInfo(o,u,h)}if(i==="int32")return q8(r,e);if(i==="bool"){const a=e.makeTensorInfo([],"bool",Si("bool",1)),u=ER({inputs:{a:r,b:a},backend:e});return e.disposeData(a.dataId),u}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const K8={kernelName:mm,backendName:"webgpu",kernelFunc:m0};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y8=pe({opType:Ct.CEIL,cpuKernelImpl:oj}),Q8={kernelName:ab,backendName:"webgpu",kernelFunc:Y8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Z8{constructor(t){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${Tt("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let J8=class{constructor(t){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${Tt("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tX(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{clipValueMin:i,clipValueMax:a}=s;let o;const u=[{type:"float32",data:[i]},{type:"float32",data:[a]}];return ht(r.shape)%4===0?o=new Z8(r.shape):o=new J8(r.shape),e.runWebGPUProgram(o,[r],r.dtype,u)}const eX={kernelName:ob,backendName:"webgpu",kernelFunc:tX};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nX=class{constructor(t){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${Tt("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cT(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}function sX(n){const{inputs:t,backend:e}=n,{x:s}=t,r=e.tensorMap.get(s.dataId),i=new nX(s.shape),a=[cT(s,r.complexTensorInfos.real),cT(s,r.complexTensorInfos.imag)];return e.runWebGPUProgram(i,a,a[0].dtype)}const rX={kernelName:ub,backendName:"webgpu",kernelFunc:sX};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let iX=class{constructor(t){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=Fr(t,1),this.variableNames=t.map((e,s)=>`T${s}`),this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=t.length-1;for(let e=0;e<this.offsetLength;e++)this.uniforms+=`offset${e} : i32,`;this.shaderKey="concat"}getUserCode(){const t=[];if(this.offsetLength>0){t.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let i=1;i<this.offsetLength;i++)t.push(`else if (yC < uniforms.offset${[i]}){ setOutputAtCoords(coords.x, coords.y, getT${i}(yR, yC - uniforms.offset${i-1})); }`);const s=this.offsetLength,r=this.offsetLength-1;t.push(`else { setOutputAtCoords(coords.x, coords.y, getT${s}(yR, yC - uniforms.offset${r})); }`)}else t.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${Tt("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${t.join(`
        `)}
          }
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pm(n){const{inputs:t,backend:e}=n,{input:s}=t,r=e.tensorMap.get(s.dataId);return Xs({inputs:{x:r.complexTensorInfos.imag},backend:e})}const aX={kernelName:Xb,backendName:"webgpu",kernelFunc:Pm};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rh(n,t,e){const s=n[0].dtype;if(s==="complex64"){const x=n.map(E=>kd({inputs:{input:E},backend:e})),w=n.map(E=>Pm({inputs:{input:E},backend:e})),S=Rh(x,t,e),C=Rh(w,t,e),k=Nl({inputs:{real:S,imag:C},backend:e});return x.forEach(E=>e.disposeData(E.dataId)),w.forEach(E=>e.disposeData(E.dataId)),e.disposeData(S.dataId),e.disposeData(C.dataId),k}let r=e.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const x=n.map(A=>{const V=[-1,ht(A.shape.slice(t))];return Pt({inputs:{x:A},backend:e,attrs:{shape:V}})}),w=x.map(A=>({vals:e.readSync(A.dataId),shape:A.shape})),S=Fr(x.map(A=>A.shape),1),C=x[0].shape[0]===1,k=lj(w,S,s,C),E=Fr(n.map(A=>A.shape),t),R=e.makeTensorInfo(E,s,k);return x.forEach(A=>e.disposeData(A.dataId)),R}const i=e.device.limits.maxStorageBuffersPerShaderStage-1;if(n.length>i){const x=[];for(let S=0;S<n.length;S+=i){const C=n.slice(S,S+i);x.push(Rh(C,t,e))}const w=Rh(x,t,e);for(const S of x)e.disposeData(S.dataId);return w}const{tensors2D:a,outShape:o}=oX(n,t,e),u=a.map(x=>x.shape),h=new iX(u),d=[],f=new Array(u.length-1);if(f.length>0){f[0]=u[0][1],d.push({type:"int32",data:[f[0]]});for(let x=1;x<f.length;x++)f[x]=f[x-1]+u[x][1],d.push({type:"int32",data:[f[x]]})}const m=e.runWebGPUProgram(h,a,a[0].dtype,d);a.forEach(x=>e.disposeData(x.dataId));const y=Pt({inputs:{x:m},backend:e,attrs:{shape:o}});return e.disposeData(m.dataId),y}function oX(n,t,e){const s=Fr(n.map(i=>i.shape),t);return{tensors2D:n.map(i=>Pt({inputs:{x:i},backend:e,attrs:{shape:[ht(i.shape.slice(0,t)),ht(i.shape.slice(t))]}})),outShape:s}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RR(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s,i=Qe(r,t[0].shape)[0],a=t.map(h=>h.shape);jv(a,i);const o=Fr(t.map(h=>h.shape),i);if(ht(o)===0)return e.makeTensorInfo(o,t[0].dtype,[]);const u=t.filter(h=>ht(h.shape)>0);return u.length===1?Xs({inputs:{x:u[0]},backend:e}):Rh(u,i,e)}const lX={kernelName:cb,backendName:"webgpu",kernelFunc:RR};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uX(n,t,e,s,r=!1,i=null,a=!1,o=4,u=4,h=4){const d=z=>{switch(z){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${z} is not supported.`)}},f=z=>{switch(z){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${z} is not supported.`)}},m=n?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,y=n?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,x=n?"uniforms.xShape[1]":"uniforms.xShape[2]",w=n?"uniforms.xShape[2]":"uniforms.xShape[3]",S=n?"row":"col",C=n?"col":"row",k=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${S} / outWidth;
      let outCol = ${S} % outWidth;

      let WRow = ${C} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${C} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${C} % inChannels;
      var resData = ${ee(o)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${x} && xCol >= 0 && xCol < ${w}) {
        ${m}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${d(o)}
      }
      return resData;`,E=n?t&&s?`
      ${k}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${k}
      }
      return ${ee(o)}(0.0);`:s&&e?`
      ${k}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${k}
      }
      return ${ee(o)}(0.0);`,R=`${f(u)}`,A=ee(h),L=ee(n?o:u),V=ee(n?u:o);return`
      ${ca(i,a,h===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${L} {
        ${n?E:R}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${V} {
        ${n?R:E}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${A}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${y}
        ${_l(r,i)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}class cX{constructor(t,e,s,r,i=!1,a=null,o=!1,u=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t.outShape,this.isChannelsLast=t.dataFormat==="channelsLast",this.isVec4=((t.inChannels%4===0||t.inChannels%3===0)&&this.isChannelsLast||t.outWidth%4===0&&!this.isChannelsLast)&&t.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=mR(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=gR(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&t.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),i&&(this.variableNames.push("bias"),this.variableComponents.push(4)),o&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=u,this.addBias=i,this.activation=a,this.hasPreluActivationWeights=o,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=e%this.tileAOuter===0,this.fitBOuter=s%this.tileBOuter===0,this.fitInner=r%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const t=this.isVec4?Am(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):Dm(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),e=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${uX(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,e[0],e[1],e[2])}
    ${t}
  `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hX{constructor(t,e=!1,s=null,r=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=t.outShape,this.isChannelsLast=t.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=e,this.activation=s,this.hasPreluActivationWeights=r,e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${ca(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${_l(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${Tt("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dX{constructor(t,e){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const t=this.isChannelsLast?1:2,e=this.isChannelsLast?2:3,s=this.isChannelsLast?"coords[1]":"coords[2]",r=this.isChannelsLast?"coords[2]":"coords[1]",i=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${Tt("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${s};
        let col = ${r};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${t}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${e}] && xCol >= 0) {
            value = ${i};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tm(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&e===1&&n[0]>1?[n[0],1]:null}function fX({x:n,filter:t,convInfo:e,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const u=e.dataFormat==="channelsLast",h=!u,d=!1,f=u&&e.filterHeight===e.inHeight&&e.filterWidth===e.inWidth&&e.padInfo.type==="VALID",m=[];let y,x;if(f){const C=e.inHeight*e.inWidth*e.inChannels;y=Pt({inputs:{x:n},backend:s,attrs:{shape:[1,e.batchSize,C]}}),x=Pt({inputs:{x:t},backend:s,attrs:{shape:[1,C,e.outChannels]}})}else y=Pt({inputs:{x:n},backend:s,attrs:{shape:u?[e.batchSize,e.inHeight*e.inWidth,e.inChannels]:[e.batchSize,e.inChannels,e.inHeight*e.inWidth]}}),x=Pt({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}});if(m.push(y),m.push(x),i!=null){const C=tm(i.shape,u);C!=null&&(i=Pt({inputs:{x:i},backend:s,attrs:{shape:C}}),m.push(i))}if(r!=null){const C=tm(r.shape,u);C!=null&&(r=Pt({inputs:{x:r},backend:s,attrs:{shape:C}}),m.push(r))}const w=Om({a:u?y:x,b:u?x:y,transposeA:h,transposeB:d,backend:s,bias:r,activation:o,preluActivationWeights:i,leakyreluAlpha:a}),S=Pt({inputs:{x:w},backend:s,attrs:{shape:e.outShape}});m.push(w);for(const C of m)s.disposeData(C.dataId);return S}function pX({x:n,filter:t,convInfo:e,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const{filterWidth:u,filterHeight:h,inChannels:d,strideWidth:f,strideHeight:m,padInfo:y,outWidth:x,outHeight:w,dilationWidth:S,dilationHeight:C,dataFormat:k}=e,E=k==="channelsLast",R=u*h*d,A=w*x,L=E?[e.batchSize,A,R]:[e.batchSize,R,A],V=new dX(L,E),B=[{type:"int32",data:[y.top,y.left]},{type:"int32",data:[m,f]},{type:"int32",data:[C,S]},{type:"int32",data:[x]},{type:"int32",data:[d*u]},{type:"int32",data:[d]}],z=s.runWebGPUProgram(V,[n],n.dtype,B),U=[];U.push(z);const D=Pt({inputs:{x:t},backend:s,attrs:{shape:[1,R,-1]}});if(U.push(D),i!=null){const K=tm(i.shape,E);K!=null&&(i=Pt({inputs:{x:i},backend:s,attrs:{shape:K}}),U.push(i))}if(r!=null){const K=tm(r.shape,E);K!=null&&(r=Pt({inputs:{x:r},backend:s,attrs:{shape:K}}),U.push(r))}const dt=Om({a:E?z:D,b:E?D:z,transposeA:!E,transposeB:!1,backend:s,bias:r,activation:o,preluActivationWeights:i,leakyreluAlpha:a}),at=Pt({inputs:{x:dt},backend:s,attrs:{shape:e.outShape}});U.push(dt);for(const K of U)s.disposeData(K.dataId);return at}function IR({x:n,filter:t,convInfo:e,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const u=r!=null,h=i!=null,d=e.dataFormat==="channelsLast",f=d&&e.filterHeight===e.inHeight&&e.filterWidth===e.inWidth&&e.padInfo.type==="VALID",m=tt().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!m&&(f||e.filterHeight===1&&e.filterWidth===1&&e.dilationHeight===1&&e.dilationWidth===1&&e.strideHeight===1&&e.strideWidth===1&&(e.padInfo.type==="SAME"||e.padInfo.type==="VALID")))return fX({x:n,filter:t,convInfo:e,backend:s,bias:r,activation:o,preluActivationWeights:i,leakyreluAlpha:a});const y=tt().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),x=y>-1?y:s.thresholdToIncreaseWorkgroups,w=e.batchSize*Math.ceil(e.outHeight*e.outWidth/32)*Math.ceil(e.outChannels/32);if(tt().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||w<=x)return pX({x:n,filter:t,convInfo:e,backend:s,bias:r,preluActivationWeights:i,leakyreluAlpha:a,activation:o});let S;const C=[e.padInfo.top,e.padInfo.left],k=[{type:"int32",data:[e.filterHeight,e.filterWidth]},{type:"int32",data:[...C]},{type:"int32",data:[e.strideHeight,e.strideWidth]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]}];if(m)S=new hX(e,u,o,h);else{const L=d?e.outHeight*e.outWidth:e.outChannels,V=d?e.outChannels:e.outHeight*e.outWidth,B=e.filterHeight*e.filterWidth*e.inChannels;k.push({type:"int32",data:[L]},{type:"int32",data:[V]},{type:"int32",data:[B]});const z=s.adapterInfo.isIntel();S=new cX(e,L,V,B,u,o,h,z)}const E=[],R=[n,t];u&&(!d&&r.shape.length===1&&(r=Pt({inputs:{x:r},backend:s,attrs:{shape:[r.shape[0],1,1]}}),E.push(r)),R.push(r)),h&&(!d&&i.shape.length===1&&(i=Pt({inputs:{x:i},backend:s,attrs:{shape:[i.shape[0],1,1]}}),E.push(i)),R.push(i)),o==="leakyrelu"&&(k.push({type:"float32",data:[a]}),S.uniforms+=" alpha : f32,");const A=s.runWebGPUProgram(S,R,n.dtype,k);for(const L of E)s.disposeData(L.dataId);return A}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mX(n){const{inputs:t,attrs:e,backend:s}=n,{x:r,filter:i}=t,{strides:a,pad:o,dataFormat:u,dilations:h,dimRoundingMode:d}=e,f=ri(u),m=vn(r.shape,i.shape,a,h,o,d,!1,f);return IR({x:r,filter:i,convInfo:m,backend:s})}const gX={kernelName:hb,backendName:"webgpu",kernelFunc:mX};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let yX=class{constructor(t){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=t.inShape,this.isChannelsLast=t.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&t.outChannels%4===0&&t.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const t=this.isChannelsLast?1:2,e=this.isChannelsLast?2:3,s=this.isChannelsLast?3:1,r=`
    ${Tt()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${r}
    `:`
    ${Tt("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${s}];

        let dyCorner = vec2<i32>(coords[${t}], coords[${e}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}},xX=class{constructor(t){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.filterShape,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${Tt("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}},bX=class{constructor(t){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.filterShape,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${Tt("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}},vX=class{constructor(t){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${Tt("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wX(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:a,pad:o,dataFormat:u,dimRoundingMode:h,filterShape:d}=s,f=ri(u),m=vn(r.shape,d,a,1,o,h,!1,f),y=new xX(m),x=[{type:"int32",data:[m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.batchSize]},{type:"int32",data:[m.outHeight]},{type:"int32",data:[m.outWidth]},{type:"int32",data:[m.inHeight]},{type:"int32",data:[m.inWidth]}];return e.runWebGPUProgram(y,[r,i],r.dtype,x)}const SX={kernelName:db,backendName:"webgpu",kernelFunc:wX};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CX(n=4){const t=i=>{switch(i){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${i} is not supported.`)}},s=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${ee(n)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${ee(n)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${n}];`}
      }
      return ${ee(n)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${ee(n)} {
    ${s}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${ee(n)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${t(n)}
    }
    return ${ee(n)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${ee(n)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${n}] = value;
    }
  }`}class $X{constructor(t){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t.inShape,M(t.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=t.inChannels%4===0&&t.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=mR(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=gR(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const t=this.isVec4?Am(this.elementsPerThread,this.workgroupSize):Dm(this.elementsPerThread,this.workgroupSize);return`
    ${CX(this.isVec4?4:1)}
    ${t}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TX(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{inputShape:a,strides:o,pad:u,dataFormat:h,dimRoundingMode:d}=s,f=ri(h),m=vn(a,i.shape,o,1,u,d,!1,f),y=[{type:"int32",data:[m.filterHeight,m.filterWidth]},{type:"int32",data:[m.filterHeight-1-m.padInfo.top,m.filterWidth-1-m.padInfo.left]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.batchSize,m.outHeight,m.outWidth,m.outChannels]}];let x;if(tt().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||m.dataFormat!=="channelsLast")x=new yX(m);else{x=new $X(m);const w=m.inHeight*m.inWidth,S=m.inChannels,C=m.filterHeight*m.filterWidth*m.outChannels;y.push({type:"uint32",data:[w]},{type:"uint32",data:[S]},{type:"uint32",data:[C]})}return e.runWebGPUProgram(x,[r,i],"float32",y)}const kX={kernelName:fb,backendName:"webgpu",kernelFunc:TX};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _X{constructor(t){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${Tt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NX(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:a,pad:o,dilations:u}=s,h=oo(r.shape,i.shape,a,u,o),d=[h.padInfo.front,h.padInfo.top,h.padInfo.left],f=[{type:"int32",data:[h.filterDepth,h.filterHeight,h.filterWidth]},{type:"int32",data:[...d]},{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.dilationDepth,h.dilationHeight,h.dilationWidth]}],m=new _X(h),y=Ns(r.dtype,i.dtype);return e.runWebGPUProgram(m,[r,i],y,f)}const EX={kernelName:pb,backendName:"webgpu",kernelFunc:NX};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RX(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:a,pad:o,filterShape:u}=s,h=oo(r.shape,u,a,1,o),d=new bX(h),f=[{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.batchSize]},{type:"int32",data:[h.outDepth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.inDepth]},{type:"int32",data:[h.inHeight]},{type:"int32",data:[h.inWidth]}];return e.runWebGPUProgram(d,[r,i],i.dtype,f)}const IX={kernelName:X_,backendName:"webgpu",kernelFunc:RX};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AX(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{strides:a,pad:o,inputShape:u}=s,h=oo(u,i.shape,a,1,o),d=new vX(h),f=[{type:"int32",data:[h.filterDepth,h.filterHeight,h.filterWidth]},{type:"int32",data:[h.filterDepth-1-h.padInfo.front,h.filterHeight-1-h.padInfo.top,h.filterWidth-1-h.padInfo.left]},{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.outDepth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.outChannels]}];return e.runWebGPUProgram(d,[r,i],r.dtype,f)}const DX={kernelName:mb,backendName:"webgpu",kernelFunc:AX};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OX=pe({opType:Ct.COS}),PX={kernelName:gb,backendName:"webgpu",kernelFunc:OX};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FX=pe({opType:Ct.COSH}),LX={kernelName:yb,backendName:"webgpu",kernelFunc:FX};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MX=class{constructor(t,e,s,r){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[i]=e;this.outputShape=[i,s[0],s[1],t],this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=r==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[t,e]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[s,r,i]=this.cropHeightBiggerThan1?[`(${t} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${t} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${t}`],[a,o,u]=this.cropWidthBiggerThan1?[`(${e} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${e} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${e}`];return`
    ${Tt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${s});
        let width_ratio = f32(${a});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${r};
        let width_scale = ${o};
        let in_y = ${i};
        if( in_y < 0.0 || in_y > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${u};
        if( in_x < 0.0 || in_x > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zX=n=>{const{inputs:t,backend:e,attrs:s}=n,{image:r,boxes:i,boxInd:a}=t,{cropSize:o,method:u,extrapolationValue:h}=s,d=new MX(r.shape[3],i.shape,o,u),f=[{type:"float32",data:[h]}];return e.runWebGPUProgram(d,[r,i,a],"float32",f)},BX={kernelName:vb,backendName:"webgpu",kernelFunc:zX};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ad;(function(n){n.Prod="*",n.Sum="+"})(ad||(ad={}));let hT=class{constructor(t,e,s,r){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=s,this.reverse=r,this.op=t,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const t=this.outputShape.length,e=this.op===ad.Prod?"1.0":"0.0",s=this.exclusive?e:`getX(${dT(t,"coords",this.op)})`,r=this.outputShape[this.outputShape.length-1];let i="",a="";return this.exclusive?(i=this.reverse?`end != ${r-1}`:"end != 0",a=this.reverse?"end + 1":"end - 1"):(i=this.reverse?`end + pow2 < ${r}`:"end >= pow2",a=this.reverse?"end + pow2":"end - pow2"),`
      ${Tt("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${fT(t,"coords",this.op)};
         var val = ${s};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${i}) {
           let idx = ${a};
           ${fT(t,"coords",this.op)} = idx;
           val ${this.op}= getX(${dT(t,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}};function dT(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.x, ${t}.y`;if(n===3)return`${t}.x, ${t}.y, ${t}.z`;if(n===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function fT(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.y`;if(n===3)return`${t}.z`;if(n===4)return`${t}.w`;throw Error(`Cumulative ${e} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AR(n,t,e,s,r,i){const a=t.shape.length,o=ts([s],a);let u=t;o!=null&&(u=Ci({inputs:{x:t},backend:e,attrs:{perm:o}}));const h=es(1,a)[0];if(h!==a-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${s}`);const d=u.shape[h];let f=Xs({inputs:{x:u},backend:e});for(let m=0;m<=Math.ceil(Math.log2(d))-1;m++){const y=new hT(n,u.shape,!1,i),x=f,w=[{type:"float32",data:[m]}];f=e.runWebGPUProgram(y,[f],f.dtype,w),e.disposeData(x.dataId)}if(r){const m=new hT(n,u.shape,r,i),y=f,x=[{type:"float32",data:[0]}];f=e.runWebGPUProgram(m,[f],f.dtype,x),e.disposeData(y.dataId)}if(o!=null){const m=Sd(o),y=Ci({inputs:{x:f},backend:e,attrs:{perm:m}});return e.disposeData(f.dataId),e.disposeData(u.dataId),y}return f}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VX(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,exclusive:a,reverse:o}=s;return AR(ad.Prod,r,e,i,a,o)}const UX={kernelName:xb,backendName:"webgpu",kernelFunc:VX};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WX(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,exclusive:a,reverse:o}=s;return AR(ad.Sum,r,e,i,a,o)}const GX={kernelName:bb,backendName:"webgpu",kernelFunc:WX};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HX(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:i}=t,{size:a,binaryOutput:o}=s,u=r.shape.length===1,d=ht(i.shape)>0,f=i.dtype,m=u?[r.shape[0]]:[r.shape[0],r.shape[1]],y=u?[a]:[r.shape[0],a],x=_s({backend:e,attrs:{shape:y,value:0,dtype:f}}),w=new NR(m,d,o),S=[{type:"int32",data:[a]}],C=d?[r,i]:[r];return e.runWebGPUProgram(w,C,f,S,x)}const jX={kernelName:wb,backendName:"webgpu",kernelFunc:HX};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let XX=class{constructor(t,e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${e}`,this.dataFormat=e}getUserCode(){return`
      ${Tt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qX(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockSize:i,dataFormat:a}=s,o=r.shape[0],u=a==="NHWC"?r.shape[1]:r.shape[2],h=a==="NHWC"?r.shape[2]:r.shape[3],d=a==="NHWC"?r.shape[3]:r.shape[1],f=u*i,m=h*i,y=d/(i*i),x=a==="NHWC"?[o,f,m,y]:[o,y,f,m],w=[{type:"int32",data:[i]}],S=new XX(x,a);return e.runWebGPUProgram(S,[r],r.dtype,w)}const KX={kernelName:Sb,backendName:"webgpu",kernelFunc:qX};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YX{constructor(t,e,s,r=!1,i=null,a=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=t,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),r&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.addBias=r,this.activation=i,this.hasPreluActivation=a,this.filterHeight=e,this.filterWidth=s,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const t=this.filterWidth*this.filterHeight,e=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],s=this.workgroupSize[1]+this.filterHeight-1,r=this.workgroupSize[0]+this.filterWidth-1;return`
      ${ca(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${r}>, ${s}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${Tt()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${r}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${t<e?`if (wIndex < ${t})`:`for(; wIndex < ${t}; wIndex = wIndex + ${e})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${_l(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DR{constructor(t,e=!1,s=null,r=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=t.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const i=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=At(i),this.dispatch=kt(this.dispatchLayout,i,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),M(t.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=t,this.addBias=e,this.activation=s,this.hasPreluActivation=r,this.shaderKey=`depthwiseVec4_${s}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const t=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,e=this.convInfo.strideHeight,s=this.convInfo.strideWidth;return`
      ${ca(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${Tt("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${e}, ${s}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${t}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${t}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${s} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${_l(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let OR=class{constructor(t,e=!1,s=null,r=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t.dataFormat==="channelsLast",e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=t,this.addBias=e,this.activation=s,this.hasPreluActivation=r,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const t=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${ca(this.activation,this.hasPreluActivation,!1,4)}

      ${Tt("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${t};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${t};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${_l(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QX(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:a,pad:o,dataFormat:u,dilations:h,dimRoundingMode:d}=s,f=ri(u);let m=h;m==null&&(m=[1,1]);const y=vn(r.shape,i.shape,a,m,o,d,!0,f),x=[{type:"int32",data:[y.padInfo.top,y.padInfo.left]},{type:"int32",data:[y.inHeight,y.inWidth]}],w=y.dataFormat==="channelsLast";let S;return!w&&y.inHeight>16&&y.inWidth>16&&y.strideHeight===1&&y.strideWidth===1&&y.dilationWidth===1&&y.dilationHeight===1&&y.inChannels===y.outChannels?S=new YX(y.outShape,y.filterHeight,y.filterWidth):w&&y.outHeight>4&&y.outWidth>4&&y.strideWidth<=2&&y.inChannels===y.outChannels&&y.dilationHeight===1&&y.dilationWidth===1&&y.inChannels%4===0?(S=new DR(y),x.push({type:"int32",data:[S.virtualWidth]})):(S=new OR(y),x.push({type:"int32",data:[y.filterHeight]},{type:"int32",data:[y.filterWidth]},{type:"int32",data:[y.strideHeight,y.strideWidth]},{type:"int32",data:[y.dilationHeight,y.dilationWidth]})),e.runWebGPUProgram(S,[r,i],r.dtype,x)}const ZX={kernelName:Cb,backendName:"webgpu",kernelFunc:QX};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let JX=class{constructor(t){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.filterShape,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${Tt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}},tq=class{constructor(t){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${Tt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eq(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:a,dilations:o,pad:u,dimRoundingMode:h,filterShape:d}=s,f=vn(r.shape,d,a,o,u,h,!0),m=new JX(f),y=[{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"int32",data:[f.inHeight]},{type:"int32",data:[f.inWidth]},{type:"int32",data:[f.batchSize]},{type:"int32",data:[f.outChannels/f.inChannels]}];return e.runWebGPUProgram(m,[r,i],"float32",y)}const nq={kernelName:$b,backendName:"webgpu",kernelFunc:eq};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sq(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{strides:a,dilations:o,pad:u,dimRoundingMode:h,inputShape:d}=s,f=vn(d,i.shape,a,o,u,h,!0),m=new tq(f),y=[{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.filterHeight-1-f.padInfo.top,f.filterWidth-1-f.padInfo.left]},{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"int32",data:[f.outChannels/f.inChannels]}];return e.runWebGPUProgram(m,[r,i],r.dtype,y)}const rq={kernelName:Tb,backendName:"webgpu",kernelFunc:sq};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let iq=class{constructor(t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t,t],this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${Tt("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aq(n){const{inputs:t,backend:e}=n,{x:s}=t,r=[...s.shape,...s.shape],i=ht(s.shape),a=Pt({inputs:{x:s},backend:e,attrs:{shape:[i]}}),o=new iq(i),u=e.runWebGPUProgram(o,[a],a.dtype),h=Pt({inputs:{x:u},backend:e,attrs:{shape:r}});return e.disposeData(a.dataId),e.disposeData(u.dataId),h}const oq={kernelName:kb,backendName:"webgpu",kernelFunc:aq};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let lq=class{constructor(t){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${Tt("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uq(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:a,pad:o,dilations:u}=s,h=vd(r.shape,i.shape,a,o,"NHWC",u),d=[h.padInfo.top,h.padInfo.left],f=[{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[...d]},{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]}],m=new lq(h);return e.runWebGPUProgram(m,[r,i],r.dtype,f)}const cq={kernelName:_b,backendName:"webgpu",kernelFunc:uq};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hq{constructor(t,e){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t.inShape,this.dispatchLayout=At(t.outShape),this.dispatch=kt(this.dispatchLayout,t.outShape,this.workgroupSize),e!=="float32"&&e!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${e} type.`);this.type=e,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${Tt("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${lo("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}class dq{constructor(t,e,s){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t.filterShape,this.dispatchLayout=At(t.outShape),this.dispatch=kt(this.dispatchLayout,t.outShape,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${s} type.`);this.type=s,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${Tt("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${lo("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fq(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i,dy:a}=t,{strides:o,pad:u,dilations:h}=s,d=vd(r.shape,i.shape,o,u,"NHWC",h),f=i.dtype,m=new dq(d,i.shape,f),y=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[ht(d.outShape)]}],x=_s({backend:e,attrs:{shape:i.shape,value:0,dtype:f}});return e.runWebGPUProgram(m,[r,i,a],f,y,x)}const pq={kernelName:vO,backendName:"webgpu",kernelFunc:fq};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mq(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i,dy:a}=t,{strides:o,pad:u,dilations:h}=s,d=vd(r.shape,i.shape,o,u,"NHWC",h),f=r.dtype,m=new hq(d,f),y=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[ht(d.outShape)]}],x=_s({backend:e,attrs:{shape:d.inShape,value:0,dtype:f}});return e.runWebGPUProgram(m,[r,i,a],f,y,x)}const gq={kernelName:bO,backendName:"webgpu",kernelFunc:mq};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yq{constructor(t,e,s){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=Hu.DRAW,this.size=!0,this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=e,this.textureFormat=s,this.shaderKey=`draw_${e}_${s}`}getUserCode(){let t;const e=this.type==="float32"?"value":"value / 255.0";return t=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${e};
        rgba[1] = ${e};
        rgba[2] = ${e};
      } else {
        rgba[d] = ${e};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${Tt("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${t}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xq(n){const{inputs:t,backend:e,attrs:s}=n,{image:r}=t,{canvas:i,options:a}=s,[o,u]=r.shape.slice(0,2),{imageOptions:h}=a||{},d=h?.alpha||1,f=e.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",m=[o,u],y=new yq(m,r.dtype,f);i.width=u,i.height=o;const x="webgpu";let w=i.getContext(x),S;w||(S=new OffscreenCanvas(u,o),w=S.getContext(x));const C=r.shape.length===3?r.shape[2]:1;w.configure({device:e.device,format:f,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const k="int32",E=e.makeTensorInfo(m,k),R=e.tensorMap.get(E.dataId);R.resource=w.getCurrentTexture(),R.external=!0;const A=[{type:"uint32",data:[C]},{type:"float32",data:[d]}];if(e.runWebGPUProgram(y,[r],k,A,E),S){const L=i.getContext("2d");if(!L)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");L.drawImage(S,0,0)}return e.disposeData(E.dataId),r}const bq={kernelName:q_,backendName:"webgpu",kernelFunc:xq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PR=In({opType:qt.MUL,cpuKernelImpl:$j,supportsComplex:!0}),vq={kernelName:x1,backendName:"webgpu",kernelFunc:PR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FR(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:a}=s;return El(r,i,a,"sum",e)}const wq={kernelName:J1,backendName:"webgpu",kernelFunc:FR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sq(n){const{inputs:t,backend:e,attrs:s}=n,{equation:r}=s,i=t,{allDims:a,summedDims:o,idDims:u}=iw(r,i.length);ow(a.length,u,i);const{path:h,steps:d}=lw(o,u),f=d.length;let m=null,y=a.length;const x=[];for(let w=0;w<f;++w){for(const S of d[w]){const{permutationIndices:C,expandDims:k}=aw(y,u[S]);let E;uw(C)?E=i[S]:(E=Ci({inputs:{x:i[S]},backend:e,attrs:{perm:C}}),x.push(E));const R=E.shape.slice();for(let A=0;A<k.length;++A)R.splice(k[A],0,1);Ee(E.shape,R)||(E=Pt({inputs:{x:E},backend:e,attrs:{shape:R}}),x.push(E)),m===null?m=E:(m=PR({inputs:{a:E,b:m},backend:e}),x.push(m))}w<f-1&&(h[w]>=0&&(m=FR({inputs:{x:m},backend:e,attrs:{axis:h[w]-(a.length-y),keepDims:!1}}),x.push(m)),y--)}for(const w of x)w!==m&&e.disposeData(w.dataId);return m}const Cq={kernelName:Eb,backendName:"webgpu",kernelFunc:Sq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $q=pe({opType:Ct.ELU}),Tq={kernelName:Rb,backendName:"webgpu",kernelFunc:$q};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kq=n=>{const{inputs:t,backend:e}=n,{dy:s,y:r}=t,i=new Zp(qt.ELU_DER,s.shape,r.shape);return e.runWebGPUProgram(i,[s,r],s.dtype)},_q={kernelName:K_,backendName:"webgpu",kernelFunc:kq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nq=In({opType:qt.EQUAL,dtype:"bool",cpuKernelImpl:uj}),Eq={kernelName:Ab,backendName:"webgpu",kernelFunc:Nq};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rq=pe({opType:Ct.ERF}),Iq={kernelName:Ib,backendName:"webgpu",kernelFunc:Rq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aq=pe({opType:Ct.EXP,cpuKernelImpl:cj,dtype:"float32"}),Dq={kernelName:Db,backendName:"webgpu",kernelFunc:Aq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g0(n){const{inputs:t,attrs:e,backend:s}=n,{dim:r}=e,{input:i}=t,a=i.shape.length,o=i.shape.slice();let u=r;return r<0&&(M(-(a+1)<=r,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+r+1),o.splice(u,0,1),Pt({inputs:{x:i},backend:s,attrs:{shape:o}})}const Oq={kernelName:Ob,backendName:"webgpu",kernelFunc:g0};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pq=pe({opType:Ct.EXPM1,cpuKernelImpl:hj}),Fq={kernelName:Pb,backendName:"webgpu",kernelFunc:Pq};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let pT=class{constructor(t,e){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=t,this.shaderKey=`fft_${t}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${Tt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LR(n,t,e){const s=e.tensorMap.get(n.dataId),r=ht(n.shape),i=n.shape[n.shape.length-1],a=r/i,o=[],u=Pt({inputs:{x:n},backend:e,attrs:{shape:[a,i]}});o.push(u);const h=u.shape,d=new pT("real",h),f=new pT("imag",h),m=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:h},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:h}],y=t?2*Math.PI:-2*Math.PI,x=t?h[1]:1,w=[{type:"float32",data:[y]},{type:"float32",data:[x]}],S=e.runWebGPUProgram(d,m,"float32",w);o.push(S);const C=e.runWebGPUProgram(f,m,"float32",w);o.push(C);const k=Nl({inputs:{real:S,imag:C},backend:e});o.push(k);const E=Pt({inputs:{x:k},backend:e,attrs:{shape:n.shape}});return o.forEach(R=>e.disposeData(R.dataId)),E}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lq(n){const{inputs:t,backend:e}=n,{input:s}=t;return LR(s,!1,e)}const Mq={kernelName:Fb,backendName:"webgpu",kernelFunc:Lq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let zq=class{constructor(t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${Tt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bq={kernelName:Mb,backendName:"webgpu",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,s=t,r=new zq(e.shape);return s.runWebGPUProgram(r,[e],e.dtype)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vq=pe({opType:Ct.FLOOR,cpuKernelImpl:dj}),Uq={kernelName:zb,backendName:"webgpu",kernelFunc:Vq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wq=In({opType:qt.FLOOR_DIV,cpuKernelImpl:fj,dtype:"int32"}),Gq={kernelName:Bb,backendName:"webgpu",kernelFunc:Wq};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Hq=class{constructor(t,e,s=!1){this.pixelsOpType=Hu.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize,[e,1,1]),this.importVideo=s,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const t=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${Tt("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${t};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jq={kernelName:zp,backendName:"webgpu",kernelFunc:Xq};let Tu,px=tt().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Xq(n){const{inputs:t,backend:e,attrs:s}=n;let{pixels:r}=t;const{numChannels:i}=s;if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const a=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,u=typeof HTMLCanvasElement<"u"&&r instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&r instanceof OffscreenCanvas,h=typeof ImageBitmap<"u"&&r instanceof ImageBitmap,[d,f]=a?[r.videoWidth,r.videoHeight]:[r.width,r.height],m=[f,d,i],y=tt().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&a,x=a||o;if(h||u||x){let k;if(y)k=e.device.importExternalTexture({source:r});else{if(x){const nt=tt().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Tu==null||nt!==px)&&(px=nt,Tu=document.createElement("canvas").getContext("2d",{willReadFrequently:px})),Tu.canvas.width=d,Tu.canvas.height=f,Tu.drawImage(r,0,0,d,f),r=Tu.canvas}const U=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,Y=e.textureManager.acquireTexture(m[1],m[0],"rgba8unorm",U);e.queue.copyExternalImageToTexture({source:r},{texture:Y},[m[1],m[0]]),k=Y}const E=ht(m),R=cn(m),A=new Hq(m,i,y),L=[{type:"uint32",data:[E]},{type:"uint32",data:[i]},{type:"uint32",data:[...R]}],V=e.makeTensorInfo([f,d],"int32"),B=e.tensorMap.get(V.dataId);B.resource=k;const z=e.runWebGPUProgram(A,[V],"int32",L);return e.disposeData(V.dataId),z}const w=r.data;let S=w;if(i!=null&&i!==4){S=new Uint8Array(r.width*r.height*i);const k=w.length;let E=0;for(let R=0;R<k;R++)R%4<i&&(S[E++]=w[R])}const C=e.makeTensorInfo(m,"int32",new Int32Array(S));return e.uploadToGPU(C.dataId),C}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let qq=class{constructor(t,e,s,r,i){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],ne(t,e),ne(t,s),this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),r!=null&&(ne(t,r),this.variableNames.push("offset")),i!=null&&(ne(t,i),this.variableNames.push("scale")),this.offsetShape=r,this.scaleShape=i,this.shaderKey="batchNorm"}getUserCode(){let t="0.0";this.offsetShape!=null&&(t="getOffsetByOutputIndex(index)");let e="1.0";return this.scaleShape!=null&&(e="getScaleByOutputIndex(index)"),`
      ${Tt("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${t};
          let scaleValue = ${e};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kq={kernelName:Vb,backendName:"webgpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s,scale:r,offset:i,mean:a,variance:o}=n,{varianceEpsilon:u}=t,h=e,d=[s,a,o];let f=null;i!=null&&(f=i.shape,d.push(i));let m=null;r!=null&&(m=r.shape,d.push(r));const y=new qq(s.shape,a.shape,o.shape,f,m),x=[{type:"float32",data:[u]}];return h.runWebGPUProgram(y,d,s.dtype,x)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yq(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=t,{strides:u,pad:h,dataFormat:d,dilations:f,dimRoundingMode:m,activation:y,leakyreluAlpha:x}=s,w=ri(d),S=vn(r.shape,i.shape,u,f,h,m,!1,w);return IR({x:r,filter:i,convInfo:S,backend:e,bias:a,preluActivationWeights:o,leakyreluAlpha:x,activation:y})}const Qq={kernelName:Vp,backendName:"webgpu",kernelFunc:Yq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zq(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=t,{strides:u,pad:h,dilations:d,dimRoundingMode:f,activation:m,leakyreluAlpha:y}=s;let x=d;x==null&&(x=[1,1]),M(ps(u,x),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${x}'`);const w=vn(r.shape,i.shape,u,x,h,f,!0),S=[r,i],C=a!=null,k=o!=null;C&&S.push(a),k&&S.push(o);const E=[{type:"int32",data:[w.padInfo.top,w.padInfo.left]},{type:"int32",data:[w.inHeight,w.inWidth]}];let R;return w.outHeight>4&&w.outWidth>4&&w.strideWidth<=2&&w.inChannels===w.outChannels&&w.dilationHeight===1&&w.dilationWidth===1&&w.inChannels%4===0?(R=new DR(w,C,m,k),E.push({type:"int32",data:[R.virtualWidth]})):(R=new OR(w,C,m,k),E.push({type:"int32",data:[w.filterHeight]},{type:"int32",data:[w.filterWidth]},{type:"int32",data:[w.strideHeight,w.strideWidth]},{type:"int32",data:[w.dilationHeight,w.dilationWidth]})),m==="leakyrelu"&&(E.push({type:"float32",data:[y]}),R.uniforms+=" alpha : f32,"),e.runWebGPUProgram(R,S,"float32",E)}const Jq={kernelName:Up,backendName:"webgpu",kernelFunc:Zq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tK=class{constructor(t,e){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${t}`,this.sliceDim=t,this.uniforms=`sliceDim : i32, strides : ${mn(t)},`}getUserCode(){let t;return this.sliceDim>1?t="uniforms.strides[j]":t="uniforms.strides",`
      ${Tt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${t};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eK(n){const{inputs:t,backend:e}=n,{params:s,indices:r}=t,i=r.shape,a=i[i.length-1],o=ht(s.shape),[u,h,d,f]=zv(s,r),m=Pt({inputs:{x:r},backend:e,attrs:{shape:[h,a]}}),y=Pt({inputs:{x:s},backend:e,attrs:{shape:[ht(s.shape)/d,d]}});if(e.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const k=e.readSync(r.dataId),E=e.bufferSync(s),R=pj(k,E,s.dtype,h,a,d,f,s.shape,o);return e.makeTensorInfo(u,s.dtype,R.values)}const x=new tK(a,[h,d]),w=[{type:"int32",data:[a]},{type:"int32",data:f}],S=e.runWebGPUProgram(x,[y,m],y.dtype,w),C=Pt({inputs:{x:S},backend:e,attrs:{shape:u}});return e.disposeData(m.dataId),e.disposeData(y.dataId),e.disposeData(S.dataId),C}const nK={kernelName:Wb,backendName:"webgpu",kernelFunc:eK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let sK=class{constructor(t,e){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.slice(),this.aShape=t,this.outputShape=e,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const t=rK(this.aShape);return`
      ${Tt("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${t}));
        }
      }
    `}};function rK(n){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],e=[];for(let s=0;s<n.length;s++)s===2?e.push("indexZ"):e.push(`${t[s]}`);return e.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MR(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,indices:i}=t,{axis:a,batchDims:o}=s,u=Qe(a,r.shape)[0],h=dw(r,i,u,o),d=ht(i.shape),f=[],m=Pt({inputs:{x:r},backend:e,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),y=Pt({inputs:{x:i},backend:e,attrs:{shape:[h.batchSize,d/h.batchSize]}});f.push(m),f.push(y);const x=[h.batchSize,h.outerSize,d/h.batchSize,h.sliceSize];if(e.shouldExecuteOnCPU([r,i])){const E=e.tensorMap.get(y.dataId).values,R=Re(y.shape,y.dtype,E),L=e.tensorMap.get(m.dataId).values,V=Re(m.shape,m.dtype,L),B=mj(V,R,x);return f.forEach(z=>e.disposeData(z.dataId)),e.makeTensorInfo(h.outputShape,B.dtype,B.values)}const w=new sK(m.shape,x),S=e.runWebGPUProgram(w,[m,y],m.dtype);f.push(S);const C=Pt({inputs:{x:S},backend:e,attrs:{shape:h.outputShape}});return f.forEach(k=>e.disposeData(k.dataId)),C}const iK={kernelName:Ub,backendName:"webgpu",kernelFunc:MR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aK=In({opType:qt.GREATER,cpuKernelImpl:yj,dtype:"bool"}),oK={kernelName:Gb,backendName:"webgpu",kernelFunc:aK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lK=In({opType:qt.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:gj}),uK={kernelName:Hb,backendName:"webgpu",kernelFunc:lK};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cK(n){const{inputs:t,backend:e}=n,{input:s}=t;return LR(s,!0,e)}const hK={kernelName:jb,backendName:"webgpu",kernelFunc:cK};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dK=pe({opType:Ct.IS_FINITE,dtype:"bool"}),fK={kernelName:qb,backendName:"webgpu",kernelFunc:dK};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pK=pe({opType:Ct.IS_INF,dtype:"bool"}),mK={kernelName:Kb,backendName:"webgpu",kernelFunc:pK};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gK=pe({opType:Ct.IS_NAN,dtype:"bool"}),yK={kernelName:Yb,backendName:"webgpu",kernelFunc:gK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xK(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{alpha:i}=s,a=[{type:"float32",data:[i]}],o=new ec(r.shape,Ct.LEAKYRELU,"alpha : f32,");return e.runWebGPUProgram(o,[r],"float32",a)}const bK={kernelName:Qb,backendName:"webgpu",kernelFunc:xK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vK=In({opType:qt.LESS,dtype:"bool",cpuKernelImpl:bj}),wK={kernelName:Zb,backendName:"webgpu",kernelFunc:vK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SK=In({opType:qt.LESS_EQUAL,dtype:"bool",cpuKernelImpl:xj}),CK={kernelName:Jb,backendName:"webgpu",kernelFunc:SK};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $K{constructor(t){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t],this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${Tt("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TK(n){const{backend:t,attrs:e}=n,{start:s,stop:r,num:i}=e,a=(r-s)/(i-1),o=new $K(i),u=[{type:"float32",data:[s]},{type:"float32",data:[a]}];return t.runWebGPUProgram(o,[],"float32",u)}const kK={kernelName:t1,backendName:"webgpu",kernelFunc:TK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _K=pe({opType:Ct.LOG,cpuKernelImpl:vj}),NK={kernelName:e1,backendName:"webgpu",kernelFunc:_K};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EK=pe({opType:Ct.LOG1P}),RK={kernelName:n1,backendName:"webgpu",kernelFunc:EK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IK=In({opType:qt.LOGICAL_AND,dtype:"bool"}),AK={kernelName:s1,backendName:"webgpu",kernelFunc:IK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DK=pe({opType:Ct.LOGICAL_NOT}),OK={kernelName:r1,backendName:"webgpu",kernelFunc:DK};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PK=In({opType:qt.LOGICAL_OR}),FK={kernelName:i1,backendName:"webgpu",kernelFunc:PK};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zR=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;let LK=class{constructor(t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${Tt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${zR}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}};class MK{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,M(e<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${e}`),this.outputShape=t,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=kt(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${Tt()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${zR}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zK(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{depthRadius:i,bias:a,alpha:o,beta:u}=s;let h;i>16?h=new LK(r.shape):h=new MK(r.shape,i);const d=[{type:"int32",data:[i]},{type:"float32",data:[a]},{type:"float32",data:[o]},{type:"float32",data:[u]}];return e.runWebGPUProgram(h,[r],r.dtype,d)}const BK={kernelName:a1,backendName:"webgpu",kernelFunc:zK};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let VK=class{constructor(t){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${Tt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UK(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,y:i,dy:a}=t,{depthRadius:o,bias:u,alpha:h,beta:d}=s,f=new VK(r.shape),m=[{type:"int32",data:[o]},{type:"float32",data:[u]},{type:"float32",data:[h]},{type:"float32",data:[d]}];return e.runWebGPUProgram(f,[r,i,a],r.dtype,m)}const WK={kernelName:Y_,backendName:"webgpu",kernelFunc:UK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GK=In({opType:qt.MAX,cpuKernelImpl:Sj}),HK={kernelName:l1,backendName:"webgpu",kernelFunc:GK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jK(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:i,strides:a,pad:o,dimRoundingMode:u}=s,d=Mr(r.shape,i,a,1,o,u);return _R(r,d,"max",e)}const XK={kernelName:u1,backendName:"webgpu",kernelFunc:jK};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qK(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:i,strides:a,pad:o,dataFormat:u,dimRoundingMode:h}=s,d=[1,1,1],f=la(r.shape,i,a,d,o,h,u),m=new gw(f,"max"),y=[{type:"int32",data:[f.strideDepth,f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.front,f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inDepth,f.inHeight,f.inWidth]},{type:"int32",data:[f.effectiveFilterDepth,f.effectiveFilterHeight,f.effectiveFilterWidth]}];return e.runWebGPUProgram(m,[r],r.dtype,y)}const KK={kernelName:c1,backendName:"webgpu",kernelFunc:qK};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let YK=class{constructor(t){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${Tt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}},QK=class{constructor(t){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${Tt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZK(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,a=i,{filterSize:o,strides:u,pad:h,dimRoundingMode:d}=s,f=[1,1,1],m=la(a.shape,o,u,f,h,d),y=new gw(m,"max",!0);let x=[{type:"int32",data:[m.strideDepth,m.strideHeight,m.strideWidth]},{type:"int32",data:[m.padInfo.front,m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.inDepth,m.inHeight,m.inWidth]},{type:"int32",data:[m.effectiveFilterDepth,m.effectiveFilterHeight,m.effectiveFilterWidth]}];const w=e.runWebGPUProgram(y,[a],"int32",x),S=new QK(m);x=[{type:"int32",data:[m.strideDepth,m.strideHeight,m.strideWidth]},{type:"int32",data:[m.effectiveFilterDepth-1-m.padInfo.front,m.effectiveFilterHeight-1-m.padInfo.top,m.effectiveFilterWidth-1-m.padInfo.left]},{type:"int32",data:[m.effectiveFilterDepth,m.effectiveFilterHeight,m.effectiveFilterWidth]},{type:"int32",data:[m.outDepth]},{type:"int32",data:[m.outHeight]},{type:"int32",data:[m.outWidth]}];const C=e.runWebGPUProgram(S,[r,w],a.dtype,x);return e.disposeData(w.dataId),C}const JK={kernelName:Z_,backendName:"webgpu",kernelFunc:ZK};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t7(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i,output:a}=t,o=i;xR([i,a],"maxPoolGrad");const{filterSize:u,strides:h,pad:d,dimRoundingMode:f}=s,m=Mr(o.shape,u,h,1,d,f),y=new id(m,"max",!0);let x=[{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.dilationHeight,m.dilationWidth]},{type:"int32",data:[m.inHeight,m.inWidth]},{type:"int32",data:[m.effectiveFilterHeight,m.effectiveFilterWidth]}];const w=e.runWebGPUProgram(y,[o],"int32",x),S=new YK(m);x=[{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.effectiveFilterHeight-1-m.padInfo.top,m.effectiveFilterWidth-1-m.padInfo.left]},{type:"int32",data:[m.dilationHeight,m.dilationWidth]},{type:"int32",data:[m.effectiveFilterHeight,m.effectiveFilterWidth]},{type:"int32",data:[m.outHeight]},{type:"int32",data:[m.outWidth]}];const C=e.runWebGPUProgram(S,[r,w],o.dtype,x);return e.disposeData(w.dataId),C}const e7={kernelName:Q_,backendName:"webgpu",kernelFunc:t7};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n7(n){const{inputs:t,backend:e,attrs:s}=n,{filterSize:r,strides:i,pad:a,includeBatchInIndex:o}=s,{x:u}=t;M(u.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${u.shape.length}.`);const h=[1,1];M(ps(i,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const d=Mr(u.shape,r,i,h,a),f=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]}];let m=new id(d,"max",!1);const y=e.runWebGPUProgram(m,[u],u.dtype,f);m=new id(d,"max",!0,!0,o);const x=e.runWebGPUProgram(m,[u],"int32",f);return[y,x]}const s7={kernelName:h1,backendName:"webgpu",kernelFunc:n7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r7(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:a}=s;return El(r,i,a,"min",e)}const i7={kernelName:f1,backendName:"webgpu",kernelFunc:r7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a7=In({opType:qt.MIN,cpuKernelImpl:Cj}),o7={kernelName:p1,backendName:"webgpu",kernelFunc:a7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let l7=class{constructor(t,e,s){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.map((r,i)=>r[0]+t[i]+r[1]),this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=t,e.map((r,i)=>{this.uniforms+=` pad${i} : vec2<i32>,`}),this.offset=s==="reflect"?0:1,this.shaderKey=`mirrorPad_${s}`}getUserCode(){const t=this.xShape.length,e=this.xShape.map((h,d)=>`uniforms.pad${d}[0]`).join(","),s=this.xShape.map((h,d)=>`uniforms.pad${d}[0] + uniforms.xShape${t>1?`[${d}]`:""}`).join(","),r=t===1?"start":"start[i]",i=t===1?"end":"end[i]",a=t===1?"outC":"outC[i]",o=mn(t),u=t>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,t):"coords";return`
      ${Tt("index")} {
        if (index < uniforms.size) {
          let start = ${o}(${e});
          let end = ${o}(${s});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${t}; i = i + 1) {
            if (${a} < ${r}) {
              ${a} = ${r} * 2 - ${a} - ${this.offset};
            } else if(${a} >= ${i}) {
              ${a} = (${i} - 1) * 2 - ${a} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${u}));
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u7={kernelName:m1,backendName:"webgpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{paddings:r,mode:i}=t,a=e,o=r.map(d=>({type:"int32",data:[d[0],d[1]]})),u=new l7(s.shape,r,i);return a.runWebGPUProgram(u,[s],s.dtype,o)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c7=In({opType:qt.MOD}),h7={kernelName:g1,backendName:"webgpu",kernelFunc:c7};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let d7=class{constructor(t,e){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t,e],this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Tt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class f7{constructor(t){this.variableNames=["logits"],this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${Tt("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BR(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{dim:i}=s,a=Pt({inputs:{x:r},backend:e,attrs:{shape:[ht(r.shape)/r.shape[i],r.shape[i]]}}),o=new f7(a.shape),u=e.runWebGPUProgram(o,[a],r.dtype),h=Pt({inputs:{x:u},backend:e,attrs:{shape:r.shape}});return e.disposeData(a.dataId),e.disposeData(u.dataId),h}const p7={kernelName:nv,backendName:"webgpu",kernelFunc:BR};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m7(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{numSamples:i,seed:a,normalized:o}=s,u=o?r:BR({inputs:{logits:r},backend:e,attrs:{dim:r.shape.length-1}}),h=u.shape[0],d=u.shape[1],f=new d7(h,i),m=[{type:"float32",data:[a]},{type:"int32",data:[d]}],y=e.runWebGPUProgram(f,[u],"int32",m);return o||e.disposeData(u.dataId),y}const g7={kernelName:y1,backendName:"webgpu",kernelFunc:m7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y7(n){const{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])){const i=e.tensorMap.get(s.dataId),[a,o]=Tj(i.values,s.shape,s.dtype);return e.makeTensorInfo(o,s.dtype,a)}const r=new ec(s.shape,Ct.NEG);return e.runWebGPUProgram(r,[s],s.dtype)}const x7={kernelName:b1,backendName:"webgpu",kernelFunc:y7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b7(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u}=s,h=e.readSync(r.dataId),d=e.readSync(i.dataId),{selectedIndices:f}=Dv(h,d,a,o,u);return e.makeTensorInfo([f.length],"int32",new Int32Array(f))}const v7={kernelName:w1,backendName:"webgpu",kernelFunc:b7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w7(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u,softNmsSigma:h}=s,d=e.readSync(r.dataId),f=e.readSync(i.dataId),m=a,y=o,x=u,w=h,{selectedIndices:S,selectedScores:C}=Ov(d,f,m,y,x,w);return[e.makeTensorInfo([S.length],"int32",new Int32Array(S)),e.makeTensorInfo([C.length],"float32",new Float32Array(C))]}const S7={kernelName:S1,backendName:"webgpu",kernelFunc:w7};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let C7=class{constructor(t,e){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t,e],this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${Tt("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $7(n){const{inputs:t,backend:e,attrs:s}=n,{indices:r}=t,{dtype:i,depth:a,onValue:o,offValue:u}=s,h=ht(r.shape),d=new C7(h,a),f=Pt({inputs:{x:r},backend:e,attrs:{shape:[h]}}),m=[{type:"float32",data:[o]},{type:"float32",data:[u]}],y=e.runWebGPUProgram(d,[f],i,m);e.disposeData(f.dataId);const x=[...r.shape,a],w=Pt({inputs:{x:y},backend:e,attrs:{shape:x}});return e.disposeData(y.dataId),w}const T7={kernelName:$1,backendName:"webgpu",kernelFunc:$7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function em(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="complex64"){const r=kd({inputs:{input:s},backend:e}),i=em({inputs:{x:r},backend:e}),a=Pm({inputs:{input:s},backend:e}),o=em({inputs:{x:a},backend:e}),u=Nl({inputs:{real:i,imag:o},backend:e});return e.disposeData(r.dataId),e.disposeData(i.dataId),e.disposeData(a.dataId),e.disposeData(o.dataId),u}else return _s({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:e})}const k7={kernelName:gv,backendName:"webgpu",kernelFunc:em};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VR(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=kd({inputs:{input:s},backend:e}),i=VR({inputs:{x:r},backend:e}),a=Pm({inputs:{input:s},backend:e}),o=em({inputs:{x:a},backend:e}),u=Nl({inputs:{real:i,imag:o},backend:e});return e.disposeData(r.dataId),e.disposeData(i.dataId),e.disposeData(a.dataId),e.disposeData(o.dataId),u}else return _s({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:e})}const _7={kernelName:C1,backendName:"webgpu",kernelFunc:VR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N7(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s;if(t.length===1)return g0({inputs:{input:t[0]},backend:e,attrs:{dim:r}});const i=t[0].shape,a=t[0].dtype;t.forEach(d=>{Ks(i,d.shape,"All tensors passed to stack must have matching shapes"),M(a===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],u=t.map(d=>{const f=g0({inputs:{input:d},backend:e,attrs:{dim:r}});return o.push(f),f}),h=RR({inputs:u,backend:e,attrs:{axis:r}});return o.forEach(d=>e.disposeData(d.dataId)),h}const E7={kernelName:T1,backendName:"webgpu",kernelFunc:N7};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UR(n,t=!1){const e=n.length,s=mn(e),r=n.map((f,m)=>`uniforms.pad${m}[0]`).join(","),i=n.map((f,m)=>`uniforms.pad${m}[0] + uniforms.xShape${e>1?`[${m}]`:""}`).join(","),a=e>1?`${s}(${r})`:`${r}`,o=e>1?`${s}(${i})`:`${i}`,u=e>1?"any(paddedCoords < start)":"paddedCoords < start",h=e>1?"any(paddedCoords >= end)":"paddedCoords >= end",d=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
        let start = ${a};
        let end = ${o};
        if (${u} || ${h}) {
          setOutputAtIndex(index, ${t?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${d}));
        }
  `}let R7=class{constructor(t,e){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.map((s,r)=>s[0]+t[r]+s[1]),this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),e.map((s,r)=>{this.uniforms+=` pad${r} : vec2<i32>,`}),this.xShape=t,this.shaderKey="pad"}getUserCode(){return`
      ${Tt("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${UR(this.xShape)}
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I7=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{paddings:i,constantValue:a}=s;if(i.every(h=>Ee(h,[0,0])))return Xs({inputs:{x:r},backend:e});if(ht(r.shape)===0){const h=i.map((d,f)=>d[0]+r.shape[f]+d[1]);return _s({backend:e,attrs:{shape:h,value:a,dtype:r.dtype}})}const o=[{type:"float32",data:[a]}];i.map(h=>o.push({type:"int32",data:[h[0],h[1]]}));const u=new R7(r.shape,i);return e.runWebGPUProgram(u,[r],r.dtype,o)},A7={kernelName:k1,backendName:"webgpu",kernelFunc:I7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D7=In({opType:qt.POW}),O7={kernelName:_1,backendName:"webgpu",kernelFunc:D7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P7(n){const{inputs:t,backend:e}=n,{x:s,alpha:r}=t,i=new Zp(qt.PRELU,s.shape,r.shape);return e.runWebGPUProgram(i,[s,r],"float32")}const F7={kernelName:N1,backendName:"webgpu",kernelFunc:P7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L7(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:a}=s;return El(r,i,a,"prod",e)}const M7={kernelName:E1,backendName:"webgpu",kernelFunc:L7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z7=n=>{const{backend:t,attrs:e}=n,{start:s,stop:r,step:i,dtype:a}=e,o=Nj(s,r,i,a);return t.makeTensorInfo([o.length],a,o)},B7={kernelName:R1,backendName:"webgpu",kernelFunc:z7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V7=In({opType:qt.DIV}),U7={kernelName:Nb,backendName:"webgpu",kernelFunc:V7};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W7=pe({opType:Ct.RECIPROCAL}),G7={kernelName:A1,backendName:"webgpu",kernelFunc:W7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H7=pe({opType:Ct.RELU}),j7={kernelName:D1,backendName:"webgpu",kernelFunc:H7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X7=pe({opType:Ct.RELU6}),q7={kernelName:L1,backendName:"webgpu",kernelFunc:X7};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let K7=class{constructor(t,e,s){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t[0],e,s,t[3]],this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${Tt("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y7(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:i,size:a,halfPixelCenters:o}=s,[u,h]=a,d=i&&u>1?1:0,f=i&&h>1?1:0,y=[{type:"float32",data:[d,f]},{type:"float32",data:[o?.5:0]}],x=new K7(r.shape,u,h);return e.runWebGPUProgram(x,[r],"float32",y)}const Q7={kernelName:F1,backendName:"webgpu",kernelFunc:Y7};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z7=class{constructor(t,e){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=e,this.shaderKey=`resizeBilinearBackprop_${e}`}getUserCode(){return`
      ${Tt("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J7(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:i}=t,{alignCorners:a}=s,[,o,u]=r.shape,[,h,d]=i.shape,f=[a&&h>1?o-1:o,a&&d>1?u-1:u],m=[a&&h>1?h-1:h,a&&d>1?d-1:d],y=f[0]/m[0],x=f[1]/m[1],w=1/y,S=1/x,C=Math.ceil(w)*2+2,k=Math.ceil(S)*2+2,E=new Z7(r.shape,a),R=[{type:"int32",data:f},{type:"int32",data:m},{type:"float32",data:[y]},{type:"float32",data:[x]},{type:"float32",data:[w]},{type:"float32",data:[S]},{type:"int32",data:[C]},{type:"int32",data:[k]}];return e.runWebGPUProgram(E,[i],i.dtype,R)}const tY={kernelName:rN,backendName:"webgpu",kernelFunc:J7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let eY=class{constructor(t,e,s,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t[0],e,s,t[3]],this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=r,this.shaderKey=`resizeNearest_${r}`}getUserCode(){let t;return this.halfPixelCenters?t="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":t="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${Tt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${t};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nY(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:i,halfPixelCenters:a,size:o}=s,[u,h]=o,d=i&&u>1?1:0,f=i&&h>1?1:0,y=[{type:"float32",data:[d,f]},{type:"float32",data:[i?.5:0]}],x=new eY(r.shape,u,h,a);return e.runWebGPUProgram(x,[r],r.dtype,y)}const sY={kernelName:P1,backendName:"webgpu",kernelFunc:nY};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rY=class{constructor(t,e){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=e,this.shaderKey=`resizeNearestNeigborBackprop_${e}`}getUserCode(){return`
      ${Tt("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iY(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:i}=t,{alignCorners:a}=s,[,o,u]=r.shape,[,h,d]=i.shape,f=[a&&h>1?o-1:o,a&&d>1?u-1:u],m=[a&&h>1?h-1:h,a&&d>1?d-1:d],y=f[0]/m[0],x=f[1]/m[1],w=1/y,S=1/x,C=Math.ceil(w)*2+2,k=Math.ceil(S)*2+2,E=new rY(r.shape,a),R=[{type:"int32",data:f},{type:"int32",data:m},{type:"float32",data:[w]},{type:"float32",data:[S]},{type:"int32",data:[C]},{type:"int32",data:[k]}];return e.runWebGPUProgram(E,[i],i.dtype,R)}const aY={kernelName:sN,backendName:"webgpu",kernelFunc:iY};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let oY=class{constructor(t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${Tt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lY(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dims:i}=s,a=r.shape.length;if(a===0)return Xs({inputs:{x:r},backend:e});const o=r.shape,u=[1,1,1,1];o.forEach((S,C)=>{const k=C+4-a;u[k]=S});const h=Qe(i,r.shape),d=[0,0,0,0];h.forEach(S=>{const C=S+4-a;d[C]=1});const f=[{type:"int32",data:d}],m=Pt({inputs:{x:r},backend:e,attrs:{shape:u}}),y=new oY(u),x=e.runWebGPUProgram(y,[m],m.dtype,f);e.disposeData(m.dataId);const w=Pt({inputs:{x},backend:e,attrs:{shape:o}});return e.disposeData(x.dataId),w}const uY={kernelName:M1,backendName:"webgpu",kernelFunc:lY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let cY=class{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=t,typeof e=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${Tt("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hY={kernelName:xv,backendName:"webgpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:r,fillValue:i,center:a}=t,o=e,u=new cY(s.shape,i),[h,d]=qv(a,s.shape[1],s.shape[2]),f=[{type:"float32",data:[h]},{type:"float32",data:[d]},{type:"float32",data:[Math.sin(r)]},{type:"float32",data:[Math.cos(r)]}];return typeof i=="number"?f.push({type:"float32",data:[Number.parseFloat(i.toFixed(2))]}):f.push({type:"float32",data:i}),o.runWebGPUProgram(u,[s],s.dtype,f)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dY=pe({opType:Ct.ROUND}),fY={kernelName:z1,backendName:"webgpu",kernelFunc:dY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pY=pe({opType:Ct.RSQRT,cpuKernelImpl:Ej}),mY={kernelName:B1,backendName:"webgpu",kernelFunc:pY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Uh=class{constructor(t,e,s,r,i,a,o,u=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=a,this.type=o,this.sumDupeIndices=u,this.dispatchLayout=At(t),this.dispatch=kt(this.dispatchLayout,t,this.workgroupSize),this.sliceDimGreaterThanOne=e>1,this.shaderKey=`scatter_${s}_${r}_${this.sliceDimGreaterThanOne}_${o}_${u}_${i.length}`;const h=mn(i.length);this.uniforms=`sliceDim : i32, strides: ${h}, updatesSize: i32,`,this.updatesRank=r,this.indicesRank=s}getUserCode(){let t="";this.indicesRank===1?t="coords[0]":this.indicesRank===2&&(t="coords[0], j");const e=`getIndices(${t})`,s=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let r="",i="";this.dispatchLayout.x.length===1?(r="flattenedIndex",i=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(r="vec2<i32>(flattenedIndex, coords[1])",i=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const o=`getUpdates(${Array.from({length:this.updatesRank},(h,d)=>`coords[${d}]`).join(", ")})`;return`
    ${i}
      ${Tt("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${e}));
            flattenedIndex = flattenedIndex + indexInside * ${s};
          }
          let updateValue =
              ${el(this.type)}(${o});
          let flatIndex = getOutputIndexFromCoords(${r});

          ${this.sumDupeIndices?lo("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gY(n){const{inputs:t,backend:e,attrs:s}=n,{indices:r,updates:i}=t,{shape:a}=s,{sliceRank:o,numUpdates:u,sliceSize:h,strides:d,outputSize:f}=$l(i,r,a),m=[f/h,h];if(f===0)return e.makeTensorInfo(a,r.dtype);const y=Pt({inputs:{x:r},backend:e,attrs:{shape:[u,o]}}),x=Pt({inputs:{x:i},backend:e,attrs:{shape:[u,h]}}),w=x.dtype,S=_s({backend:e,attrs:{shape:m,value:0,dtype:w}}),C=ht(x.shape),k=[{type:"int32",data:[o]},{type:"int32",data:d},{type:"int32",data:[C]}],E=new Uh(x.shape,o,y.shape.length,x.shape.length,d,m,w),R=e.runWebGPUProgram(E,[x,y],w,k,S),A=Pt({inputs:{x:R},backend:e,attrs:{shape:a}});return e.disposeData(y.dataId),e.disposeData(x.dataId),e.disposeData(R.dataId),A}const yY={kernelName:V1,backendName:"webgpu",kernelFunc:gY};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let xY=class{constructor(t,e){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=e,this.shaderKey=`search_sorted_${e}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${Tt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bY(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:r,values:i}=t,{side:a}=s,o=new xY([i.shape[0],i.shape[1]],a),u=[{type:"int32",data:[r.shape[1]]}];return e.runWebGPUProgram(o,[r,i],"int32",u)}const vY={kernelName:W1,backendName:"webgpu",kernelFunc:bY};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let wY=class{constructor(t,e,s){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=t,this.rank=s,this.shaderKey="select"}getUserCode(){let t,e;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)e="resRC",t="resRC";else{const r=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],a=[];for(let o=0;o<this.outputShape.length;o++)a.push(`${r[o]}`),o<this.cRank&&i.push(`${r[o]}`);t=i.join(),e=a.join()}return`
      ${Tt("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${t});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${e}));
          } else {
            setOutputAtIndex(index, getB(${e}));
          }
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SY(n){const{inputs:t,backend:e}=n,{condition:s,t:r,e:i}=t,a=new wY(s.shape.length,r.shape,r.shape.length);return e.runWebGPUProgram(a,[s,r,i],Ns(r.dtype,i.dtype))}const CY={kernelName:G1,backendName:"webgpu",kernelFunc:SY};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Y=pe({opType:Ct.SELU}),TY={kernelName:H1,backendName:"webgpu",kernelFunc:$Y};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kY=pe({opType:Ct.SIGMOID}),_Y={kernelName:Y1,backendName:"webgpu",kernelFunc:kY};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NY=pe({opType:Ct.SIGN}),EY={kernelName:K1,backendName:"webgpu",kernelFunc:NY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RY=pe({opType:Ct.SIN}),IY={kernelName:X1,backendName:"webgpu",kernelFunc:RY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AY=pe({opType:Ct.SINH}),DY={kernelName:q1,backendName:"webgpu",kernelFunc:AY};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OY=pe({opType:Ct.SOFTPLUS}),PY={kernelName:Q1,backendName:"webgpu",kernelFunc:OY};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FY{constructor(t,e,s,r,i,a){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const o=new Array(r.length);for(let u=0;u<o.length;u++)o[u]=r[i[u]];this.outputShape=o,this.newDim=i,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=t,this.paddedXShape=e,this.uniforms+=`reshapedPaddedXShape : ${mn(r.length)}, paddedXShapeStrides : ${mn(a)}, `,s.map((u,h)=>{this.uniforms+=` pad${h} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${i}`}getUserCode(){const t=mn(this.outputShape.length),e=CR(this.newDim);return`
      ${Ep(this.paddedXShape,"PaddedX")}
      ${Tt("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${t}(${e}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${UR(this.xShape,!0)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LY=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:i,paddings:a}=s;M(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const o=i.reduce((k,E)=>k*E),u=[[0,0]];u.push(...a);for(let k=1+i.length;k<r.shape.length;++k)u.push([0,0]);const h=u.map((k,E)=>k[0]+r.shape[E]+k[1]),d=Cd(h,i,o,!1),f=$d(d.length,i.length,!1),m=Td(h,i,o,!1),y=cn(h),x=new FY(r.shape,h,u,d,f,y.length),w=[{type:"int32",data:d},{type:"int32",data:y}];u.map(k=>w.push({type:"int32",data:[k[0],k[1]]}));const S=e.runWebGPUProgram(x,[r],r.dtype,w),C=Pt({inputs:{x:S},backend:e,attrs:{shape:m}});return e.disposeData(S.dataId),C},MY={kernelName:tv,backendName:"webgpu",kernelFunc:LY};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zY{constructor(t,e,s){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.type=s,this.dispatchLayout=At([e]),this.dispatch=kt(this.dispatchLayout,[e],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${Tt("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${lo("&result[outIndex]","value",this.type)}
      }
    }
  `}}class BY{constructor(t,e){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[t],this.dispatchLayout=At(e),this.dispatch=kt(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${Tt("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${lo("&result[segmentId]","1","int32")}
      }
    }
  `}}class VY{constructor(t,e){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.type=e,this.dispatchLayout=At(t),this.dispatch=kt(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${Tt("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WR(n,t,e,s=!1,r){const a=ht(n.shape)/n.shape[0],o=n.dtype,u=ht(t.shape),h=r.readSync(e.dataId),f=u>0?h[u-1]+1:0;let m;const y=n.shape.slice();y[0]=f;const x=u*a,w=_s({backend:r,attrs:{shape:y,value:0,dtype:o}});m=new zY(y,x,o);let S=[{type:"int32",data:[a]},{type:"int32",data:[x]}];const C=r.runWebGPUProgram(m,[n,t,e],o,S,w);if(s)return C;const k=_s({backend:r,attrs:{shape:[f],value:0,dtype:"int32"}});m=new BY(f,e.shape);const E=r.runWebGPUProgram(m,[e],"int32",null,k),R=_s({backend:r,attrs:{shape:y,value:0,dtype:o}});m=new VY(y,o),S=[{type:"int32",data:[a]}];const A=r.runWebGPUProgram(m,[C,E],o,S,R);return r.disposeData(C.dataId),r.disposeData(E.dataId),A}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UY(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:i}=t;return WR(s,r,i,!1,e)}const WY={kernelName:sv,backendName:"webgpu",kernelFunc:UY};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GY(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:i}=t;return WR(s,r,i,!0,e)}const HY={kernelName:rv,backendName:"webgpu",kernelFunc:GY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let jY=class{constructor(t,e){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(t.length);for(let r=0;r<s.length;r++)s[r]=t[r]*e[r];this.outputShape=s,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const t=XY(this.rank,"uniforms.");return`
      ${Tt("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${t}));
        }
      }
    `}};function XY(n,t=""){if(n>=5)throw Error(`Tile for rank ${n} is not yet supported`);if(n===1)return`(resRC % ${t}aShape)`;const e=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n;r++)s.push(`(${e[r]} % ${t}aShape[${r}])`);return s.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yw(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reps:i}=s;if(e.shouldExecuteOnCPU([r])||r.dtype==="string"||r.shape.length>=5){const u=e.readSync(r.dataId),h=r.dtype==="string"?u.map(m=>ea(m)):u,d=Re(r.shape,r.dtype,h),f=Fj(d,i);return e.makeTensorInfo(f.shape,f.dtype,f.values)}const a=new jY(r.shape,i);return e.runWebGPUProgram(a,[r],r.dtype)}const qY={kernelName:ym,backendName:"webgpu",kernelFunc:yw};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KY(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:a}=t,{outputShape:o}=s,{sliceRank:u,numUpdates:h,sliceSize:d,strides:f,outputSize:m}=$l(i,r,o),y=!1;if(i.dtype==="string"){const B=e.bufferSync(r),z=e.bufferSync(i),U=ea(e.readSync(a.dataId)[0]),D=Rj(B,z,o,m,d,h,u,f,U,y);return e.makeTensorInfo(o,D.dtype,D.values)}const x=[m/d,d],w=Pt({inputs:{x:r},backend:e,attrs:{shape:[h,u]}}),S=i.shape.length?Pt({inputs:{x:i},backend:e,attrs:{shape:[h,d]}}):Xs({inputs:{x:i},backend:e}),C=S.dtype,k=e.makeTensorInfo([],C,ta(1,C)),E=Pt({inputs:{x:a},backend:e,attrs:{shape:Array(x.length).fill(1)}}),R=yw({inputs:{x:E},backend:e,attrs:{reps:x}}),A=ht([h,d]),L=[{type:"int32",data:[u]},{type:"int32",data:f},{type:"int32",data:[A]}];switch(h){case 0:break;case 1:{const B=new Uh([h,d],u,w.shape.length,S.shape.length,f,x,C,y);e.runWebGPUProgram(B,[S,w],C,L,R)}break;default:{const B=new Uh([h,d],u,w.shape.length,k.shape.length,f,x,C,y);e.runWebGPUProgram(B,[k,w],C,L,R)}{const B=new Uh([h,d],u,w.shape.length,S.shape.length,f,x,C);e.runWebGPUProgram(B,[S,w],C,L,R)}}const V=Pt({inputs:{x:R},backend:e,attrs:{shape:o}});return e.disposeData(w.dataId),e.disposeData(S.dataId),e.disposeData(E.dataId),e.disposeData(k.dataId),e.disposeData(R.dataId),V}const YY={kernelName:iv,backendName:"webgpu",kernelFunc:KY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QY(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{numOrSizeSplits:i,axis:a}=s,o=Qe(a,r.shape)[0],u=cw(r,i,o),h=r.shape.length,d=new Array(h).fill(0),f=r.shape.slice();return u.map(m=>{const y=[...f];y[o]=m;const x=nc({inputs:{x:r},backend:e,attrs:{begin:d,size:y}});return d[o]+=m,x})}const ZY={kernelName:ev,backendName:"webgpu",kernelFunc:QY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JY=pe({opType:Ct.SQRT}),t9={kernelName:Z1,backendName:"webgpu",kernelFunc:JY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e9={kernelName:oN,backendName:"webgpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,s=t,r=new ec(e.shape,Ct.SQUARE);return s.runWebGPUProgram(r,[e],e.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n9=In({opType:qt.SQUARED_DIFFERENCE}),s9={kernelName:av,backendName:"webgpu",kernelFunc:n9};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r9({inputs:n,attrs:t,backend:e}){const{x:s}=n,r=new ec(s.shape,Ct.STEP,"stepAlpha : f32,"),i=[{type:"float32",data:[t.alpha]}];return e.runWebGPUProgram(r,[s],s.dtype,i)}const i9={kernelName:yv,backendName:"webgpu",kernelFunc:r9};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let a9=class{constructor(t){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const e=mn(this.outputShape.length);this.uniforms=`begin : ${e},  strides : ${e}, `,this.shaderKey="stridedSlice"}getUserCode(){const t=this.outputShape.length;let e="";if(t===1)e="coords * uniforms.strides + uniforms.begin";else{let r=0;e=this.outputShape.map((i,a)=>(r++,this.outputShape.length===1?`coords * uniforms.strides[${a}] + uniforms.begin[${a}]`:`coords[${r-1}] * uniforms.strides[${a}] + uniforms.begin[${a}]`)).join(",")}return`
       ${Tt("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${e}));
         }
       }
     `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o9(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:i,end:a,strides:o,beginMask:u,endMask:h,ellipsisMask:d,newAxisMask:f,shrinkAxisMask:m}=s,{finalShapeSparse:y,finalShape:x,isIdentity:w,sliceDim0:S,isSimpleSlice:C,begin:k,end:E,strides:R}=Hv(r.shape,i,a,o,u,h,d,f,m);let A;if(w)A=Pt({inputs:{x:r},backend:e,attrs:{shape:x}});else if(S||C){M(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const L=Vv(k,E,R),V=nc({inputs:{x:r},backend:e,attrs:{begin:k,size:L}});A=Pt({inputs:{x:V},backend:e,attrs:{shape:x}}),e.disposeData(V.dataId)}else if(e.shouldExecuteOnCPU([r])){const V=e.readSync(r.dataId),B=Re(r.shape,r.dtype,V),z=Dj(y,B,R,k);A=e.makeTensorInfo(x,r.dtype,z.values)}else{const V=new a9(y),B=[{type:"int32",data:k},{type:"int32",data:R}],z=e.runWebGPUProgram(V,[r],r.dtype,B);A=Pt({inputs:{x:z},backend:e,attrs:{shape:x}}),e.disposeData(z.dataId)}return A}const l9={kernelName:ov,backendName:"webgpu",kernelFunc:o9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u9(n){const{inputs:t,backend:e,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:a,rightPad:o,padWidth:u,preserveShortSequences:h}=s,{data:d,dataSplits:f}=t,m=e.readSync(d.dataId),y=e.readSync(f.dataId),[x,w]=Oj(m,y,r,i,a,o,u,h);return[e.makeTensorInfo([x.length],"string",x),e.makeTensorInfo(f.shape,"int32",w)]}const c9={kernelName:lv,backendName:"webgpu",kernelFunc:u9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h9=In({opType:qt.SUB,cpuKernelImpl:Pj,supportsComplex:!0}),d9={kernelName:uv,backendName:"webgpu",kernelFunc:h9};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f9=pe({opType:Ct.TAN}),p9={kernelName:cv,backendName:"webgpu",kernelFunc:f9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m9=pe({opType:Ct.TANH}),g9={kernelName:hv,backendName:"webgpu",kernelFunc:m9};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y9(n){const{inputs:t,backend:e,attrs:s}=n,{tensor:r,indices:i,updates:a}=t,{sliceRank:o,numUpdates:u,sliceSize:h,strides:d,outputSize:f}=$l(a,i,r.shape),m=[f/h,h];if(f===0)return e.makeTensorInfo(r.shape,i.dtype);const y=[],x=Pt({inputs:{x:i},backend:e,attrs:{shape:[u,o]}});y.push(x);const w=Pt({inputs:{x:a},backend:e,attrs:{shape:[u,h]}});y.push(w);const S=Pt({inputs:{x:r},backend:e,attrs:{shape:m}});y.push(S);const C=yw({inputs:{x:S},backend:e,attrs:{reps:Array(m.length).fill(1)}}),k=new Uh([u,h],o,x.shape.length,w.shape.length,d,m,r.dtype,!1),E=ht([u,h]),R=[{type:"int32",data:[o]},{type:"int32",data:d},{type:"int32",data:[E]}],A=e.runWebGPUProgram(k,[w,x],S.dtype,R,C);y.push(A);const L=Pt({inputs:{x:A},backend:e,attrs:{shape:r.shape}});return y.forEach(V=>e.disposeData(V.dataId)),L}const x9={kernelName:U1,backendName:"webgpu",kernelFunc:y9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let b9=class{constructor(t){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${Tt("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}},v9=class{constructor(t){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${Tt("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ku(n,t){t!==null&&n.disposeData(t.dataId)}function mT(n){let t=1;for(;t<n;)t*=2;return t}function w9(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{k:i,sorted:a}=s,o=r.shape,u=o[o.length-1];if(e.shouldExecuteOnCPU([r])){const A=e.readSync(r.dataId),[L,V]=Lj(A,o,r.dtype,i,a);return[e.makeTensorInfo(L.shape,L.dtype,L.values),e.makeTensorInfo(V.shape,V.dtype,V.values)]}if(i===0)return o[o.length-1]=0,[e.makeTensorInfo(o,r.dtype,[]),e.makeTensorInfo(o,"int32",[])];if(u===1)return[r,_s({attrs:{shape:o,dtype:"int32",value:0},backend:e})];const d=ht(o)/u,f=Pt({inputs:{x:r},attrs:{shape:[d,u]},backend:e}),m=mT(i),y=mT(u);let x=null;const w=()=>x===null?[f,f]:[f,x],S=(A,L,V)=>{const B=w(),z=new b9(V),D=[{type:"int32",data:[u]},{type:"int32",data:[x===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[A]},{type:"int32",data:[L]}],Y=x;x=e.runWebGPUProgram(z,B,"int32",D),ku(e,Y)};for(let A=1;A<m;A*=2){const L=A*2;for(let V=A;V>=1;V/=2)S(L,V,[d,y])}for(let A=y;A>m;A/=2){const L=w(),V=new v9([d,A/2]),z=[{type:"int32",data:[u]},{type:"int32",data:[x===null?1:0]},{type:"int32",data:[m]}],U=x;x=e.runWebGPUProgram(V,L,"int32",z),ku(e,U);const D=m/2,Y=D*2;for(let nt=D;nt>=1;nt/=2)S(Y,nt,x.shape)}let C=x;x=nc({inputs:{x},backend:e,attrs:{begin:0,size:[d,i]}}),ku(e,C);let k=MR({inputs:{x:f,indices:x},backend:e,attrs:{axis:1,batchDims:1}});ku(e,f);const E=o.slice(0,-1);E.push(i),C=x,x=Pt({inputs:{x},attrs:{shape:E},backend:e}),ku(e,C);const R=k;return k=Pt({inputs:{x:k},attrs:{shape:E},backend:e}),ku(e,R),[k,x]}const S9={kernelName:dv,backendName:"webgpu",kernelFunc:w9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let C9=class{constructor(t){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${Tt("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $9(n){const{inputs:t,backend:e,attrs:s}=n,{image:r,transforms:i}=t,{interpolation:a,fillMode:o,fillValue:u,outputShape:h}=s,[d,f,m,y]=r.shape,[x,w]=h??[f,m],S=[d,x,w,y],C=new C9(S),k=a==="nearest"?1:2;let E;switch(o){case"constant":E=1;break;case"reflect":E=2;break;case"wrap":E=3;break;case"nearest":E=4;break;default:E=1;break}const R=[{type:"int32",data:[k]},{type:"int32",data:[E]},{type:"float32",data:[u]}];return e.runWebGPUProgram(C,[r,i],"float32",R)}const T9={kernelName:fv,backendName:"webgpu",kernelFunc:$9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k9(n){const{inputs:t,backend:e,attrs:s}=n,{value:r}=t;let{axis:i}=s;i<0&&(i+=r.shape.length);const a=r,o=a.shape.length,u=r.shape[i],h=new Array(o-1);let d=0;for(let w=0;w<o;w++)w!==i&&(h[d++]=a.shape[w]);const f=[],m=new Array(o).fill(0),y=a.shape.slice();y[i]=1;const x=new Array(u);for(let w=0;w<x.length;w++){m[i]=w;const S=nc({inputs:{x:a},backend:e,attrs:{begin:m,size:y}}),C=Pt({inputs:{x:S},backend:e,attrs:{shape:h}});x[w]=C,f.push(S)}return f.forEach(w=>e.disposeData(w.dataId)),x}const _9={kernelName:pv,backendName:"webgpu",kernelFunc:k9};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class N9{constructor(t,e,s){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.dispatchLayout=At(t),this.dispatch=kt(this.dispatchLayout,t,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${s} type.`);this.type=s,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${Tt("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${lo("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E9(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,segmentIds:i}=t,{numSegments:a}=s,o=r.shape.length,u=[];let h=0;const d=ts([h],o);let f=r;d!=null&&(f=Ci({inputs:{x:r},backend:e,attrs:{perm:d}}),u.push(f),h=es(1,o)[0]);const m=hw(f.shape,h,a),y=ht([f.shape[h]]),x=Pt({inputs:{x:f},backend:e,attrs:{shape:[-1,y]}});u.push(x);const w=r.dtype,S=[x.shape[0],a],C=_s({backend:e,attrs:{shape:S,value:0,dtype:w}}),k=new N9(x.shape,S,w),E=[{type:"int32",data:[a]},{type:"int32",data:[ht(x.shape)]}],R=e.runWebGPUProgram(k,[x,i],w,E,C),A=Pt({inputs:{x:R},backend:e,attrs:{shape:m}});u.push(R);let L=A;if(d!=null){u.push(A);const V=Sd(d);L=Ci({inputs:{x:L},backend:e,attrs:{perm:V}})}return u.forEach(V=>e.disposeData(V.dataId)),L}const R9={kernelName:mv,backendName:"webgpu",kernelFunc:E9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I9=[Z6,Bj,Uj,Gj,jj,Kj,n8,r8,a8,l8,c8,d8,p8,g8,x8,C8,T8,E8,I8,D8,M8,U8,H8,K8,Q8,eX,t5,rX,lX,gX,SX,kX,EX,IX,DX,PX,LX,BX,UX,GX,jX,KX,nq,rq,ZX,oq,cq,pq,gq,bq,Cq,Tq,_q,Eq,Iq,Dq,Oq,Fq,Mq,K6,Bq,jq,Uq,Gq,Kq,Qq,Jq,nK,iK,oK,uK,J6,hK,aX,fK,mK,yK,bK,wK,CK,kK,RK,NK,AK,OK,FK,BK,WK,v8,HK,XK,e7,KK,JK,s7,w8,i7,o7,u7,h7,g7,vq,x7,v7,S7,j8,T7,_7,E7,A7,O7,F7,M7,B7,X8,U7,G7,j7,q7,Y6,Q7,tY,sY,aY,uY,hY,fY,mY,yY,vY,CY,TY,_Y,EY,IY,DY,F8,i9,l9,c9,p7,PY,MY,WY,HY,YY,ZY,t9,e9,s9,d9,wq,p9,g9,x9,qY,S9,T9,Zj,_9,R9,k7];for(const n of I9)dN(n);/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var GR=function(n,t){return(GR=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,s){e.__proto__=s}||function(e,s){for(var r in s)Object.prototype.hasOwnProperty.call(s,r)&&(e[r]=s[r])})(n,t)};function HR(n,t){if(typeof t!="function"&&t!==null)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function e(){this.constructor=n}GR(n,t),n.prototype=t===null?Object.create(t):(e.prototype=t.prototype,new e)}var Ve=function(){return(Ve=Object.assign||function(n){for(var t,e=1,s=arguments.length;e<s;e++)for(var r in t=arguments[e])Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n}).apply(this,arguments)};function de(n,t,e,s){return new(e||(e=Promise))((function(r,i){function a(h){try{u(s.next(h))}catch(d){i(d)}}function o(h){try{u(s.throw(h))}catch(d){i(d)}}function u(h){var d;h.done?r(h.value):(d=h.value,d instanceof e?d:new e((function(f){f(d)}))).then(a,o)}u((s=s.apply(n,[])).next())}))}function fe(n,t){var e,s,r,i,a={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:o(0),throw:o(1),return:o(2)},typeof Symbol=="function"&&(i[Symbol.iterator]=function(){return this}),i;function o(u){return function(h){return(function(d){if(e)throw new TypeError("Generator is already executing.");for(;a;)try{if(e=1,s&&(r=2&d[0]?s.return:d[0]?s.throw||((r=s.return)&&r.call(s),0):s.next)&&!(r=r.call(s,d[1])).done)return r;switch(s=0,r&&(d=[2&d[0],r.value]),d[0]){case 0:case 1:r=d;break;case 4:return a.label++,{value:d[1],done:!1};case 5:a.label++,s=d[1],d=[0];continue;case 7:d=a.ops.pop(),a.trys.pop();continue;default:if(r=a.trys,!((r=r.length>0&&r[r.length-1])||d[0]!==6&&d[0]!==2)){a=0;continue}if(d[0]===3&&(!r||d[1]>r[0]&&d[1]<r[3])){a.label=d[1];break}if(d[0]===6&&a.label<r[1]){a.label=r[1],r=d;break}if(r&&a.label<r[2]){a.label=r[2],a.ops.push(d);break}r[2]&&a.ops.pop(),a.trys.pop();continue}d=t.call(n,a)}catch(f){d=[6,f],s=0}finally{e=r=0}if(5&d[0])throw d[1];return{value:d[0]?d[1]:void 0,done:!0}})([u,h])}}}function il(n,t,e){if(e||arguments.length===2)for(var s,r=0,i=t.length;r<i;r++)!s&&r in t||(s||(s=Array.prototype.slice.call(t,0,r)),s[r]=t[r]);return n.concat(s||Array.prototype.slice.call(t))}var $i=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],od=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"];function nm(n){return n instanceof SVGAnimatedLength?n.baseVal.value:n}function jR(n){return de(this,void 0,void 0,(function(){var t,e;return fe(this,(function(s){switch(s.label){case 0:return t=document.createElement("canvas"),n instanceof un?[4,Mv(n,t)]:[3,2];case 1:return s.sent(),[3,3];case 2:t.width=nm(n.width),t.height=nm(n.height),e=t.getContext("2d"),n instanceof ImageData?e.putImageData(n,0,0):e.drawImage(n,0,0),s.label=3;case 3:return[2,t]}}))}))}function XR(n){return de(this,void 0,void 0,(function(){var t,e,s,r,i,a;return fe(this,(function(o){switch(o.label){case 0:return n instanceof un?(t=n.shape.slice(0,2),e=t[0],s=t[1],r=ImageData.bind,[4,Mv(n)]):[3,2];case 1:return[2,new(r.apply(ImageData,[void 0,o.sent(),s,e]))];case 2:return i=document.createElement("canvas"),a=i.getContext("2d"),i.width=nm(n.width),i.height=nm(n.height),a.drawImage(n,0,0),[2,a.getImageData(0,0,i.width,i.height)]}}))}))}function A9(n){return de(this,void 0,void 0,(function(){var t,e;return fe(this,(function(s){switch(s.label){case 0:return n instanceof SVGImageElement||n instanceof OffscreenCanvas?[4,jR(n)]:[3,2];case 1:return e=s.sent(),[3,3];case 2:e=n,s.label=3;case 3:return t=e,[2,zE(t,4)]}}))}))}function qR(n){if(n<0||n>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(n));if(!Number.isInteger(n))throw new Error("Mask value must be an integer but got ".concat(n))}var bh={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},D9=(function(){function n(t){this.mask=t}return n.prototype.toCanvasImageSource=function(){return de(this,void 0,void 0,(function(){return fe(this,(function(t){return[2,this.mask]}))}))},n.prototype.toImageData=function(){return de(this,void 0,void 0,(function(){return fe(this,(function(t){return[2,XR(this.mask)]}))}))},n.prototype.toTensor=function(){return de(this,void 0,void 0,(function(){return fe(this,(function(t){return[2,A9(this.mask)]}))}))},n.prototype.getUnderlyingType=function(){return"canvasimagesource"},n})();function O9(n){return qR(n),"person"}var P9=(function(){function n(t){var e,s=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new rO.Pose({locateFile:function(r,i){if(t.solutionPath){var a=t.solutionPath.replace(/\/+$/,"");return"".concat(a,"/").concat(r)}return"".concat(i,"/").concat(r)}}),t.modelType){case"lite":e=0;break;case"heavy":e=2;break;case"full":default:e=1}this.poseSolution.setOptions({modelComplexity:e,smoothLandmarks:t.enableSmoothing,enableSegmentation:t.enableSegmentation,smoothSegmentation:t.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults((function(r){if(s.height=r.image.height,s.width=r.image.width,r.poseLandmarks==null)s.poses=[];else{var i=s.translateOutput(r.poseLandmarks,r.poseWorldLandmarks);r.segmentationMask&&(i.segmentation={maskValueToLabel:O9,mask:new D9(r.segmentationMask)}),s.poses=[i]}}))}return n.prototype.translateOutput=function(t,e){var s=this,r={keypoints:t.map((function(i,a){return{x:i.x*s.width,y:i.y*s.height,z:i.z,score:i.visibility,name:od[a]}}))};return e!=null&&(r.keypoints3D=e.map((function(i,a){return{x:i.x,y:i.y,z:i.z,score:i.visibility,name:od[a]}}))),r},n.prototype.estimatePoses=function(t,e,s){return de(this,void 0,void 0,(function(){var r,i;return fe(this,(function(a){switch(a.label){case 0:return e&&e.flipHorizontal&&e.flipHorizontal!==this.selfieMode&&(this.selfieMode=e.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),t instanceof un?(i=ImageData.bind,[4,Mv(t)]):[3,2];case 1:return r=new(i.apply(ImageData,[void 0,a.sent(),t.shape[1],t.shape[0]])),[3,3];case 2:r=t,a.label=3;case 3:return t=r,[4,this.poseSolution.send({image:t},s)];case 4:return a.sent(),[2,this.poses]}}))}))},n.prototype.dispose=function(){this.poseSolution.close()},n.prototype.reset=function(){this.poseSolution.reset()},n.prototype.initialize=function(){return this.poseSolution.initialize()},n})();function F9(n){return de(this,void 0,void 0,(function(){var t,e;return fe(this,(function(s){switch(s.label){case 0:return t=(function(r){if(r==null)return Ve({},bh);var i=Ve({},r);return i.runtime="mediapipe",i.enableSegmentation==null&&(i.enableSegmentation=bh.enableSegmentation),i.enableSmoothing==null&&(i.enableSmoothing=bh.enableSmoothing),i.smoothSegmentation==null&&(i.smoothSegmentation=bh.smoothSegmentation),i.modelType==null&&(i.modelType=bh.modelType),i})(n),[4,(e=new P9(t)).initialize()];case 1:return s.sent(),[2,e]}}))}))}function ju(n){return n instanceof un?{height:n.shape[0],width:n.shape[1]}:{height:n.height,width:n.width}}function KR(n){return n-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}function xw(n){return n instanceof un?n:zE(n)}function YR(n,t,e){return y0(e,"inputResolution"),[1/e.width*n[0][0]*t.width,1/e.height*n[0][1]*t.width,n[0][3]*t.width,1/e.width*n[1][0]*t.height,1/e.height*n[1][1]*t.height,n[1][3]*t.height,0,0]}function y0(n,t){M(n.width!==0,(function(){return"".concat(t," width cannot be 0.")})),M(n.height!==0,(function(){return"".concat(t," height cannot be 0.")}))}function mx(n,t,e){var s=e.rotationVectorStartKeypointIndex,r=e.rotationVectorEndKeypointIndex,i=n.locationData,a=i.relativeKeypoints[s].x*t.width,o=i.relativeKeypoints[s].y*t.height,u=i.relativeKeypoints[r].x*t.width,h=i.relativeKeypoints[r].y*t.height,d=2*Math.sqrt((u-a)*(u-a)+(h-o)*(h-o)),f=(function(m,y,x){var w,S=m.locationData,C=x.rotationVectorStartKeypointIndex,k=x.rotationVectorEndKeypointIndex;w=x.rotationVectorTargetAngle?x.rotationVectorTargetAngle:Math.PI*x.rotationVectorTargetAngleDegree/180;var E=S.relativeKeypoints[C].x*y.width,R=S.relativeKeypoints[C].y*y.height,A=S.relativeKeypoints[k].x*y.width,L=S.relativeKeypoints[k].y*y.height;return KR(w-Math.atan2(-(L-R),A-E))})(n,t,e);return{xCenter:a/t.width,yCenter:o/t.height,width:d/t.width,height:d/t.height,rotation:f}}function QR(n){if(n.length!==16)throw new Error("Array length must be 16 but got ".concat(n.length));return[[n[0],n[1],n[2],n[3]],[n[4],n[5],n[6],n[7]],[n[8],n[9],n[10],n[11]],[n[12],n[13],n[14],n[15]]]}function gx(n,t,e,s,r,i,a){return n[t][r]*(n[e][i]*n[s][a]-n[e][a]*n[s][i])}function ls(n,t,e){var s=(t+1)%4,r=(t+2)%4,i=(t+3)%4,a=(e+1)%4,o=(e+2)%4,u=(e+3)%4;return gx(n,s,r,i,a,o,u)+gx(n,r,i,s,a,o,u)+gx(n,i,s,r,a,o,u)}function gT(n,t,e){e===void 0&&(e={ignoreRotation:!1});for(var s=[],r=0,i=n;r<i.length;r++){var a=i[r],o=a.x-.5,u=a.y-.5,h=e.ignoreRotation?0:t.rotation,d=Math.cos(h)*o-Math.sin(h)*u,f=Math.sin(h)*o+Math.cos(h)*u;d=d*t.width+t.xCenter,f=f*t.height+t.yCenter;var m=a.z*t.width,y=Ve({},a);y.x=d,y.y=f,y.z=m,s.push(y)}return s}function ZR(n,t){var e=(function(s,r,i,a){var o=r-s,u=a-i,h=u/o;return{scale:h,offset:i-s*h}})(0,255,t[0],t[1]);return Yt((function(){return zt(wt(n,e.scale),e.offset)}))}function x0(n,t,e){var s,r,i,a,o,u,h,d,f,m,y,x,w,S,C=t.outputTensorSize,k=t.keepAspectRatio,E=t.borderMode,R=t.outputTensorFloatRange,A=ju(n),L=(function(z,U){return U?{xCenter:U.xCenter*z.width,yCenter:U.yCenter*z.height,width:U.width*z.width,height:U.height*z.height,rotation:U.rotation}:{xCenter:.5*z.width,yCenter:.5*z.height,width:z.width,height:z.height,rotation:0}})(A,e),V=(function(z,U,D){if(D===void 0&&(D=!1),!D)return{top:0,left:0,right:0,bottom:0};var Y=U.height,nt=U.width;y0(U,"targetSize"),y0(z,"roi");var dt,at,K=Y/nt,ct=z.height/z.width,yt=0,$t=0;return K>ct?(dt=z.width,at=z.width*K,$t=(1-ct/K)/2):(dt=z.height/K,at=z.height,yt=(1-K/ct)/2),z.width=dt,z.height=at,{top:$t,left:yt,right:yt,bottom:$t}})(L,C,k),B=(s=L,r=A.width,i=A.height,a=!1,o=s.width,u=s.height,h=a?-1:1,d=Math.cos(s.rotation),f=Math.sin(s.rotation),m=s.xCenter,y=s.yCenter,x=1/r,w=1/i,(S=new Array(16))[0]=o*d*h*x,S[1]=-u*f*x,S[2]=0,S[3]=(-.5*o*d*h+.5*u*f+m)*x,S[4]=o*f*h*w,S[5]=u*d*w,S[6]=0,S[7]=(-.5*u*d-.5*o*f*h+y)*w,S[8]=0,S[9]=0,S[10]=o*x,S[11]=0,S[12]=0,S[13]=0,S[14]=0,S[15]=1,QR(S));return{imageTensor:Yt((function(){var z=xw(n),U=Or(YR(B,A,C),[1,8]),D=E==="zero"?"constant":"nearest",Y=ll.transform(cr(Ue(z,"float32")),U,"bilinear",D,0,[C.height,C.width]);return R!=null?ZR(Y,R):Y})),padding:V,transformationMatrix:B}}function yT(n,t,e,s){return s===1?.5*(n+t):n+(t-n)*e/(s-1)}function L9(n){return Yt((function(){var t=(function(r){return Yt((function(){return[re(r,[0,0,0],[1,-1,1]),re(r,[0,0,1],[1,-1,-1])]}))})(n),e=t[0],s=t[1];return{boxes:De(s),logits:De(e)}}))}function JR(n){return n!=null&&n.currentTime!=null}function xT(n){for(var t={locationData:{relativeKeypoints:[]}},e=Number.MAX_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER,r=Number.MAX_SAFE_INTEGER,i=Number.MIN_SAFE_INTEGER,a=0;a<n.length;++a){var o=n[a];e=Math.min(e,o.x),s=Math.max(s,o.x),r=Math.min(r,o.y),i=Math.max(i,o.y),t.locationData.relativeKeypoints.push({x:o.x,y:o.y})}return t.locationData.relativeBoundingBox={xMin:e,yMin:r,xMax:s,yMax:i,width:s-e,height:i-r},t}function M9(n,t,e,s){return de(this,void 0,void 0,(function(){var r,i,a,o,u;return fe(this,(function(h){switch(h.label){case 0:return n.sort((function(d,f){return Math.max.apply(Math,f.score)-Math.max.apply(Math,d.score)})),r=Or(n.map((function(d){return[d.locationData.relativeBoundingBox.yMin,d.locationData.relativeBoundingBox.xMin,d.locationData.relativeBoundingBox.yMax,d.locationData.relativeBoundingBox.xMax]}))),i=Jn(n.map((function(d){return d.score[0]}))),[4,ll.nonMaxSuppressionAsync(r,i,t,e)];case 1:return[4,(a=h.sent()).array()];case 2:return o=h.sent(),u=n.filter((function(d,f){return o.indexOf(f)>-1})),Ne([r,i,a]),[2,u]}}))}))}function tI(n,t){return n.map((function(e){var s=Ve(Ve({},e),{x:e.x*t.width,y:e.y*t.height});return e.z!=null&&(s.z=e.z*t.width),s}))}function z9(n,t,e){return de(this,void 0,void 0,(function(){var s,r,i,a,o,u,h,d,f,m,y,x,w,S,C,k,E,R,A,L,V,B,z,U;return fe(this,(function(D){switch(D.label){case 0:if(s=De(t,[0]),r=s.shape,i=r[0],a=r[1],o=r[2],n.length!==o)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(n.length,", heatmap length: ").concat(o));return u=[],[4,s.buffer()];case 1:for(h=D.sent(),d=0;d<n.length;d++)if(f=n[d],m=Ve({},f),u.push(m),y=Math.trunc(m.x*a),x=Math.trunc(m.y*i),!(y<0||y>=a||x<0||y>=i)){for(w=Math.trunc((e.kernelSize-1)/2),S=Math.max(0,y-w),C=Math.min(a,y+w+1),k=Math.max(0,x-w),E=Math.min(i,x+w+1),R=0,A=0,L=0,V=0,B=k;B<E;++B)for(z=S;z<C;++z)U=h.get(B,z,d),R+=U,V=Math.max(V,U),A+=z*U,L+=B*U;V>=e.minConfidenceToRefine&&R>0&&(m.x=A/a/R,m.y=L/i/R)}return s.dispose(),[2,u]}}))}))}function bT(n,t){var e=t.left,s=t.top,r=t.left+t.right,i=t.top+t.bottom;return n.map((function(a){return Ve(Ve({},a),{x:(a.x-e)/(1-r),y:(a.y-s)/(1-i),z:a.z/(1-r)})}))}function B9(n,t,e){return qh()==="webgl"?(function(s,r,i){var a=i.combineWithPreviousRatio.toFixed(2),o={variableNames:["prevMask","newMask"],outputShape:s.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `.concat(a,`);

      setOutput(outputValue);
    }
`)},u=Uu();return Yt((function(){var h=u.compileAndRun(o,[s,r]);return Gs().makeTensorFromDataId(h.dataId,h.shape,h.dtype)}))})(n,t,e):Yt((function(){var s=Jt(t,.5),r=Dr(s),i=Jt(1,td(1,wt(r,zt(5.68842,wt(r,zt(-.748699,wt(r,zt(-57.8051,wt(r,zt(291.309,wt(r,-624.717)))))))))));return zt(t,wt(Jt(n,t),wt(i,e.combineWithPreviousRatio)))}))}function V9(n,t,e){return de(this,void 0,void 0,(function(){var s,r,i,a,o;return fe(this,(function(u){switch(u.label){case 0:return s=n[0],r=n[1],i=(function(h,d,f){return Yt((function(){var m,y,x,w;f.reverseOutputOrder?(y=De(re(h,[0,f.boxCoordOffset+0],[-1,1])),m=De(re(h,[0,f.boxCoordOffset+1],[-1,1])),w=De(re(h,[0,f.boxCoordOffset+2],[-1,1])),x=De(re(h,[0,f.boxCoordOffset+3],[-1,1]))):(m=De(re(h,[0,f.boxCoordOffset+0],[-1,1])),y=De(re(h,[0,f.boxCoordOffset+1],[-1,1])),x=De(re(h,[0,f.boxCoordOffset+2],[-1,1])),w=De(re(h,[0,f.boxCoordOffset+3],[-1,1]))),y=zt(wt(ae(y,f.xScale),d.w),d.x),m=zt(wt(ae(m,f.yScale),d.h),d.y),f.applyExponentialOnBoxSize?(x=wt(ra(ae(x,f.hScale)),d.h),w=wt(ra(ae(w,f.wScale)),d.w)):(x=wt(ae(x,f.hScale),d.h),w=wt(ae(w,f.wScale),d.h));var S=Jt(m,ae(x,2)),C=Jt(y,ae(w,2)),k=zt(m,ae(x,2)),E=zt(y,ae(w,2)),R=Rn([ft(S,[f.numBoxes,1]),ft(C,[f.numBoxes,1]),ft(k,[f.numBoxes,1]),ft(E,[f.numBoxes,1])],1);if(f.numKeypoints)for(var A=0;A<f.numKeypoints;++A){var L=f.keypointCoordOffset+A*f.numValuesPerKeypoint,V=void 0,B=void 0;f.reverseOutputOrder?(V=De(re(h,[0,L],[-1,1])),B=De(re(h,[0,L+1],[-1,1]))):(B=De(re(h,[0,L],[-1,1])),V=De(re(h,[0,L+1],[-1,1])));var z=zt(wt(ae(V,f.xScale),d.w),d.x),U=zt(wt(ae(B,f.yScale),d.h),d.y);R=Rn([R,ft(z,[f.numBoxes,1]),ft(U,[f.numBoxes,1])],1)}return R}))})(r,t,e),a=Yt((function(){var h=s;return e.sigmoidScore?(e.scoreClippingThresh!=null&&(h=KN(s,-e.scoreClippingThresh,e.scoreClippingThresh)),h=Zi(h)):h})),[4,U9(i,a,e)];case 1:return o=u.sent(),Ne([i,a]),[2,o]}}))}))}function U9(n,t,e){return de(this,void 0,void 0,(function(){var s,r,i,a,o,u,h,d,f,m,y,x;return fe(this,(function(w){switch(w.label){case 0:return s=[],[4,n.data()];case 1:return r=w.sent(),[4,t.data()];case 2:for(i=w.sent(),a=0;a<e.numBoxes;++a)if(!(e.minScoreThresh!=null&&i[a]<e.minScoreThresh||(o=a*e.numCoords,u=W9(r[o+0],r[o+1],r[o+2],r[o+3],i[a],e.flipVertically,a),(h=u.locationData.relativeBoundingBox).width<0||h.height<0))){if(e.numKeypoints>0)for((d=u.locationData).relativeKeypoints=[],f=e.numKeypoints*e.numValuesPerKeypoint,m=0;m<f;m+=e.numValuesPerKeypoint)y=o+e.keypointCoordOffset+m,x={x:r[y+0],y:e.flipVertically?1-r[y+1]:r[y+1]},d.relativeKeypoints.push(x);s.push(u)}return[2,s]}}))}))}function W9(n,t,e,s,r,i,a){return{score:[r],ind:a,locationData:{relativeBoundingBox:{xMin:t,yMin:i?1-e:n,xMax:s,yMax:i?1-n:e,width:s-t,height:e-n}}}}function G9(n,t){return n==="none"?t:(function(e){return 1/(1+Math.exp(-e))})(t)}function vT(n,t,e,s){return de(this,void 0,void 0,(function(){var r,i,a,o,u,h,d,f;return fe(this,(function(m){switch(m.label){case 0:return e=e||t.flipHorizontally||!1,s=s||t.flipVertically||!1,r=n.size,i=r/t.numLandmarks,[4,n.data()];case 1:for(a=m.sent(),o=[],u=0;u<t.numLandmarks;++u)h=u*i,(f={x:0,y:0}).x=e?t.inputImageWidth-a[h]:a[h],i>1&&(f.y=s?t.inputImageHeight-a[h+1]:a[h+1]),i>2&&(f.z=a[h+2]),i>3&&(f.score=G9(t.visibilityActivation,a[h+3])),o.push(f);for(d=0;d<o.length;++d)(f=o[d]).x=f.x/t.inputImageWidth,f.y=f.y/t.inputImageHeight,f.z=f.z/t.inputImageWidth/(t.normalizeZ||1);return[2,o]}}))}))}function wT(n,t,e){var s=n.width,r=n.height,i=n.rotation;if(e.rotation==null&&e.rotationDegree==null||(i=(function(h,d){return d.rotation!=null?h+=d.rotation:d.rotationDegree!=null&&(h+=Math.PI*d.rotationDegree/180),KR(h)})(i,e)),i===0)n.xCenter=n.xCenter+s*e.shiftX,n.yCenter=n.yCenter+r*e.shiftY;else{var a=(t.width*s*e.shiftX*Math.cos(i)-t.height*r*e.shiftY*Math.sin(i))/t.width,o=(t.width*s*e.shiftX*Math.sin(i)+t.height*r*e.shiftY*Math.cos(i))/t.height;n.xCenter=n.xCenter+a,n.yCenter=n.yCenter+o}{var u=Math.max(s*t.width,r*t.height);s=u/t.width,r=u/t.height}return n.width=s*e.scaleX,n.height=r*e.scaleY,n}function H9(n,t){return n.map((function(e){var s=Ve(Ve({},e),{x:e.x/t.width,y:e.y/t.height});return e.z!=null&&(e.z=e.z/t.width),s}))}var Ga=(function(){function n(t){this.alpha=t,this.initialized=!1}return n.prototype.apply=function(t,e){var s;return this.initialized?s=e==null?this.storedValue+this.alpha*(t-this.storedValue):this.storedValue+this.alpha*e*Math.asinh((t-this.storedValue)/e):(s=t,this.initialized=!0),this.rawValue=t,this.storedValue=s,s},n.prototype.applyWithAlpha=function(t,e,s){return this.alpha=e,this.apply(t,s)},n.prototype.hasLastRawValue=function(){return this.initialized},n.prototype.lastRawValue=function(){return this.rawValue},n.prototype.reset=function(){this.initialized=!1},n})(),yx=(function(){function n(t){this.frequency=t.frequency,this.minCutOff=t.minCutOff,this.beta=t.beta,this.thresholdCutOff=t.thresholdCutOff,this.thresholdBeta=t.thresholdBeta,this.derivateCutOff=t.derivateCutOff,this.x=new Ga(this.getAlpha(this.minCutOff)),this.dx=new Ga(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return n.prototype.apply=function(t,e,s){if(t==null)return t;var r=Math.trunc(e);if(this.lastTimestamp>=r)return t;this.lastTimestamp!==0&&r!==0&&(this.frequency=1/(1e-6*(r-this.lastTimestamp))),this.lastTimestamp=r;var i=this.x.hasLastRawValue()?(t-this.x.lastRawValue())*s*this.frequency:0,a=this.dx.applyWithAlpha(i,this.getAlpha(this.derivateCutOff)),o=this.minCutOff+this.beta*Math.abs(a),u=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(a):null;return this.x.applyWithAlpha(t,this.getAlpha(o),u)},n.prototype.getAlpha=function(t){return 1/(1+this.frequency/(2*Math.PI*t))},n})(),b0=(function(){function n(t){this.config=t}return n.prototype.apply=function(t,e,s){var r=this;if(t==null)return this.reset(),null;this.initializeFiltersIfEmpty(t);var i=1;if(!this.config.disableValueScaling){if(s<this.config.minAllowedObjectScale)return il([],t,!0);i=1/s}return t.map((function(a,o){var u=Ve(Ve({},a),{x:r.xFilters[o].apply(a.x,e,i),y:r.yFilters[o].apply(a.y,e,i)});return a.z!=null&&(u.z=r.zFilters[o].apply(a.z,e,i)),u}))},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(t){var e=this;this.xFilters!=null&&this.xFilters.length===t.length||(this.xFilters=t.map((function(s){return new yx(e.config)})),this.yFilters=t.map((function(s){return new yx(e.config)})),this.zFilters=t.map((function(s){return new yx(e.config)})))},n})(),xx=(function(){function n(t){this.config=t,this.window=[],this.lowPassFilter=new Ga(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return n.prototype.apply=function(t,e,s){if(t==null)return t;var r,i=Math.trunc(e);if(this.lastTimestamp>=i)return t;if(this.lastTimestamp===-1)r=1;else{for(var a=t*s-this.lastValue*this.lastValueScale,o=i-this.lastTimestamp,u=a,h=o,d=(1+this.window.length)*(1e6/30),f=0,m=this.window;f<m.length;f++){var y=m[f];if(h+y.duration>d)break;u+=y.distance,h+=y.duration}var x=u/(1e-6*h);r=1-1/(1+this.config.velocityScale*Math.abs(x)),this.window.unshift({distance:a,duration:o}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=t,this.lastValueScale=s,this.lastTimestamp=i,this.lowPassFilter.applyWithAlpha(t,r)},n})(),j9=(function(){function n(t){this.config=t}return n.prototype.apply=function(t,e,s){var r=this;if(t==null)return this.reset(),null;var i=1;if(!this.config.disableValueScaling){if(s<this.config.minAllowedObjectScale)return il([],t,!0);i=1/s}return this.initializeFiltersIfEmpty(t),t.map((function(a,o){var u=Ve(Ve({},a),{x:r.xFilters[o].apply(a.x,e,i),y:r.yFilters[o].apply(a.y,e,i)});return a.z!=null&&(u.z=r.zFilters[o].apply(a.z,e,i)),u}))},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(t){var e=this;this.xFilters!=null&&this.xFilters.length===t.length||(this.xFilters=t.map((function(s){return new xx(e.config)})),this.yFilters=t.map((function(s){return new xx(e.config)})),this.zFilters=t.map((function(s){return new xx(e.config)})))},n})(),bx=(function(){function n(t){if(t.velocityFilter!=null)this.keypointsFilter=new j9(t.velocityFilter);else{if(t.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(t,"."));this.keypointsFilter=new b0(t.oneEuroFilter)}}return n.prototype.apply=function(t,e,s,r,i){if(r===void 0&&(r=!1),t==null)return this.keypointsFilter.reset(),null;var a=i!=null?(function(h,d){return(h.width*d.width+h.height*d.height)/2})(i,s):1,o=r?tI(t,s):t,u=this.keypointsFilter.apply(o,e,a);return r?H9(u,s):u},n})(),ST=(function(){function n(t){this.alpha=t.alpha}return n.prototype.apply=function(t){var e=this;if(t==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===t.length||(this.visibilityFilters=t.map((function(o){return new Ga(e.alpha)})));for(var s=[],r=0;r<t.length;++r){var i=t[r],a=Ve({},i);a.score=this.visibilityFilters[r].apply(i.score),s.push(a)}return s},n})(),X9={interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},_u={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},q9={maxPoses:1,flipHorizontal:!1},K9={applyExponentialOnBoxSize:!1,flipVertically:!1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},Y9=.3,CT={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25},Q9={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},Z9={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},J9={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},tQ={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},eQ={kernelSize:7,minConfidenceToRefine:.5},$T={alpha:.1},nQ={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},sQ={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},rQ={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},iQ={activation:"none"},aQ={combineWithPreviousRatio:.7},oQ=(function(){function n(t){this.mask=t}return n.prototype.toCanvasImageSource=function(){return de(this,void 0,void 0,(function(){return fe(this,(function(t){return[2,jR(this.mask)]}))}))},n.prototype.toImageData=function(){return de(this,void 0,void 0,(function(){return fe(this,(function(t){return[2,XR(this.mask)]}))}))},n.prototype.toTensor=function(){return de(this,void 0,void 0,(function(){return fe(this,(function(t){return[2,this.mask]}))}))},n.prototype.getUnderlyingType=function(){return"tensor"},n})();function lQ(n){return qR(n),"person"}var uQ=(function(){function n(t,e,s,r,i,a){this.detectorModel=t,this.landmarkModel=e,this.enableSmoothing=s,this.enableSegmentation=r,this.smoothSegmentation=i,this.modelType=a,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=(function(f){f.reduceBoxesInLowestLayer==null&&(f.reduceBoxesInLowestLayer=!1),f.interpolatedScaleAspectRatio==null&&(f.interpolatedScaleAspectRatio=1),f.fixedAnchorSize==null&&(f.fixedAnchorSize=!1);for(var m=[],y=0;y<f.numLayers;){for(var x=[],w=[],S=[],C=[],k=y;k<f.strides.length&&f.strides[k]===f.strides[y];){var E=yT(f.minScale,f.maxScale,k,f.strides.length);if(k===0&&f.reduceBoxesInLowestLayer)S.push(1),S.push(2),S.push(.5),C.push(.1),C.push(E),C.push(E);else{for(var R=0;R<f.aspectRatios.length;++R)S.push(f.aspectRatios[R]),C.push(E);if(f.interpolatedScaleAspectRatio>0){var A=k===f.strides.length-1?1:yT(f.minScale,f.maxScale,k+1,f.strides.length);C.push(Math.sqrt(E*A)),S.push(f.interpolatedScaleAspectRatio)}}k++}for(var L=0;L<S.length;++L){var V=Math.sqrt(S[L]);x.push(C[L]/V),w.push(C[L]*V)}var B=0,z=0;if(f.featureMapHeight.length>0)B=f.featureMapHeight[y],z=f.featureMapWidth[y];else{var U=f.strides[y];B=Math.ceil(f.inputSizeHeight/U),z=Math.ceil(f.inputSizeWidth/U)}for(var D=0;D<B;++D)for(var Y=0;Y<z;++Y)for(var nt=0;nt<x.length;++nt){var dt={xCenter:(Y+f.anchorOffsetX)/z,yCenter:(D+f.anchorOffsetY)/B,width:0,height:0};f.fixedAnchorSize?(dt.width=1,dt.height=1):(dt.width=w[nt],dt.height=x[nt]),m.push(dt)}y=k}return m})(X9);var o=Jn(this.anchors.map((function(f){return f.width}))),u=Jn(this.anchors.map((function(f){return f.height}))),h=Jn(this.anchors.map((function(f){return f.xCenter}))),d=Jn(this.anchors.map((function(f){return f.yCenter})));this.anchorTensor={x:h,y:d,w:o,h:u},this.prevFilteredSegmentationMask=this.enableSegmentation?Or([],[0,0]):null}return n.prototype.estimatePoses=function(t,e,s){return de(this,void 0,void 0,(function(){var r,i,a,o,u,h,d,f,m,y,x,w,S,C,k,E,R,A,L,V,B,z,U;return fe(this,(function(D){switch(D.label){case 0:return r=(function(Y){var nt;if((nt=Y==null?q9:Ve({},Y)).maxPoses==null&&(nt.maxPoses=1),nt.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(nt.maxPoses,". Should be > 0."));if(nt.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return nt})(e),t==null?(this.reset(),[2,[]]):(this.maxPoses=r.maxPoses,this.timestamp=s!=null?1e3*s:JR(t)?1e6*t.currentTime:null,i=ju(t),a=Yt((function(){return Ue(xw(t),"float32")})),(o=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(a)]);case 1:if((u=D.sent()).length===0)return this.reset(),a.dispose(),[2,[]];h=u[0],o=this.poseDetectionToRoi(h,i),D.label=2;case 2:return[4,this.poseLandmarksByRoi(o,a)];case 3:return d=D.sent(),a.dispose(),d==null?(this.reset(),[2,[]]):(f=d.landmarks,m=d.auxiliaryLandmarks,y=d.poseScore,x=d.worldLandmarks,w=d.segmentationMask,S=this.poseLandmarkFiltering(f,m,x,i),C=S.actualLandmarksFiltered,k=S.auxiliaryLandmarksFiltered,E=S.actualWorldLandmarksFiltered,R=this.poseLandmarksToRoi(k,i),this.regionOfInterest=R,A=this.smoothSegmentation&&w!=null?this.poseSegmentationFiltering(w):w,(L=C!=null?tI(C,i):null)!=null&&L.forEach((function(Y,nt){Y.name=od[nt]})),(V=E)!=null&&V.forEach((function(Y,nt){Y.name=od[nt]})),B={score:y,keypoints:L,keypoints3D:V},A!==null&&(z=Yt((function(){var Y=cr(A,2),nt=eo(Y,[[0,0],[0,0],[0,1]]);return pE(nt,[[0,0],[0,0],[0,2]],"symmetric")})),this.smoothSegmentation||Ne(A),U={maskValueToLabel:lQ,mask:new oQ(z)},B.segmentation=U),[2,[B]])}}))}))},n.prototype.poseSegmentationFiltering=function(t){var e=this.prevFilteredSegmentationMask;return e.size===0?this.prevFilteredSegmentationMask=t:(this.prevFilteredSegmentationMask=B9(e,t,aQ),Ne(t)),Ne(e),this.prevFilteredSegmentationMask},n.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),Ne([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},n.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(Ne(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=Or([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},n.prototype.detectPose=function(t){return de(this,void 0,void 0,(function(){var e,s,r,i,a,o,u,h,d,f;return fe(this,(function(m){switch(m.label){case 0:return e=x0(t,Q9),s=e.imageTensor,r=e.padding,i=this.detectorModel.predict(s),a=L9(i),o=a.boxes,[4,V9([u=a.logits,o],this.anchorTensor,K9)];case 1:return(h=m.sent()).length===0?(Ne([s,i,u,o]),[2,h]):[4,M9(h,this.maxPoses,Y9)];case 2:return d=m.sent(),f=(function(y,x){y===void 0&&(y=[]);for(var w=x.left,S=x.top,C=x.left+x.right,k=x.top+x.bottom,E=0;E<y.length;E++){var R=y[E],A=R.locationData.relativeBoundingBox,L=(A.xMin-w)/(1-C),V=(A.yMin-S)/(1-k),B=A.width/(1-C),z=A.height/(1-k);A.xMin=L,A.yMin=V,A.width=B,A.height=z,A.xMax=L+B,A.yMax=V+z;var U=R.locationData.relativeKeypoints;U&&U.forEach((function(D){var Y=(D.x-w)/(1-C),nt=(D.y-S)/(1-k);D.x=Y,D.y=nt}))}return y})(d,r),Ne([s,i,u,o]),[2,f]}}))}))},n.prototype.poseDetectionToRoi=function(t,e){return wT(mx(t,e,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),e,CT)},n.prototype.poseLandmarksByRoi=function(t,e){return de(this,void 0,void 0,(function(){var s,r,i,a,o,u,h,d,f,m,y,x,w,S;return fe(this,(function(C){switch(C.label){case 0:if(s=ju(e),r=x0(e,Z9,t),i=r.imageTensor,a=r.padding,o=r.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return u=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&u.push("activation_segmentation"),h=this.landmarkModel.execute(i,u),[4,this.tensorsToPoseLandmarksAndSegmentation(h)];case 1:return(d=C.sent())==null?(Ne(h),Ne(i),[2,null]):(f=d.landmarks,m=d.auxiliaryLandmarks,y=d.poseScore,x=d.worldLandmarks,w=d.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(s,t,a,o,f,m,x,w)]);case 2:return S=C.sent(),Ne(h),Ne(i),[2,Ve({poseScore:y},S)]}}))}))},n.prototype.poseLandmarksAndSegmentationInverseProjection=function(t,e,s,r,i,a,o,u){return de(this,void 0,void 0,(function(){var h,d,f,m,y,x;return fe(this,(function(w){return h=bT(i,s),d=bT(a,s),f=gT(h,e),m=gT(d,e),y=(function(S,C){for(var k=[],E=0,R=S;E<R.length;E++){var A=R[E],L=A.x,V=A.y,B=C.rotation,z=Math.cos(B)*L-Math.sin(B)*V,U=Math.sin(B)*L+Math.cos(B)*V,D=Ve({},A);D.x=z,D.y=U,k.push(D)}return k})(o,e),x=null,this.enableSegmentation&&(x=Yt((function(){var S=u.shape,C=S[0],k=S[1],E=(function(L){var V=QR(new Array(16).fill(0));V[0][0]=ls(L,0,0),V[1][0]=-ls(L,0,1),V[2][0]=ls(L,0,2),V[3][0]=-ls(L,0,3),V[0][2]=ls(L,2,0),V[1][2]=-ls(L,2,1),V[2][2]=ls(L,2,2),V[3][2]=-ls(L,2,3),V[0][1]=-ls(L,1,0),V[1][1]=ls(L,1,1),V[2][1]=-ls(L,1,2),V[3][1]=ls(L,1,3),V[0][3]=-ls(L,3,0),V[1][3]=ls(L,3,1),V[2][3]=-ls(L,3,2),V[3][3]=ls(L,3,3);for(var B=L[0][0]*V[0][0]+L[1][0]*V[0][1]+L[2][0]*V[0][2]+L[3][0]*V[0][3],z=0;z<V.length;z++)for(var U=0;U<V.length;U++)V[z][U]/=B;return V})(r),R=Or(YR(E,{width:k,height:C},t),[1,8]),A=[1,C,k,1];return De(ll.transform(ft(u,A),R,"bilinear","constant",0,[t.height,t.width]),[0,3])})),Ne(u)),[2,{landmarks:f,auxiliaryLandmarks:m,worldLandmarks:y,segmentationMask:x}]}))}))},n.prototype.tensorsToPoseLandmarksAndSegmentation=function(t){return de(this,void 0,void 0,(function(){var e,s,r,i,a,o,u,h,d,f,m,y,x;return fe(this,(function(w){switch(w.label){case 0:return e=t[0],s=t[1],r=t[2],i=t[3],a=this.enableSegmentation?t[4]:null,[4,s.data()];case 1:return(o=w.sent()[0])<.5?[2,null]:[4,vT(e,J9)];case 2:return[4,z9(w.sent(),r,eQ)];case 3:return u=w.sent(),h=u.slice(0,33),d=u.slice(33,35),[4,vT(i,tQ)];case 4:return f=w.sent(),m=f.slice(0,33),y=(function(S,C,k){for(var E=[],R=0;R<S.length;R++){var A=Ve({},C[R]);A.score=S[R].score,E.push(A)}return E})(h,m),x=this.enableSegmentation?(function(S,C,k){return Yt((function(){var E=De(S,[0]),R=E.shape[2];if(R===1){var A=E;switch(C.activation){case"none":break;case"sigmoid":A=Zi(A);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(C.activation,")"))}var L=A;return De(L,[2])}throw new Error("Unsupported number of tensor channels ".concat(R))}))})(a,iQ):null,[2,{landmarks:h,auxiliaryLandmarks:d,poseScore:o,worldLandmarks:y,segmentationMask:x}]}}))}))},n.prototype.poseLandmarksToRoi=function(t,e){return wT(mx(xT(t),e,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),e,CT)},n.prototype.poseLandmarkFiltering=function(t,e,s,r){var i,a,o;if(this.timestamp!=null&&this.enableSmoothing){var u=mx(xT(e),r,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new ST($T)),i=this.visibilitySmoothingFilterActual.apply(t),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new ST($T)),a=this.visibilitySmoothingFilterAuxiliary.apply(e),o=this.visibilitySmoothingFilterActual.apply(s),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new bx(nQ)),i=this.landmarksSmoothingFilterActual.apply(i,this.timestamp,r,!0,u),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new bx(sQ)),a=this.landmarksSmoothingFilterAuxiliary.apply(a,this.timestamp,r,!0,u),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new bx(rQ)),o=this.worldLandmarksSmoothingFilterActual.apply(s,this.timestamp)}else i=t,a=e,o=s;return{actualLandmarksFiltered:i,auxiliaryLandmarksFiltered:a,actualWorldLandmarksFiltered:o}},n})();function cQ(n){return de(this,void 0,void 0,(function(){var t,e,s,r,i,a;return fe(this,(function(o){switch(o.label){case 0:return t=(function(u){var h=Ve({},u??_u);if(h.enableSmoothing==null&&(h.enableSmoothing=_u.enableSmoothing),h.enableSegmentation==null&&(h.enableSegmentation=_u.enableSegmentation),h.smoothSegmentation==null&&(h.smoothSegmentation=_u.smoothSegmentation),h.modelType==null&&(h.modelType=_u.modelType),h.detectorModelUrl==null&&(h.detectorModelUrl=_u.detectorModelUrl),h.landmarkModelUrl==null)switch(h.modelType){case"lite":h.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":h.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:h.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return h})(n),e=typeof t.detectorModelUrl=="string"&&t.detectorModelUrl.indexOf("https://tfhub.dev")>-1,s=typeof t.landmarkModelUrl=="string"&&t.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([Gu(t.detectorModelUrl,{fromTFHub:e}),Gu(t.landmarkModelUrl,{fromTFHub:s})])];case 1:return r=o.sent(),i=r[0],a=r[1],[2,new uQ(i,a,t.enableSmoothing,t.enableSegmentation,t.smoothSegmentation,t.modelType)]}}))}))}var cl,vi,eI=(function(){function n(t){(function(e){if(e.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(e.maxTracks));if(e.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(e.maxAge));if(e.keypointTrackerParams!==void 0){if(e.keypointTrackerParams.keypointConfidenceThreshold<0||e.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(e.keypointTrackerParams.keypointConfidenceThreshold));if(e.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(e.keypointTrackerParams.minNumberOfKeypoints));for(var s=0,r=e.keypointTrackerParams.keypointFalloff;s<r.length;s++){var i=r[s];if(i<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(i))}}})(t),this.tracks=[],this.maxTracks=t.maxTracks,this.maxAge=1e3*t.maxAge,this.minSimilarity=t.minSimilarity,this.nextID=1}return n.prototype.apply=function(t,e){this.filterOldTracks(e);var s=this.computeSimilarity(t);return this.assignTracks(t,s,e),this.updateTracks(e),t},n.prototype.getTracks=function(){return this.tracks.slice()},n.prototype.getTrackIDs=function(){return new Set(this.tracks.map((function(t){return t.id})))},n.prototype.filterOldTracks=function(t){var e=this;this.tracks=this.tracks.filter((function(s){return t-s.lastTimestamp<=e.maxAge}))},n.prototype.assignTracks=function(t,e,s){for(var r=Array.from(Array(e[0].length).keys()),i=[],a=0,o=Array.from(Array(t.length).keys());a<o.length;a++){var u=o[a];if(r.length!==0){for(var h=-1,d=-1,f=0,m=r;f<m.length;f++){var y=m[f],x=e[u][y];x>=this.minSimilarity&&x>d&&(h=y,d=x)}if(h>=0){var w=this.tracks[h];w=Object.assign(w,this.createTrack(t[u],s,w.id)),t[u].id=w.id;var S=r.indexOf(h);r.splice(S,1)}else i.push(u)}else i.push(u)}for(var C=0,k=i;C<k.length;C++){u=k[C];var E=this.createTrack(t[u],s);this.tracks.push(E),t[u].id=E.id}},n.prototype.updateTracks=function(t){this.tracks.sort((function(e,s){return s.lastTimestamp-e.lastTimestamp})),this.tracks=this.tracks.slice(0,this.maxTracks)},n.prototype.createTrack=function(t,e,s){var r={id:s||this.nextTrackID(),lastTimestamp:e,keypoints:il([],t.keypoints,!0).map((function(i){return Ve({},i)}))};return t.box!==void 0&&(r.box=Ve({},t.box)),r},n.prototype.nextTrackID=function(){var t=this.nextID;return this.nextID+=1,t},n.prototype.remove=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];this.tracks=this.tracks.filter((function(s){return!t.includes(s.id)}))},n.prototype.reset=function(){this.tracks=[]},n})(),hQ=(function(n){function t(e){return n.call(this,e)||this}return HR(t,n),t.prototype.computeSimilarity=function(e){var s=this;return e.length===0||this.tracks.length===0?[[]]:e.map((function(r){return s.tracks.map((function(i){return s.iou(r,i)}))}))},t.prototype.iou=function(e,s){var r=Math.max(e.box.xMin,s.box.xMin),i=Math.max(e.box.yMin,s.box.yMin),a=Math.min(e.box.xMax,s.box.xMax),o=Math.min(e.box.yMax,s.box.yMax);if(r>=a||i>=o)return 0;var u=(a-r)*(o-i);return u/(e.box.width*e.box.height+s.box.width*s.box.height-u)},t})(eI),dQ=(function(n){function t(e){var s=n.call(this,e)||this;return s.keypointThreshold=e.keypointTrackerParams.keypointConfidenceThreshold,s.keypointFalloff=e.keypointTrackerParams.keypointFalloff,s.minNumKeyoints=e.keypointTrackerParams.minNumberOfKeypoints,s}return HR(t,n),t.prototype.computeSimilarity=function(e){if(e.length===0||this.tracks.length===0)return[[]];for(var s=[],r=0,i=e;r<i.length;r++){for(var a=i[r],o=[],u=0,h=this.tracks;u<h.length;u++){var d=h[u];o.push(this.oks(a,d))}s.push(o)}return s},t.prototype.oks=function(e,s){for(var r=this.area(s.keypoints)+1e-6,i=0,a=0,o=0;o<e.keypoints.length;++o){var u=e.keypoints[o],h=s.keypoints[o];if(!(u.score<this.keypointThreshold||h.score<this.keypointThreshold)){a+=1;var d=Math.pow(u.x-h.x,2)+Math.pow(u.y-h.y,2),f=2*this.keypointFalloff[o];i+=Math.exp(-1*d/(2*r*Math.pow(f,2)))}}return a<this.minNumKeyoints?0:i/a},t.prototype.area=function(e){var s=this,r=e.filter((function(u){return u.score>s.keypointThreshold})),i=Math.min.apply(Math,il([1],r.map((function(u){return u.x})),!1)),a=Math.max.apply(Math,il([0],r.map((function(u){return u.x})),!1)),o=Math.min.apply(Math,il([1],r.map((function(u){return u.y})),!1));return(a-i)*(Math.max.apply(Math,il([0],r.map((function(u){return u.y})),!1))-o)},t})(eI);function fQ(n){switch(n){case vi.BlazePose:return od.reduce((function(t,e,s){return t[e]=s,t}),{});case vi.PoseNet:case vi.MoveNet:return $i.reduce((function(t,e,s){return t[e]=s,t}),{});default:throw new Error("Model ".concat(n," is not supported."))}}(function(n){n.Keypoint="keypoint",n.BoundingBox="boundingBox"})(cl||(cl={})),(function(n){n.MoveNet="MoveNet",n.BlazePose="BlazePose",n.PoseNet="PoseNet"})(vi||(vi={}));var TT=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],nI={modelType:"SinglePose.Lightning",enableSmoothing:!0},kT={},_T={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},vx={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},NT={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function pQ(n,t,e,s){for(var r={},i=0,a=$i;i<a.length;i++){var o=a[i];r[o]=[t[e[o]].y*s.height,t[e[o]].x*s.width]}if((function(k,E){return(k[E.left_hip].score>.2||k[E.right_hip].score>.2)&&(k[E.left_shoulder].score>.2||k[E.right_shoulder].score>.2)})(t,e)){var u=(r.left_hip[0]+r.right_hip[0])/2,h=(r.left_hip[1]+r.right_hip[1])/2,d=(function(k,E,R,A,L){for(var V=["left_shoulder","right_shoulder","left_hip","right_hip"],B=0,z=0,U=0;U<V.length;U++)(at=Math.abs(A-R[V[U]][0]))>B&&(B=at),(K=Math.abs(L-R[V[U]][1]))>z&&(z=K);for(var D=0,Y=0,nt=0,dt=Object.keys(R);nt<dt.length;nt++){var at,K,ct=dt[nt];k[E[ct]].score<.2||((at=Math.abs(A-R[ct][0]))>D&&(D=at),(K=Math.abs(L-R[ct][1]))>Y&&(Y=K))}return[B,z,D,Y]})(t,e,r,u,h),f=d[0],m=d[1],y=d[2],x=d[3],w=Math.max(1.9*m,1.9*f,1.2*y,1.2*x),S=[u-(w=Math.min(w,Math.max(h,s.width-h,u,s.height-u))),h-w];if(w>Math.max(s.width,s.height)/2)return v0(n==null,s);var C=2*w;return{yMin:S[0]/s.height,xMin:S[1]/s.width,yMax:(S[0]+C)/s.height,xMax:(S[1]+C)/s.width,height:(S[0]+C)/s.height-S[0]/s.height,width:(S[1]+C)/s.width-S[1]/s.width}}return v0(n==null,s)}function v0(n,t){var e,s,r,i;return n?t.width>t.height?(e=1,s=t.height/t.width,r=0,i=(t.width/2-t.height/2)/t.width):(e=t.width/t.height,s=1,r=(t.height/2-t.width/2)/t.height,i=0):t.width>t.height?(e=t.width/t.height,s=1,r=(t.height/2-t.width/2)/t.height,i=0):(e=1,s=t.height/t.width,r=0,i=(t.width/2-t.height/2)/t.width),{yMin:r,xMin:i,yMax:r+e,xMax:i+s,height:e,width:s}}function mQ(n){var t,e=n==null?nI:Ve({},n);if(e.modelType==null)e.modelType="SinglePose.Lightning";else if(TT.indexOf(e.modelType)<0)throw new Error("Invalid architecture ".concat(e.modelType,". ")+"Should be one of ".concat(TT));if(e.enableSmoothing==null&&(e.enableSmoothing=!0),e.minPoseScore!=null&&(e.minPoseScore<0||e.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(e.multiPoseMaxDimension!=null&&(e.multiPoseMaxDimension%32!=0||e.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(e.modelType==="MultiPose.Lightning"&&e.enableTracking==null&&(e.enableTracking=!0),e.modelType==="MultiPose.Lightning"&&e.enableTracking===!0)if(e.trackerType==null&&(e.trackerType=cl.BoundingBox),e.trackerType===cl.Keypoint)e.trackerConfig!=null?e.trackerConfig=(function(s){var r=ET(vx,s);return r.keypointTrackerParams=Ve({},vx.keypointTrackerParams),s.keypointTrackerParams!=null&&(s.keypointTrackerParams.keypointConfidenceThreshold!=null&&(r.keypointTrackerParams.keypointConfidenceThreshold=s.keypointTrackerParams.keypointConfidenceThreshold),s.keypointTrackerParams.keypointFalloff!=null&&(r.keypointTrackerParams.keypointFalloff=s.keypointTrackerParams.keypointFalloff),s.keypointTrackerParams.minNumberOfKeypoints!=null&&(r.keypointTrackerParams.minNumberOfKeypoints=s.keypointTrackerParams.minNumberOfKeypoints)),r})(e.trackerConfig):e.trackerConfig=vx;else{if(e.trackerType!==cl.BoundingBox)throw new Error("Tracker type not supported by MoveNet");e.trackerConfig!=null?e.trackerConfig=(t=e.trackerConfig,ET(NT,t)):e.trackerConfig=NT}return e}function ET(n,t){var e={maxTracks:n.maxTracks,maxAge:n.maxAge,minSimilarity:n.minSimilarity};return t.maxTracks!=null&&(e.maxTracks=t.maxTracks),t.maxAge!=null&&(e.maxAge=t.maxAge),t.minSimilarity!=null&&(e.minSimilarity=t.minSimilarity),e}var gQ=(function(){function n(t,e){this.moveNetModel=t,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=fQ(vi.MoveNet),e.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):e.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=e.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new b0(_T),this.cropRegionFilterYMin=new Ga(.9),this.cropRegionFilterXMin=new Ga(.9),this.cropRegionFilterYMax=new Ga(.9),this.cropRegionFilterXMax=new Ga(.9)),this.enableSmoothing=e.enableSmoothing,e.minPoseScore?this.minPoseScore=e.minPoseScore:this.minPoseScore=.25,e.multiPoseMaxDimension?this.multiPoseMaxDimension=e.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=e.enableTracking,this.multiPoseModel&&this.enableTracking&&(e.trackerType===cl.Keypoint?this.tracker=new dQ(e.trackerConfig):e.trackerType===cl.BoundingBox&&(this.tracker=new hQ(e.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return n.prototype.runSinglePersonPoseModel=function(t){return de(this,void 0,void 0,(function(){var e,s,r,i,a;return fe(this,(function(o){switch(o.label){case 0:if((e=this.moveNetModel.execute(t)).shape.length!==4||e.shape[0]!==1||e.shape[1]!==1||e.shape[2]!==17||e.shape[3]!==3)throw e.dispose(),new Error("Unexpected output shape from model: [".concat(e.shape,"]"));return qh()==="webgpu"?[3,1]:(s=e.dataSync(),[3,3]);case 1:return[4,e.data()];case 2:s=o.sent(),o.label=3;case 3:for(e.dispose(),r={keypoints:[],score:0},i=0,a=0;a<17;++a)r.keypoints[a]={y:s[3*a],x:s[3*a+1],score:s[3*a+2]},r.keypoints[a].score>.2&&(++i,r.score+=r.keypoints[a].score);return i>0&&(r.score/=i),[2,r]}}))}))},n.prototype.runMultiPersonPoseModel=function(t){return de(this,void 0,void 0,(function(){var e,s,r,i,a,o,u,h;return fe(this,(function(d){switch(d.label){case 0:if((e=this.moveNetModel.execute(t)).shape.length!==3||e.shape[0]!==1||e.shape[2]!==56)throw e.dispose(),new Error("Unexpected output shape from model: [".concat(e.shape,"]"));return qh()==="webgpu"?[3,1]:(s=e.dataSync(),[3,3]);case 1:return[4,e.data()];case 2:s=d.sent(),d.label=3;case 3:for(e.dispose(),r=[],i=s.length/56,a=0;a<i;++a)for(r[a]={keypoints:[]},o=56*a+51,r[a].box={yMin:s[o],xMin:s[o+1],yMax:s[o+2],xMax:s[o+3],width:s[o+3]-s[o+1],height:s[o+2]-s[o]},u=56*a+55,r[a].score=s[u],r[a].keypoints=[],h=0;h<17;++h)r[a].keypoints[h]={y:s[56*a+3*h],x:s[56*a+3*h+1],score:s[56*a+3*h+2]};return[2,r]}}))}))},n.prototype.estimatePoses=function(t,e,s){return e===void 0&&(e=kT),de(this,void 0,void 0,(function(){var r,i,a,o,u,h;return fe(this,(function(d){switch(d.label){case 0:return e=(function(f){return f==null?kT:Ve({},f)})(e),t==null?(this.reset(),[2,[]]):(s==null?JR(t)&&(s=1e6*t.currentTime):s*=1e3,r=xw(t),i=ju(r),a=cr(r,0),t instanceof un||r.dispose(),o=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(a,i,s)]);case 1:return o=d.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(a,i,s)];case 3:o=d.sent(),d.label=4;case 4:for(u=0;u<o.length;++u)for(h=0;h<o[u].keypoints.length;++h)o[u].keypoints[h].name=$i[h],o[u].keypoints[h].y*=i.height,o[u].keypoints[h].x*=i.width;return[2,o]}}))}))},n.prototype.estimateSinglePose=function(t,e,s){return de(this,void 0,void 0,(function(){var r,i,a,o,u=this;return fe(this,(function(h){switch(h.label){case 0:return this.cropRegion||(this.cropRegion=v0(this.cropRegion==null,e)),r=Yt((function(){var d=Or([[u.cropRegion.yMin,u.cropRegion.xMin,u.cropRegion.yMax,u.cropRegion.xMax]]),f=aa([1],"int32"),m=[u.modelInputResolution.height,u.modelInputResolution.width];return Ue(ll.cropAndResize(t,d,f,m,"bilinear",0),"int32")})),t.dispose(),[4,this.runSinglePersonPoseModel(r)];case 1:if(i=h.sent(),r.dispose(),i.score<this.minPoseScore)return this.reset(),[2,[]];for(a=0;a<i.keypoints.length;++a)i.keypoints[a].y=this.cropRegion.yMin+i.keypoints[a].y*this.cropRegion.height,i.keypoints[a].x=this.cropRegion.xMin+i.keypoints[a].x*this.cropRegion.width;return s!=null&&this.enableSmoothing&&(i.keypoints=this.keypointFilter.apply(i.keypoints,s,1)),o=pQ(this.cropRegion,i.keypoints,this.keypointIndexByName,e),this.cropRegion=this.filterCropRegion(o),[2,[i]]}}))}))},n.prototype.estimateMultiplePoses=function(t,e,s){return de(this,void 0,void 0,(function(){var r,i,a,o,u,h,d,f,m,y,x,w=this;return fe(this,(function(S){switch(S.label){case 0:return e.width>e.height?(i=this.multiPoseMaxDimension,a=Math.round(this.multiPoseMaxDimension*e.height/e.width),r=ll.resizeBilinear(t,[a,i]),u=i,h=32*Math.ceil(a/32),o=eo(r,[[0,0],[0,h-a],[0,0],[0,0]])):(i=Math.round(this.multiPoseMaxDimension*e.width/e.height),a=this.multiPoseMaxDimension,r=ll.resizeBilinear(t,[a,i]),u=32*Math.ceil(i/32),h=a,o=eo(r,[[0,0],[0,0],[0,u-i],[0,0]])),r.dispose(),t.dispose(),d=Ue(o,"int32"),o.dispose(),[4,this.runMultiPersonPoseModel(d)];case 1:for(f=S.sent(),d.dispose(),f=f.filter((function(C){return C.score>=w.minPoseScore})),y=0;y<f.length;++y)for(m=0;m<f[y].keypoints.length;++m)f[y].keypoints[m].y*=h/a,f[y].keypoints[m].x*=u/i;if(this.enableTracking&&(this.tracker.apply(f,s),this.enableSmoothing)){for(y=0;y<f.length;++y)this.keypointFilterMap.has(f[y].id)||this.keypointFilterMap.set(f[y].id,new b0(_T)),f[y].keypoints=this.keypointFilterMap.get(f[y].id).apply(f[y].keypoints,s,1);x=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach((function(C,k){x.has(k)||w.keypointFilterMap.delete(k)}))}return[2,f]}}))}))},n.prototype.filterCropRegion=function(t){if(t){var e=this.cropRegionFilterYMin.apply(t.yMin),s=this.cropRegionFilterXMin.apply(t.xMin),r=this.cropRegionFilterYMax.apply(t.yMax),i=this.cropRegionFilterXMax.apply(t.xMax);return{yMin:e,xMin:s,yMax:r,xMax:i,height:r-e,width:i-s}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},n.prototype.dispose=function(){this.moveNetModel.dispose()},n.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},n.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},n})();function yQ(n){return n===void 0&&(n=nI),de(this,void 0,void 0,(function(){var t,e,s,r;return fe(this,(function(i){switch(i.label){case 0:return t=mQ(n),s=!0,t.modelUrl?(s=typeof t.modelUrl=="string"&&t.modelUrl.indexOf("https://tfhub.dev")>-1,[4,Gu(t.modelUrl,{fromTFHub:s})]):[3,2];case 1:return e=i.sent(),[3,4];case 2:return r=void 0,t.modelType==="SinglePose.Lightning"?r="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":t.modelType==="SinglePose.Thunder"?r="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":t.modelType==="MultiPose.Lightning"&&(r="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,Gu(r,{fromTFHub:s})];case 3:e=i.sent(),i.label=4;case 4:return qh()==="webgl"&&tt().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new gQ(e,t)]}}))}))}var RT={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},IT=["MobileNetV1","ResNet50"],AT={MobileNetV1:[8,16],ResNet50:[16]},xQ=[8,16,32],DT={MobileNetV1:[.5,.75,1],ResNet50:[1]},OT=[1,2,4],PT={maxPoses:1,flipHorizontal:!1},bQ={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},vQ=[-123.15,-115.9,-103.06];function wx(n){return Math.floor(n/2)}var wQ=(function(){function n(t,e){this.priorityQueue=new Array(t),this.numberOfElements=-1,this.getElementValue=e}return n.prototype.enqueue=function(t){this.priorityQueue[++this.numberOfElements]=t,this.swim(this.numberOfElements)},n.prototype.dequeue=function(){var t=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,t},n.prototype.empty=function(){return this.numberOfElements===-1},n.prototype.size=function(){return this.numberOfElements+1},n.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},n.prototype.max=function(){return this.priorityQueue[0]},n.prototype.swim=function(t){for(;t>0&&this.less(wx(t),t);)this.exchange(t,wx(t)),t=wx(t)},n.prototype.sink=function(t){for(;2*t<=this.numberOfElements;){var e=2*t;if(e<this.numberOfElements&&this.less(e,e+1)&&e++,!this.less(t,e))break;this.exchange(t,e),t=e}},n.prototype.getValueAt=function(t){return this.getElementValue(this.priorityQueue[t])},n.prototype.less=function(t,e){return this.getValueAt(t)<this.getValueAt(e)},n.prototype.exchange=function(t,e){var s=this.priorityQueue[t];this.priorityQueue[t]=this.priorityQueue[e],this.priorityQueue[e]=s},n})();function SQ(n,t,e,s,r,i){for(var a=i.shape,o=a[0],u=a[1],h=!0,d=Math.max(e-r,0),f=Math.min(e+r+1,o),m=d;m<f;++m){for(var y=Math.max(s-r,0),x=Math.min(s+r+1,u),w=y;w<x;++w)if(i.get(m,w,n)>t){h=!1;break}if(!h)break}return h}function CQ(n){return de(this,void 0,void 0,(function(){return fe(this,(function(t){return[2,Promise.all(n.map((function(e){return e.buffer()})))]}))}))}function sI(n,t,e,s){return{y:s.get(n,t,e),x:s.get(n,t,e+17)}}function rI(n,t,e){var s=sI(n.heatmapY,n.heatmapX,n.id,e),r=s.y,i=s.x;return{x:n.heatmapX*t+i,y:n.heatmapY*t+r}}function iI(n,t,e,s){var r=e.x,i=e.y;return n.some((function(a){var o,u,h,d,f,m,y=a.keypoints;return o=i,u=r,h=y[s].y,d=y[s].x,(f=h-o)*f+(m=d-u)*m<=t}))}var FT=$i.reduce((function(n,t,e){return n[t]=e,n}),{}),aI=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map((function(n){var t=n[0],e=n[1];return[FT[t],FT[e]]})),Sx=aI.map((function(n){return n[1]})),LT=aI.map((function(n){return n[0]}));function MT(n,t,e){return n<t?t:n>e?e:n}function Cx(n,t,e,s){return{y:MT(Math.round(n.y/t),0,e-1),x:MT(Math.round(n.x/t),0,s-1)}}function zT(n,t){return{x:n.x+t.x,y:n.y+t.y}}function BT(n,t,e,s,r,i,a,o){o===void 0&&(o=2);for(var u=s.shape,h=u[0],d=u[1],f={y:t.y,x:t.x},m=zT(f,(function(k,E,R){var A=R.shape[2]/2;return{y:R.get(E.y,E.x,k),x:R.get(E.y,E.x,A+k)}})(n,Cx(f,i,h,d),a)),y=0;y<o;y++){var x=Cx(m,i,h,d),w=sI(x.y,x.x,e,r);m=zT({x:x.x*i,y:x.y*i},{x:w.x,y:w.y})}var S=Cx(m,i,h,d),C=s.get(S.y,S.x,e);return{y:m.y,x:m.x,name:$i[e],score:C}}function $Q(n,t,e,s,r,i){var a=t.shape[2],o=Sx.length,u=new Array(a),h=n.part,d=n.score,f=rI(h,s,e);u[h.id]={score:d,name:$i[h.id],y:f.y,x:f.x};for(var m=o-1;m>=0;--m){var y=Sx[m],x=LT[m];u[y]&&!u[x]&&(u[x]=BT(m,u[y],x,t,e,s,i))}for(m=0;m<o;++m)y=LT[m],x=Sx[m],u[y]&&!u[x]&&(u[x]=BT(m,u[y],x,t,e,s,r));return u}function TQ(n,t,e){return e.reduce((function(s,r,i){var a=r.y,o=r.x,u=r.score;return iI(n,t,{y:a,x:o},i)||(s+=u),s}),0)/e.length}function kQ(n,t,e,s,r,i,a,o){return a===void 0&&(a=.5),o===void 0&&(o=20),de(this,void 0,void 0,(function(){var u,h,d,f,m,y,x,w,S,C,k,E;return fe(this,(function(R){switch(R.label){case 0:return[4,CQ([n,t,e,s])];case 1:for(u=R.sent(),h=u[0],d=u[1],f=u[2],m=u[3],y=[],x=(function(A,L,V){for(var B=V.shape,z=B[0],U=B[1],D=B[2],Y=new wQ(z*U*D,(function(ct){return ct.score})),nt=0;nt<z;++nt)for(var dt=0;dt<U;++dt)for(var at=0;at<D;++at){var K=V.get(nt,dt,at);K<A||SQ(at,K,nt,dt,L,V)&&Y.enqueue({score:K,part:{heatmapY:nt,heatmapX:dt,id:at}})}return Y})(a,1,h),w=o*o;y.length<i&&!x.empty();)S=x.dequeue(),C=rI(S.part,r,d),iI(y,w,C,S.part.id)||(k=$Q(S,h,d,r,f,m),E=TQ(y,w,k),y.push({keypoints:k,score:E}));return[2,y]}}))}))}function oI(){for(var n,t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];switch(t.length){case 0:n="fn main() ";break;case 1:n="fn main(".concat(t[0]," : i32)");break;default:throw Error("Unreachable")}return n}var _Q=(function(){function n(t){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[t[0],1],this.dispatchLayout=At(this.outputShape),this.dispatch=kt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return n.prototype.getUserCode=function(){return`
        `.concat(oI("index"),` {
          if (index < uniforms.size) {
            let y = B[index * 2];
            let x = B[index * 2 + 1];
            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;
            result[index] = A[outIndex];
          }
        }
        `)},n})();function NQ(n,t){if(Uu()instanceof tc)return(function(e,s){var r=Uu(),i=new _Q(s.shape),a=r.runWebGPUProgram(i,[e,s],"float32");return Gs().makeTensorFromTensorInfo(a)})(n,t);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}var EQ=(function(){function n(t){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,t.length!==2||t[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(t));this.workgroupSize=[32,1,1],this.outputShape=t;var e=[t[0],1];this.dispatchLayout=At(e),this.dispatch=kt(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return n.prototype.getUserCode=function(){return`
    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {
      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;
      let outIndexX = outIndexY + uniforms.bShape.z;
      let outY = i32(B[outIndexY]);
      let outX = i32(B[outIndexX]);
      return vec2<i32>(outY, outX);
    }

    `.concat(oI("index"),` {
      if (index < uniforms.size) {
        let indexY = index * `).concat(this.supportedLastDimension,`;
        let indexX = indexY + 1;
        let heatmapY = A[indexY];
        let heatmapX = A[indexX];
        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);
        result[indexY] = f32(out[0]);
        result[indexX] = f32(out[1]);
      }
    }
    `)},n})();function RQ(n,t){if(Uu()instanceof tc)return(function(e,s){var r=Uu(),i=new EQ(e.shape),a=r.runWebGPUProgram(i,[e,s],"float32");return Gs().makeTensorFromTensorInfo(a)})(n,t);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}function lI(n){var t=n.shape,e=t[0],s=t[1],r=t[2];return Yt((function(){var i,a,o=ft(n,[e*s,r]),u=HN(o,0),h=cr(ae(u,ie(s,"int32")),1),d=cr((i=u,a=s,Yt((function(){var f=ae(i,ie(a,"int32"));return Jt(i,wt(f,ie(a,"int32")))}))),1);return Rn([h,d],1)}))}function IQ(n,t,e){return Yt((function(){var s=(function(r,i){for(var a=[],o=0;o<$i.length;o++){var u=r.get(o,0).valueOf(),h=r.get(o,1).valueOf(),d=AQ(u,h,o,i),f=d.x,m=d.y;a.push(m),a.push(f)}return Or(a,[$i.length,2])})(n,e);return zt(Ue(wt(n.toTensor(),ie(t,"int32")),"float32"),s)}))}function AQ(n,t,e,s){return{y:s.get(n,t,e),x:s.get(n,t,e+$i.length)}}function DQ(n,t,e){return de(this,void 0,void 0,(function(){var s,r,i,a,o,u,h,d,f,m;return fe(this,(function(y){switch(y.label){case 0:return s=0,r=lI(n),[4,Promise.all([n.buffer(),t.buffer(),r.buffer()])];case 1:return i=y.sent(),a=i[0],o=i[1],u=i[2],[4,(h=IQ(u,e,o)).buffer()];case 2:return d=y.sent(),f=Array.from((function(x,w){for(var S=w.shape[0],C=new Float32Array(S),k=0;k<S;k++){var E=w.get(k,0),R=w.get(k,1);C[k]=x.get(E,R,k)}return C})(a,u)),m=f.map((function(x,w){return s+=x,{y:d.get(w,0),x:d.get(w,1),score:x,name:$i[w]}})),r.dispose(),h.dispose(),[2,{keypoints:m,score:s/m.length}]}}))}))}function OQ(n,t,e){return de(this,void 0,void 0,(function(){var s,r,i;return fe(this,(function(a){return s=lI(n),r=(function(o,u,h){return Yt((function(){var d=RQ(o,h);return zt(Ue(wt(o,ie(u,"int32")),"float32"),d)}))})(s,e,t),i=NQ(n,s),[2,[r,i]]}))}))}function VT(n,t){return(n-1)%t==0}var UT="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",WT="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function GT(n,t){return(function(e,s){return(e-1)%s==0})(n,t)?n:Math.floor(n/t)*t+1}var HT=(function(){function n(t,e){this.posenetModel=t;var s=this.posenetModel.inputs[0].shape;M(s[1]===-1&&s[2]===-1,(function(){return"Input shape [".concat(s[1],", ").concat(s[2],"] ")+"must both be equal to or -1"}));var r,i,a=(r=e.inputResolution,i=e.outputStride,{height:GT(r.height,i),width:GT(r.width,i)});(function(o){M(xQ.indexOf(o)>=0,(function(){return"outputStride of ".concat(o," is invalid. ")+"It must be either 8 or 16."}))})(e.outputStride),(function(o,u){M(VT(o.height,u),(function(){return"height of ".concat(o.height," is invalid for output stride ")+"".concat(u,".")})),M(VT(o.width,u),(function(){return"width of ".concat(o.width," is invalid for output stride ")+"".concat(u,".")}))})(a,e.outputStride),this.inputResolution=a,this.outputStride=e.outputStride,this.architecture=e.architecture}return n.prototype.estimatePoses=function(t,e){return e===void 0&&(e=PT),de(this,void 0,void 0,(function(){return fe(this,(function(s){return[2,this.estimatePosesGPU(t,e,!1)]}))}))},n.prototype.estimatePosesGPU=function(t,e,s){return e===void 0&&(e=PT),s===void 0&&(s=!1),de(this,void 0,void 0,(function(){var r,i,a,o,u,h,d,f,m,y,x,w,S,C,k,E,R,A;return fe(this,(function(L){switch(L.label){case 0:return r=(function(V){var B=V;if(B.maxPoses==null&&(B.maxPoses=1),B.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(B.maxPoses,". Should be > 0."));if(B.maxPoses>1){if((B=Ve(Ve({},bQ),B)).scoreThreshold<0||B.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(B.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(B.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(B.nmsRadius,"."))}return B})(e),t==null?[2,s?[[],[]]:[]]:(this.maxPoses=r.maxPoses,i=x0(t,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),a=i.imageTensor,o=i.padding,u=this.architecture==="ResNet50"?zt(a,vQ):ZR(a,[-1,1]),h=this.posenetModel.predict(u),this.architecture==="ResNet50"?(d=De(h[2],[0]),f=De(h[3],[0]),m=De(h[0],[0]),y=De(h[1],[0])):(d=De(h[0],[0]),f=De(h[1],[0]),m=De(h[2],[0]),y=De(h[3],[0])),x=Zi(f),this.maxPoses!==1?[3,5]:s?[4,OQ(x,d,this.outputStride)]:[3,2]);case 1:return S=L.sent(),k=S[0],C=S[1],w=[k,C],[3,4];case 2:return[4,DQ(x,d,this.outputStride)];case 3:k=L.sent(),w=[k],L.label=4;case 4:return[3,7];case 5:if(s)throw new Error("GPU renderer only supports single pose!");return[4,kQ(x,d,m,y,this.outputStride,this.maxPoses,r.scoreThreshold,r.nmsRadius)];case 6:w=L.sent(),L.label=7;case 7:if(s){if(r.flipHorizontal===!0)throw new Error("flipHorizontal is not supported!");E=this.getCanvasInfo(ju(t),this.inputResolution,o)}else A=ju(t),R=(function(V,B,z,U){var D=B.height,Y=B.width,nt=D/(z.height*(1-U.top-U.bottom)),dt=Y/(z.width*(1-U.left-U.right)),at=-U.top*z.height,K=-U.left*z.width;if(dt===1&&nt===1&&at===0&&K===0)return V;for(var ct=0,yt=V;ct<yt.length;ct++)for(var $t=0,H=yt[ct].keypoints;$t<H.length;$t++){var ut=H[$t];ut.x=(ut.x+K)*dt,ut.y=(ut.y+at)*nt}return V})(w,A,this.inputResolution,o),r.flipHorizontal&&(R=(function(V,B){for(var z=0,U=V;z<U.length;z++)for(var D=0,Y=U[z].keypoints;D<Y.length;D++){var nt=Y[D];nt.x=B.width-1-nt.x}return V})(R,A));return a.dispose(),u.dispose(),Ne(h),d.dispose(),f.dispose(),m.dispose(),y.dispose(),x.dispose(),[2,s?[w,E]:R]}}))}))},n.prototype.getCanvasInfo=function(t,e,s){var r=t.height,i=t.width,a=r/(e.height*(1-s.top-s.bottom)),o=i/(e.width*(1-s.left-s.right)),u=-s.top*e.height;return[-s.left*e.width,u,o,a,t.width,t.height]},n.prototype.dispose=function(){this.posenetModel.dispose()},n.prototype.reset=function(){},n})();function PQ(n){return n===void 0&&(n=RT),de(this,void 0,void 0,(function(){var t,e,s,r,i;return fe(this,(function(a){switch(a.label){case 0:return(t=(function(d){var f=d||RT;if(f.architecture==null&&(f.architecture="MobileNetV1"),IT.indexOf(f.architecture)<0)throw new Error("Invalid architecture ".concat(f.architecture,". ")+"Should be one of ".concat(IT));if(f.inputResolution==null&&(f.inputResolution={height:257,width:257}),f.outputStride==null&&(f.outputStride=16),AT[f.architecture].indexOf(f.outputStride)<0)throw new Error("Invalid outputStride ".concat(f.outputStride,". ")+"Should be one of ".concat(AT[f.architecture]," ")+"for architecture ".concat(f.architecture,"."));if(f.multiplier==null&&(f.multiplier=1),DT[f.architecture].indexOf(f.multiplier)<0)throw new Error("Invalid multiplier ".concat(f.multiplier,". ")+"Should be one of ".concat(DT[f.architecture]," ")+"for architecture ".concat(f.architecture,"."));if(f.quantBytes==null&&(f.quantBytes=4),OT.indexOf(f.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(f.quantBytes,". ")+"Should be one of ".concat(OT," ")+"for architecture ".concat(f.architecture,"."));if(f.architecture==="MobileNetV1"&&f.outputStride===32&&f.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return f})(n)).architecture!=="ResNet50"?[3,2]:(o=t.outputStride,u=t.quantBytes,h="model-stride".concat(o,".json"),e=u===4?WT+"float/"+h:WT+"quant".concat(u,"/")+h,[4,Gu(t.modelUrl||e)]);case 1:return s=a.sent(),[2,new HT(s,t)];case 2:return r=(function(d,f,m){var y={1:"100",.75:"075",.5:"050"},x="model-stride".concat(d,".json");return m===4?UT+"float/".concat(y[f],"/")+x:UT+"quant".concat(m,"/").concat(y[f],"/")+x})(t.outputStride,t.multiplier,t.quantBytes),[4,Gu(t.modelUrl||r)];case 3:return i=a.sent(),[2,new HT(i,t)]}var o,u,h}))}))}function FQ(n,t){return de(this,void 0,void 0,(function(){var e,s;return fe(this,(function(r){switch(n){case vi.PoseNet:return[2,PQ(t)];case vi.BlazePose:if(s=void 0,(e=t)!=null){if(e.runtime==="tfjs")return[2,cQ(t)];if(e.runtime==="mediapipe")return[2,F9(t)];s=e.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(s));case vi.MoveNet:return[2,yQ(t)];default:throw new Error("".concat(n," is not a supported model name."))}}))}))}var LQ={modelType:{SINGLEPOSE_LIGHTNING:"SinglePose.Lightning"}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nl={},Jf={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function MQ(n,t){nl[n]=t}function ei(n,t){if(!(n in nl)||t!=null){const s=BQ(n,t);if(s!==null)nl[n]=s;else return console.log("Could not get context for WebGL version",n),null}const e=nl[n];return e==null||e.isContextLost()?(delete nl[n],ei(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),nl[n])}function zQ(n){if(!tt().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function BQ(n,t){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=t??zQ(n);return e.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete nl[n]},!1),tt().getBool("SOFTWARE_WEBGL_ENABLED")&&(Jf.failIfMajorPerformanceCaveat=!1),n===1?e.getContext("webgl",Jf)||e.getContext("experimental-webgl",Jf):e.getContext("webgl2",Jf)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ld;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(ld||(ld={}));var hr;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(hr||(hr={}));var zn;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(zn||(zn={}));function _d(n,t){return[t,n]}function VQ(n,t){return n*t}function tp(n){const t=ht(n),e=Math.ceil(t/4);return Px(e)}function sc(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function UQ(n,t){const[e,s]=sc(n,t);return e*s*4}function bw(n,t){const e=n;let s,r,i,a,o,u,h,d,f,m;return tt().getNumber("WEBGL_VERSION")===2?(s=e.R32F,r=e.R16F,i=e.RGBA16F,a=e.RGBA32F,o=e.RED,h=4,d=1,f=e.HALF_FLOAT,m=e.FLOAT,u=e.RGBA8):(s=n.RGBA,r=n.RGBA,i=n.RGBA,a=e.RGBA,o=n.RGBA,h=4,d=4,f=t!=null?t.HALF_FLOAT_OES:null,m=n.FLOAT,u=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:a,textureFormatFloat:o,downloadTextureFormat:u,downloadUnpackNumChannels:h,defaultNumChannels:d,textureTypeHalfFloat:f,textureTypeFloat:m}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rt(n,t){const e=t();return tt().getBool("DEBUG")&&WQ(n),e}function WQ(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+cI(n,t))}const GQ=596e-10,HQ=65504;function uI(n){return!!(tt().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||GQ<Math.abs(n)&&Math.abs(n)<HQ)}function cI(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function Ih(n,t){return da(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function hI(n,t){const e=da(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Rt(n,()=>n.shaderSource(e,t)),Rt(n,()=>n.compileShader(e)),n.getShaderParameter(e,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function dI(n,t){const e=da(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Rt(n,()=>n.shaderSource(e,t)),Rt(n,()=>n.compileShader(e)),tt().get("ENGINE_COMPILE_ONLY"))return e;if(n.getShaderParameter(e,n.COMPILE_STATUS)===!1)throw vw(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}const jQ=/ERROR: [0-9]+:([0-9]+):/g;function vw(n,t){const e=jQ.exec(t);if(e==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(n);return}const s=+e[1],r=n.split(`
`),i=r.length.toString().length+2,a=r.map((f,m)=>Ou((m+1).toString(),i)+f);let o=0;for(let f=0;f<a.length;f++)o=Math.max(a[f].length,o);const u=a.slice(0,s-1),h=a.slice(s-1,s),d=a.slice(s);console.log(u.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${Ou(h[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join(`
`))}function fI(n){return da(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function pI(n,t){if(Rt(n,()=>n.linkProgram(t)),!tt().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(t,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function Rp(n,t){if(Rt(n,()=>n.validateProgram(t)),n.getProgramParameter(t,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function mI(n,t){const e=da(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Rt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),Rt(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function gI(n,t){const e=da(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Rt(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),Rt(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function XQ(){return tt().getNumber("WEBGL_VERSION")===2?1:4}function yI(n){return da(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function xI(n,t){const e=tt().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0){const s=`[${n}x${t}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>e||t>e){const s=`[${n}x${t}]`,r=`[${e}x${e}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function bI(n){return da(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function w0(n,t,e,s,r,i,a){const o=n.getAttribLocation(t,e);return o===-1?!1:(Rt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),Rt(n,()=>n.vertexAttribPointer(o,r,n.FLOAT,!1,i,a)),Rt(n,()=>n.enableVertexAttribArray(o)),!0)}function vI(n,t,e){TI(n,e),Rt(n,()=>n.activeTexture(n.TEXTURE0+e)),Rt(n,()=>n.bindTexture(n.TEXTURE_2D,t))}function qQ(n,t){TI(n,t),Rt(n,()=>n.activeTexture(n.TEXTURE0+t)),Rt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function wI(n,t,e){return da(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}function SI(n,t,e){return n.getUniformLocation(t,e)}function CI(n,t,e,s){Rt(n,()=>vI(n,t,s)),Rt(n,()=>n.uniform1i(e,s))}function KQ(n){Rt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,null)),Rt(n,()=>n.viewport(0,0,n.canvas.width,n.canvas.height)),Rt(n,()=>n.scissor(0,0,n.canvas.width,n.canvas.height))}function Ip(n,t,e){Rt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),Rt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function S0(n,t){Rt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),Rt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Ah(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+$I(n,t))}function $I(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function da(n,t,e){const s=Rt(n,()=>t());if(s==null)throw new Error(e);return s}function TI(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=t+n.TEXTURE0;if(s<n.TEXTURE0||s>e){const r=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${r}.`)}}function vl(n,t=2){return ht(n.slice(0,n.length-t))}function wl(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Dh(n){let t=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(t=[vl(n),...wl(n)]),t}function kI(n,t=!1){let e=tt().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=tt().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&tt().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=e/2),t&&(e=e*2,s=s*2,n=n.map((o,u)=>u>=n.length-2?M0(n[u]):n[u]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=ro(n).newShape);let r=ht(n),i=null;n.length<=1&&r<=e?i=[1,r]:n.length===2&&n[0]<=e&&n[1]<=e?i=n:n.length===3&&n[0]*n[1]<=e&&n[2]<=e?i=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=e&&n[1]*n[2]<=e?i=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=e&&n[3]<=e?i=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=e&&n[1]*n[2]*n[3]<=e&&(i=[n[0],n[1]*n[2]*n[3]]);const a=i!=null&&Math.max(...i)>s&&Math.min(...i)<=(t?2:1)&&Math.min(...i)>0;if(i==null||a)if(t){const o=vl(n);let u=2,h=2;n.length&&([u,h]=wl(n)),r=o*(u/2)*(h/2),i=Px(r).map(d=>d*2)}else i=Px(r);return i}function ep(n){return n%2===0}function ud(n,t){if(n=n.slice(-2),t=t.slice(-2),Ee(n,t)||!n.length||!t.length||n[0]===0||n[1]===0||t[0]===0||t[1]===0)return!0;if(n.length!==t.length){const e=n[n.length-1],s=t[t.length-1];if(e===s||ep(e)&&ep(s)&&(n[0]===1||t[0]===1))return!0}return n[1]===t[1]&&ep(n[0])&&ep(t[0])}let Ap,Dp;function _I(n){if(Ap==null){const t=ei(n);Ap=t.getParameter(t.MAX_TEXTURE_SIZE)}return Ap}function YQ(){Ap=null}function QQ(){Dp=null}function NI(n){if(Dp==null){const t=ei(n);Dp=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Dp)}function EI(n){if(n===0)return 0;let t;const e=ei(n);return dr(e,"EXT_disjoint_timer_query_webgl2")&&n===2?t=2:dr(e,"EXT_disjoint_timer_query")?t=1:t=0,t}function dr(n,t){return n.getExtension(t)!=null}function C0(n){try{if(ei(n)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function RI(n){if(n===0)return!1;const t=ei(n);if(n===1){if(!dr(t,"OES_texture_float"))return!1}else if(!dr(t,"EXT_color_buffer_float"))return!1;return $0(t)}function II(n){if(n===0)return!1;const t=ei(n);if(n===1){if(!dr(t,"OES_texture_float")||!dr(t,"WEBGL_color_buffer_float"))return!1}else{if(dr(t,"EXT_color_buffer_float"))return $0(t);const s="EXT_color_buffer_half_float";if(dr(t,s)){const r=t.getExtension(s);return ZQ(t,r)}return!1}return $0(t)}function $0(n){const t=bw(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(i),a}function ZQ(n,t){const e=bw(n,t),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(a),o}function AI(n){return n!==2?!1:ei(n).fenceSync!=null}function rc(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&M(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const dpt=Object.freeze(Object.defineProperty({__proto__:null,assertNotComplex:rc,bindCanvasToFramebuffer:KQ,bindColorTextureToFramebuffer:Ip,bindTextureToProgramUniformSampler:CI,bindTextureUnit:vI,bindVertexBufferToProgramAttribute:w0,callAndCheck:Rt,canBeRepresented:uI,createFragmentShader:dI,createFramebuffer:bI,createProgram:fI,createStaticIndexBuffer:gI,createStaticVertexBuffer:mI,createTexture:yI,createVertexShader:hI,getBatchDim:vl,getExtensionOrThrow:Ih,getFramebufferErrorMessage:$I,getMaxTexturesInShader:NI,getNumChannels:XQ,getProgramUniformLocation:SI,getProgramUniformLocationOrThrow:wI,getRowsCols:wl,getShapeAs3D:Dh,getTextureShapeFromLogicalShape:kI,getWebGLDisjointQueryTimerVersion:EI,getWebGLErrorMessage:cI,getWebGLMaxTextureSize:_I,hasExtension:dr,isCapableOfRenderingToFloatTexture:RI,isDownloadFloatTextureEnabled:II,isReshapeFree:ud,isWebGLFenceEnabled:AI,isWebGLVersionEnabled:C0,linkProgram:pI,logShaderSourceAndInfoLog:vw,resetMaxTextureSize:YQ,resetMaxTexturesInShader:QQ,unbindColorTextureFromFramebuffer:S0,unbindTextureUnit:qQ,validateFramebuffer:Ah,validateProgram:Rp,validateTextureSize:xI},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lt=tt();Lt.registerFlag("HAS_WEBGL",()=>Lt.getNumber("WEBGL_VERSION")>0);Lt.registerFlag("WEBGL_VERSION",()=>C0(2)?2:C0(1)?1:0);Lt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Lt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Lt.get("WEBGL_VERSION")===2);Lt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Lt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Lt.registerFlag("WEBGL_PACK",()=>Lt.getBool("HAS_WEBGL"));Lt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Lt.getBool("WEBGL_PACK"));Lt.registerFlag("WEBGL_PACK_CLIP",()=>Lt.getBool("WEBGL_PACK"));Lt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Lt.getBool("WEBGL_PACK"));Lt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Lt.getBool("WEBGL_PACK"));Lt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Lt.getBool("WEBGL_PACK"));Lt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Lt.getBool("WEBGL_PACK"));Lt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Lt.getBool("WEBGL_PACK"));Lt.registerFlag("WEBGL_PACK_REDUCE",()=>Lt.getBool("WEBGL_PACK"));Lt.registerFlag("WEBGL_LAZILY_UNPACK",()=>Lt.getBool("WEBGL_PACK"));Lt.registerFlag("WEBGL_CONV_IM2COL",()=>Lt.getBool("WEBGL_PACK"));Lt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Lt.getBool("WEBGL_PACK"));Lt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>_I(Lt.getNumber("WEBGL_VERSION")));Lt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>NI(Lt.getNumber("WEBGL_VERSION")));Lt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Lt.getNumber("WEBGL_VERSION");return n===0?0:EI(n)});Lt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Lt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!kN());Lt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>RI(Lt.getNumber("WEBGL_VERSION")));Lt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Lt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Lt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Lt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>II(Lt.getNumber("WEBGL_VERSION")));Lt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>AI(Lt.getNumber("WEBGL_VERSION")));Lt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Lt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Lt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});Lt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>kN()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});Lt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Lt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Lt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Lt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Lt.registerFlag("WEBGL_EXP_CONV",()=>!1);Lt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Lt.getBool("IS_TEST"));Lt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Lt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Lt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Lt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ms(){let n,t,e,s,r,i,a,o,u,h;return tt().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",t="in",e="out",s="in",r="texture",i="outputColor",a="out vec4 outputColor;",o=tt().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",u="",h=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",t="attribute",e="varying",s="varying",r="texture2D",i="gl_FragColor",a="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,h=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:t,varyingVs:e,varyingFs:s,texture2D:r,output:i,defineOutput:a,defineSpecialNaN:o,defineSpecialInf:u,defineRound:h}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rl(n,t,e="index"){const s=cn(t);return s.map((r,i)=>{const a=`int ${n[i]} = ${e} / ${r}`,o=i===s.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * ${r}`:`index -= ${n[i]} * ${r}`;return`${a}; ${o};`}).join("")}function Fm(n,t,e="index"){const s=cn(t);return s.map((r,i)=>{const a=`int ${n[i]} = ${e} / outShapeStrides[${i}]`,o=i===s.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`;return`${a}; ${o};`}).join("")}function JQ(n,t){const e=n.length,s=n.map(i=>`${t}[${i}]`),r=new Array(e-1);r[e-2]=s[e-1];for(let i=e-3;i>=0;--i)r[i]=`(${r[i+1]} * ${s[i+1]})`;return r}function tZ(n,t,e="index"){const s=n.map((i,a)=>a),r=JQ(s,t);return r.map((i,a)=>{const o=`int ${n[a]} = ${e} / ${r[a]}`,u=a===r.length-1?`int ${n[a+1]} = ${e} - ${n[a]} * ${r[a]}`:`index -= ${n[a]} * ${r[a]}`;return`${o}; ${u};`}).join("")}function ww(n){const t=cn(n).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function Sw(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const DI=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:OI}=SW;function eZ(n,t,e){const s=[];if(n.forEach(y=>{const x=ht(y.shapeInfo.logicalShape);if(y.shapeInfo.isUniform?s.push(`uniform float ${y.name}${x>1?`[${x}]`:""};`):(s.push(`uniform sampler2D ${y.name};`),s.push(`uniform int offset${y.name};`)),e.enableShapeUniforms){const{uniformShape:w}=Cw(e.packedInputs,y.shapeInfo.logicalShape,y.shapeInfo.texShape);switch(w.length){case 1:s.push(`uniform int ${y.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${y.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${y.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${y.name}Shape;`);break}s.push(`uniform ivec2 ${y.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(y=>{s.push(`uniform ${y.type} ${y.name}${y.arrayIndex?`[${y.arrayIndex}]`:""};`)});const r=s.join(`
`),i=n.map(y=>nZ(y,t,e.packedInputs,e.enableShapeUniforms)).join(`
`),a=t.texShape,o=ms(),u=iZ(o);let h,d,f=lZ(o);return t.isPacked?(h=sZ(t.logicalShape,a,e.enableShapeUniforms),d=oZ(o)):(h=rZ(t.logicalShape,a,e.enableShapeUniforms),d=aZ(o)),e.packedInputs&&(f+=dZ),[f,u,d,r,h,i,e.userCode].join(`
`)}function ic(n,t=!1){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return $Z(n,t);case 1:return kZ(n,t);case 2:return NZ(n,t);case 3:return RZ(n,t);case 4:return AZ(n,t);case 5:return DZ(n);case 6:return OZ(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function PI(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return CZ(n);case 1:return TZ(n,t);case 2:return _Z(n,t);case 3:return EZ(n,t);default:return IZ(n,t)}}function nZ(n,t,e=!1,s){let r="";e?r+=PI(n,s):r+=ic(n,s);const i=n.shapeInfo.logicalShape,a=t.logicalShape;return i.length<=a.length&&(e?r+=PZ(n,t):r+=FZ(n,t)),r}function sZ(n,t,e){switch(n.length){case 0:return FI();case 1:return fZ(n,t,e);case 2:return wZ(n,t,e);case 3:return mZ(n,t,e);default:return yZ(n,t,e)}}function rZ(n,t,e){switch(n.length){case 0:return FI();case 1:return pZ(n,t,e);case 2:return SZ(n,t,e);case 3:return gZ(n,t,e);case 4:return xZ(n,t,e);case 5:return bZ(n,t);case 6:return vZ(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function iZ(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function aZ(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function oZ(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function lZ(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${uZ}
    ${cZ}
    ${hZ}
  `}const uZ=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,cZ=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,hZ=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,dZ=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function FI(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function fZ(n,t,e){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return s[0]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function pZ(n,t,e){return t[0]===1?e?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?e?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function mZ(n,t,e){if(e)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(n[2]/2),i=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function gZ(n,t,e){if(e)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Fm(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=Rl(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function yZ(n,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(n[n.length-1]/2),i=r*Math.ceil(n[n.length-2]/2);let a=i,o="",u="b, r, c";for(let h=2;h<n.length-1;h++)a*=n[n.length-h-1],o=`
      int b${h} = index / ${a};
      index -= b${h} * ${a};
    `+o,u=`b${h}, `+u;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${o}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${u});
    }
  `}function xZ(n,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Fm(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=Rl(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function bZ(n,t){const e=Rl(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function vZ(n,t){const e=Rl(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function wZ(n,t,e){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Ee(n,t))return e?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return e?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function SZ(n,t,e){return Ee(n,t)?e?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:n[1]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:e?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function Il(n){return`offset${n}`}function CZ(n){const t=n.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),s=ms();return`
    vec4 ${e}() {
      return ${s.texture2D}(${t}, halfCR);
    }
  `}function $Z(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${e};}`;const[r,i]=n.shapeInfo.texShape;if(r===1&&i===1)return`
      float ${s}() {
        return sampleTexture(${e}, halfCR);
      }
    `;const a=Il(e);if(t)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${a});
      return sampleTexture(${e}, uv);
    }
  `;const[o,u]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${o}, ${u}, ${a});
      return sampleTexture(${e}, uv);
    }
  `}function TZ(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=n.shapeInfo.texShape,i=ms();if(t)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${e}, uv);
    }
  `;const a=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${i.texture2D}(${e}, uv);
    }
  `}function kZ(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${ac(n)}
      }
    `;const r=n.shapeInfo.texShape,i=r[0],a=r[1];if(a===1&&i===1)return`
      float ${s}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;const o=Il(e);return a===1?t?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${e}TexShape[0]));
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${i}.0);
        return sampleTexture(${e}, uv);
      }
    `:i===1?t?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${e}TexShape[1]), 0.5);
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    `:t?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${o});
      return sampleTexture(${e}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${i}, ${a}, index + ${o});
      return sampleTexture(${e}, uv);
    }
  `}function _Z(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,a=i[0],o=i[1],u=ms();if(i!=null&&Ee(e,i))return t?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${u.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${a}.0);

        return ${u.texture2D}(${s}, uv);
      }
    `;if(t)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `;const h=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],d=Math.ceil(e[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${d}, ${h[0]}, ${h[1]}, row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `}function NZ(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape;if(i!=null&&Ee(e,i)){if(t)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const m=i[0],y=i[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${y}.0, ${m}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:a,keptDims:o}=ro(e),u=a;if(u.length<e.length){const m=oc(n,u),y=["row","col"];return`
      ${ic(m,t)}
      float ${r}(int row, int col) {
        return ${r}(${lc(y,o)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${ac(n)}
      }
    `;const h=i[0],d=i[1],f=Il(s);return d===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `:h===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:t?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${f};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${f};
    vec2 uv = uvFromFlat(${h}, ${d}, index);
    return sampleTexture(${s}, uv);
  }
`}function EZ(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(e[0]===1){const m=e.slice(1),y=[1,2],x=oc(n,m),w=["b","row","col"];return`
        ${PI(x,t)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${lc(w,y)});
        }
      `}const o=ms();if(t)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${s}, uv);
    }
  `;const u=a[0],h=a[1],d=Math.ceil(e[2]/2),f=d*Math.ceil(e[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${h}, ${f}, ${d}, b, row, col);
      return ${o.texture2D}(${s}, uv);
    }
  `}function RZ(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=e[1]*e[2],a=e[2],{newShape:o,keptDims:u}=ro(e),h=o;if(h.length<e.length){const w=oc(n,h),S=["row","col","depth"];return`
        ${ic(w,t)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${lc(S,u)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${a}, 1)));
        ${ac(n)}
      }
    `;const d=n.shapeInfo.texShape,f=d[0],m=d[1],y=n.shapeInfo.flatOffset;if(m===i&&y==null)return t?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${f}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(m===a&&y==null)return t?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${f}.0);
      return sampleTexture(${s}, uv);
    }
  `;const x=Il(s);return t?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${x};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${a} + depth + ${x};
        vec2 uv = uvFromFlat(${f}, ${m}, index);
        return sampleTexture(${s}, uv);
      }
  `}function IZ(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=ms();if(t)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${e}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${e}, uv);
    }
  `;const i=n.shapeInfo.logicalShape,a=i.length,o=n.shapeInfo.texShape,u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],h=u[0],d=u[1],f=Math.ceil(i[a-1]/2);let m=f*Math.ceil(i[a-2]/2),y="int b, int row, int col",x=`b * ${m} + (row / 2) * ${f} + (col / 2)`;for(let w=2;w<a-1;w++)y=`int b${w}, `+y,m*=i[a-w-1],x=`b${w} * ${m} + `+x;return`
    vec4 ${s}(${y}) {
      int index = ${x};
      int texR = index / ${d};
      int texC = index - texR * ${d};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${h});
      return ${r.texture2D}(${e}, uv);
    }
  `}function AZ(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=e[3],a=e[2]*i,o=e[1]*a,{newShape:u,keptDims:h}=ro(e);if(u.length<e.length){const k=oc(n,u),E=["row","col","depth","depth2"];return`
      ${ic(k,t)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${lc(E,h)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${a}, ${i}, 1)));
        ${ac(n)}
      }
    `;const d=n.shapeInfo.flatOffset,f=n.shapeInfo.texShape,m=f[0],y=f[1],x=`int stride2 = ${s}Shape[3];`,w=`int stride1 = ${s}Shape[2] * stride2;`,S=`int stride0 = ${s}Shape[1] * stride1;`;if(y===o&&d==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${x}
        ${w}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(y===i&&d==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1]*e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;const C=Il(s);return t?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${x}
      ${w}
      ${S}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${C});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${a} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${m}, ${y}, index + ${C});
      return sampleTexture(${s}, uv);
    }
  `}function DZ(n){const t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t[4],i=t[3]*r,a=t[2]*i,o=t[1]*a,{newShape:u,keptDims:h}=ro(t);if(u.length<t.length){const w=oc(n,u),S=["row","col","depth","depth2","depth3"];return`
      ${ic(w)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${lc(S,h)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${a}, ${i}, ${r})) +
          depth3;
        ${ac(n)}
      }
    `;const d=n.shapeInfo.flatOffset,f=n.shapeInfo.texShape,m=f[0],y=f[1];if(y===o&&d==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${i}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(y===r&&d==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;const x=Il(e);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${a} + depth * ${i} +
          depth2 * ${r} + depth3 + ${x};
      vec2 uv = uvFromFlat(${m}, ${y}, index);
      return sampleTexture(${e}, uv);
    }
  `}function OZ(n){const t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:r,keptDims:i}=ro(t);if(r.length<t.length){const S=oc(n,r),C=["row","col","depth","depth2","depth3","depth4"];return`
      ${ic(S)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${lc(C,i)});
      }
    `}const a=t[5],o=t[4]*a,u=t[3]*o,h=t[2]*u,d=t[1]*h;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${d}, ${h}, ${u}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${ac(n)}
      }
    `;const f=n.shapeInfo.flatOffset,m=n.shapeInfo.texShape,y=m[0],x=m[1];if(x===d&&f==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${h}, ${u}, ${o}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${x}.0, ${y}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(x===a&&f==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${x}.0, ${y}.0);
        return sampleTexture(${e}, uv);
      }
    `;const w=Il(e);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${d} + col * ${h} + depth * ${u} +
          depth2 * ${o} + depth3 * ${a} + depth4 + ${w};
      vec2 uv = uvFromFlat(${y}, ${x}, index);
      return sampleTexture(${e}, uv);
    }
  `}function ac(n){const t=n.name,e=ht(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function PZ(n,t){const e=n.name,s=e.charAt(0).toUpperCase()+e.slice(1),r="get"+s+"AtOutCoords",i=n.shapeInfo.logicalShape.length,a=t.logicalShape.length,o=OI(n.shapeInfo.logicalShape,t.logicalShape),u=Fe(a),h=a-i;let d;const f=["x","y","z","w","u","v"];i===0?d="":a<2&&o.length>=1?d="coords = 0;":d=o.map(k=>`coords.${f[k+h]} = 0;`).join(`
`);let m="";a<2&&i>0?m="coords":m=n.shapeInfo.logicalShape.map((k,E)=>`coords.${f[E+h]}`).join(", ");let y="return outputValue;";const w=ht(n.shapeInfo.logicalShape)===1,C=ht(t.logicalShape)===1;if(i===1&&!w&&!C)y=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(w&&!C)a===1?y=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:y=`
        return vec4(outputValue.x);
      `;else if(o.length){const k=i-2,E=i-1;o.indexOf(k)>-1&&o.indexOf(E)>-1?y="return vec4(outputValue.x);":o.indexOf(k)>-1?y="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(E)>-1&&(y="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${u} coords = getOutputCoords();
      ${d}
      vec4 outputValue = get${s}(${m});
      ${y}
    }
  `}function FZ(n,t){const e=n.name,s=e.charAt(0).toUpperCase()+e.slice(1),r="get"+s+"AtOutCoords",i=t.texShape,a=n.shapeInfo.texShape,o=n.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!n.shapeInfo.isUniform&&o===u&&n.shapeInfo.flatOffset==null&&Ee(a,i))return`
      float ${r}() {
        return sampleTexture(${e}, resultUV);
      }
    `;const h=Fe(u),d=OI(n.shapeInfo.logicalShape,t.logicalShape),f=u-o;let m;const y=["x","y","z","w","u","v"];o===0?m="":u<2&&d.length>=1?m="coords = 0;":m=d.map(w=>`coords.${y[w+f]} = 0;`).join(`
`);let x="";return u<2&&o>0?x="coords":x=n.shapeInfo.logicalShape.map((w,S)=>`coords.${y[S+f]}`).join(", "),`
    float ${r}() {
      ${h} coords = getOutputCoords();
      ${m}
      return get${s}(${x});
    }
  `}function Fe(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Cw(n,t,e){const{newShape:s,keptDims:r}=ro(t),i=t.length,a=n&&i===3&&t[0]===1,o=a?t.slice(1):s,u=!n&&i>1&&!Ee(t,e)&&s.length<i||a;return{useSqueezeShape:u,uniformShape:u?o:t,keptDims:r}}function oc(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function lc(n,t){return t.map(e=>n[e]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LZ(n,t,e,s){const r=e.map((d,f)=>{const m={logicalShape:d.shape,texShape:d.isUniform?null:d.texData.texShape,isUniform:d.isUniform,isPacked:d.isUniform?!1:d.texData.isPacked,flatOffset:null};return d.texData!=null&&d.texData.slice!=null&&d.texData.slice.flatOffset>0&&(m.flatOffset=d.texData.slice.flatOffset),{name:t.variableNames[f],shapeInfo:m}}),i=r.map(d=>d.shapeInfo),a={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},o=eZ(r,a,t),u=dI(n.gl,o),h=n.createProgram(u);return tt().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:u,source:o,webGLProgram:h,inShapeInfos:i,outShapeInfo:a,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(h),Object.assign({program:t,fragmentShader:u,source:o,webGLProgram:h,inShapeInfos:i,outShapeInfo:a},LI(n,t,h)))}function LI(n,t,e){const s=[],r=[];let i,a,o,u=null,h=null;h=n.getUniformLocation(e,"NAN",!1),tt().getNumber("WEBGL_VERSION")===1&&(u=n.getUniformLocation(e,"INFINITY",!1));const d=!1;for(const f of t.variableNames){const m={name:f,uniform:n.getUniformLocation(e,f,d),offset:n.getUniformLocation(e,`offset${f}`,d)};t.enableShapeUniforms&&(m.shape=n.getUniformLocation(e,`${f}Shape`,d),m.texShape=n.getUniformLocation(e,`${f}TexShape`,d)),s.push(m)}if(t.enableShapeUniforms&&(i=n.getUniformLocation(e,"outShape",d),o=n.getUniformLocation(e,"outShapeStrides",d),a=n.getUniformLocation(e,"outTexShape",d)),t.customUniforms)for(const f of t.customUniforms)r.push(n.getUniformLocation(e,f.name,d));return{variablesLocations:s,customUniformLocations:r,infLoc:u,nanLoc:h,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:a}}function jT(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,s)=>{const r=e.logicalShape,i=t[s],a=i.shape;if(!Ee(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(e.isUniform&&i.isUniform)return;const o=e.texShape,u=i.isUniform?null:i.texData.texShape;if(!Ee(o,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${u} must match`)})}function MZ(n,t,e,s,r){t.program.enableShapeUniforms||(jT(t.inShapeInfos,e),jT([t.outShapeInfo],[s]));const i=s.texData.texture,a=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,a[0],a[1]):n.setOutputMatrixTexture(i.texture,a[0],a[1]),n.setProgram(t.webGLProgram),n.bindVertexArray(t.webGLProgram.vao),tt().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&n.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&n.gl.uniform1f(t.nanLoc,NaN);for(let u=0;u<e.length;++u){const h=e[u],{uniform:d,offset:f,shape:m,texShape:y}=t.variablesLocations[u];if(m){const{uniformShape:x}=Cw(t.program.packedInputs,h.shape,h.texData.texShape);switch(x.length){case 1:n.gl.uniform1iv(m,new Int32Array(x));break;case 2:n.gl.uniform2iv(m,new Int32Array(x));break;case 3:n.gl.uniform3iv(m,new Int32Array(x));break;case 4:n.gl.uniform4iv(m,new Int32Array(x));break}}if(y&&n.gl.uniform2i(y,h.texData.texShape[0],h.texData.texShape[1]),d!=null){if(h.isUniform){if(ht(h.shape)<2)n.gl.uniform1f(d,h.uniformValues[0]);else{let x=h.uniformValues;x instanceof Float32Array||(x=new Float32Array(x)),n.gl.uniform1fv(d,x)}continue}h.texData.slice!=null&&f!=null&&n.gl.uniform1i(f,h.texData.slice.flatOffset),n.setInputMatrixTexture(h.texData.texture.texture,d,u)}}const o=t.outShapeLocation;if(o)switch(s.shape.length){case 1:n.gl.uniform1iv(o,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(o,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(o,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(o,new Int32Array(s.shape));break}if(t.outShapeStridesLocation){const u=cn(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(u));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(u));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(u));break}}if(t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),t.program.customUniforms&&r)for(let u=0;u<t.program.customUniforms.length;++u){const h=t.program.customUniforms[u],d=t.customUniformLocations[u],f=r[u];if(h.type==="float")n.gl.uniform1fv(d,f);else if(h.type==="vec2")n.gl.uniform2fv(d,f);else if(h.type==="vec3")n.gl.uniform3fv(d,f);else if(h.type==="vec4")n.gl.uniform4fv(d,f);else if(h.type==="int")n.gl.uniform1iv(d,f);else if(h.type==="ivec2")n.gl.uniform2iv(d,f);else if(h.type==="ivec3")n.gl.uniform3iv(d,f);else if(h.type==="ivec4")n.gl.uniform4iv(d,f);else throw Error(`uniform type ${h.type} is not supported yet.`)}n.executeProgram()}function zZ(n,t,e){let s="";t.concat(e).forEach(a=>{const o=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!a.isUniform){const u=a.texData.texShape,{useSqueezeShape:h,uniformShape:d,keptDims:f}=Cw(n.packedInputs,a.shape,u);let m="",y="",x="";if(d.length===1&&n.packedInputs){const A=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];m=`${A[0]>1}_${A[1]>1}`}else if(d.length===2&&!n.packedInputs)y=`${d[0]>1}_${d[1]>1}`;else if(d.length>2&&!n.packedInputs){const A=cn(d);x=`${A[0]===u[1]}_${A[A.length-1]===u[1]}`}const w=a.shape.length,S=d.length===2&&Ee(a.shape,u),C=ht(a.shape)===1,k=Wu(a.shape,e.shape),E=!n.packedInputs&&w===e.shape.length&&Ee(u,e.texData.texShape),R=n.packedInputs||d.length>2?"":`${u[0]>1}_${u[1]>1}`;s+=`${w}_${E}_${h?f:""}_${d.length}_${C}_${k}_${S}_${m}_${y}_${x}_${R}_${o}`}else{const u=a.isUniform?"uniform":a.texData.texShape;s+=`${a.shape}_${u}_${o}`}});const r=n.userCode;let i=n.constructor.name;return i+="_"+s+"_"+r+`${tt().getNumber("WEBGL_VERSION")}`,i}function ns(n){return tt().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BZ{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=ld.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=ms();this.outputShape=t,this.enableShapeUniforms=ns(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Fm(["r","c","d"],t):Rl(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${e.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VZ{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=ld.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=ms();this.outputShape=t,this.enableShapeUniforms=ns(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Fm(["r","c","d"],t):Rl(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${e.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UZ{constructor(t){this.variableNames=["A"],this.outTexUsage=hr.DOWNLOAD;const e=ms();this.outputShape=t,this.userCode=`
      ${DI}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WZ{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=hr.DOWNLOAD;const e=ms();this.outputShape=t,this.userCode=`
      ${DI}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GZ={R:0,G:1,B:2,A:3};class XT{constructor(t,e=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=ms();this.outputShape=t,this.enableShapeUniforms=ns(this.outputShape.length);let i="result";e&&(i="floor(result * 255. + 0.5)");let a="";for(let o=0;o<s.length;o++){const u=s[o];a+=`
          if(offset == ${o}) {
            result = values[${GZ[u]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?Sw():ww(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${a}
        }
        ${r.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HZ{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=ms();this.outputShape=t,this.enableShapeUniforms=ns(this.outputShape.length);let r="",i="result";e&&(i="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let o=0;o<=1;o++){const u=a*2+o;r+=`
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Sw():ww(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${i};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MI(n){const t=ms(),e=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return hI(n,e)}function zI(n){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return mI(n,t)}function BI(n){const t=new Uint16Array([0,1,2,2,1,3]);return gI(n,t)}function Nd(n,t,e,s,r,i){xI(t,e);const a=yI(n),o=n.TEXTURE_2D;return Rt(n,()=>n.bindTexture(o,a)),Rt(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),Rt(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),Rt(n,()=>n.texParameteri(o,n.TEXTURE_MIN_FILTER,n.NEAREST)),Rt(n,()=>n.texParameteri(o,n.TEXTURE_MAG_FILTER,n.NEAREST)),tt().getNumber("WEBGL_VERSION")===1?Rt(n,()=>n.texImage2D(o,0,s,t,e,0,r,i,null)):Rt(n,()=>n.texStorage2D(o,1,s,t,e)),Rt(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:a,texShape:[e,t]}}function $w(n){return n.internalFormatFloat}function VI(n,t,e,s){const[r,i]=_d(t,e);return Nd(n,r,i,$w(s),s.textureFormatFloat,n.FLOAT)}function Tw(n){return n.internalFormatHalfFloat}function UI(n,t,e,s){const[r,i]=_d(t,e);return Nd(n,r,i,Tw(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function kw(n){return n.downloadTextureFormat}function WI(n,t,e,s){const[r,i]=_d(t,e);return Nd(n,r,i,kw(s),n.RGBA,n.UNSIGNED_BYTE)}function _w(n){return n.internalFormatPackedFloat}function GI(n,t,e,s){const[r,i]=sc(t,e);return Nd(n,r,i,_w(s),n.RGBA,n.FLOAT)}function Nw(n){return n.internalFormatPackedHalfFloat}function HI(n,t,e,s){const[r,i]=sc(t,e);return Nd(n,r,i,Nw(s),n.RGBA,s.textureTypeHalfFloat)}function jI(n,t,e){return Rt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),w0(n,t,"clipSpacePos",e,3,20,0)&&w0(n,t,"uv",e,2,20,12)}function XI(n,t,e,s,r,i){Rt(n,()=>n.bindTexture(n.TEXTURE_2D,t));let a,o,u;r instanceof Uint8Array?(a=new Uint8Array(e*s*4),o=n.UNSIGNED_BYTE,u=n.RGBA):(a=new Float32Array(e*s*4),o=n.FLOAT,u=i.internalFormatPackedFloat),a.set(r),tt().getNumber("WEBGL_VERSION")===2?Rt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,s,n.RGBA,o,a)):Rt(n,()=>n.texImage2D(n.TEXTURE_2D,0,u,e,s,0,n.RGBA,o,a)),Rt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function qI(n,t,e){Rt(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?tt().getNumber("WEBGL_VERSION")===2?Rt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):Rt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):tt().getNumber("WEBGL_VERSION")===2?Rt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):Rt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),Rt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function KI(n,t,e,s){const r=n.createBuffer();Rt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const o=4*4*t*e;return Rt(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,o,n.STREAM_READ)),Rt(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),Rt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function YI(n,t,e){const s=n,r=new Float32Array(e);return s.bindBuffer(s.PIXEL_PACK_BUFFER,t),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function QI(n,t,e,s){const[r,i]=_d(t,e),a=4,o=new Uint8Array(VQ(t*e,a));return Rt(n,()=>n.readPixels(0,0,r,i,s.downloadTextureFormat,n.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function ZI(n,t,e,s,r,i,a,o){const u=n,h=new Float32Array(UQ(i,a));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,h),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),h}function JI(n,t,e){const s=new Float32Array(t*e*4);return Rt(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,s)),s}const fpt=Object.freeze(Object.defineProperty({__proto__:null,bindVertexProgramAttributeStreams:jI,createBufferFromOutputTexture:KI,createFloat16MatrixTexture:UI,createFloat16PackedMatrixTexture:HI,createFloat32MatrixTexture:VI,createIndexBuffer:BI,createPackedMatrixTexture:GI,createUnsignedBytesMatrixTexture:WI,createVertexBuffer:zI,createVertexShader:MI,downloadByteEncodedFloatMatrixFromOutputTexture:QI,downloadFloat32MatrixFromBuffer:YI,downloadMatrixFromPackedOutputTexture:JI,downloadPackedMatrixFromBuffer:ZI,getInternalFormatForFloat16MatrixTexture:Tw,getInternalFormatForFloat16PackedMatrixTexture:Nw,getInternalFormatForFloat32MatrixTexture:$w,getInternalFormatForPackedMatrixTexture:_w,getInternalFormatForUnsignedBytesMatrixTexture:kw,uploadDenseMatrixToTexture:XI,uploadPixelDataToTexture:qI},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $x{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=tt().getNumber("WEBGL_VERSION");if(t!=null?(this.gl=t,MQ(e,t)):this.gl=ei(e),t=this.gl,tt().getNumber("WEBGL_VERSION")===2){const i=t;this.createVertexArray=()=>Rt(i,()=>i.createVertexArray()),this.bindVertexArray=a=>Rt(i,()=>i.bindVertexArray(a)),this.deleteVertexArray=a=>Rt(i,()=>i.deleteVertexArray(a)),this.getVertexArray=()=>Rt(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(t!=null){const i=t.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Rt(t,()=>i.createVertexArrayOES()),this.bindVertexArray=a=>Rt(t,()=>i.bindVertexArrayOES(a)),this.deleteVertexArray=a=>Rt(t,()=>i.deleteVertexArrayOES(a)),this.getVertexArray=()=>Rt(t,()=>t.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),tt().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=Ih(this.gl,i),dr(this.gl,a))this.textureHalfFloatExtension=Ih(this.gl,a);else if(tt().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),dr(this.gl,r))this.colorBufferHalfFloatExtension=Ih(this.gl,r);else if(tt().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",dr(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(dr(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=zI(this.gl),this.indexBuffer=BI(this.gl),this.framebuffer=bI(this.gl),this.textureConfig=bw(this.gl,this.textureHalfFloatExtension)}get debug(){return tt().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;Rt(t,()=>t.finish()),Rt(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),Rt(t,()=>t.deleteFramebuffer(this.framebuffer)),Rt(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),Rt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),Rt(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),VI(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),UI(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),WI(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),qI(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,s,r){this.throwIfDisposed(),XI(this.gl,t,e,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),HI(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),GI(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(S0(this.gl,this.framebuffer),this.outputTexture=null),Rt(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,s){return this.downloadMatrixDriver(t,()=>QI(this.gl,e,s,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,s,r,i,a){return ZI(this.gl,t,e,s,r,i,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return YI(this.gl,t,e)}createBufferFromTexture(t,e,s){this.bindTextureToFrameBuffer(t);const r=KI(this.gl,e,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,s;if(tt().getBool("WEBGL_FENCE_API_ENABLED")){const r=t,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),s=()=>{const a=r.clientWaitSync(i,0,0);return a===r.ALREADY_SIGNALED||a===r.CONDITION_SATISFIED},e=i}else tt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(e,tt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:e,isFencePassed:s}}downloadMatrixFromPackedTexture(t,e,s){return this.downloadMatrixDriver(t,()=>JI(this.gl,e,s))}createProgram(t){this.throwIfDisposed();const e=this.gl;this.vertexShader==null&&(this.vertexShader=MI(e));const s=fI(e);Rt(e,()=>e.attachShader(s,this.vertexShader)),Rt(e,()=>e.attachShader(s,t)),pI(e,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&Rp(e,r),r}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const e=this.gl;Rt(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),jI(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&(Rt(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&Rp(this.gl,this.program),Rt(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,s=!0){return this.throwIfDisposed(),s?wI(this.gl,t,e):SI(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),Rt(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,s){this.throwIfDisposed(),this.throwIfNoProgram(),CI(this.gl,t,e,s)}setOutputMatrixTexture(t,e,s){this.setOutputMatrixTextureDriver(t,s,e)}setOutputPackedMatrixTexture(t,e,s){this.throwIfDisposed();const[r,i]=sc(e,s);this.setOutputMatrixTextureDriver(t,r,i)}setOutputMatrixWriteRegion(t,e,s,r){this.setOutputMatrixWriteRegionDriver(s,t,r,e)}setOutputPackedMatrixWriteRegion(t,e,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Rp(this.gl,this.program),Ah(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Rt(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Rt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Ih(this.gl,tt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(tt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,i),i}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(tt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const e=this.gl,s=this.getQueryTimerExtensionWebGL2();e.endQuery(s.TIME_ELAPSED_EXT);return}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await f$(()=>this.disposed||this.isQueryAvailable(t,tt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,tt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(e===0)return null;if(e===2){const s=this.gl;return s.getQueryParameter(t,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(t,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(e===0)return!0;if(e===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.getQueryParameter(t,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(t,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=jZ(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:s}=this.itemsToPoll[e];s()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in tt().platform&&(s=tt().platform.setTimeoutCustom.bind(tt().platform)),f$(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),Ip(this.gl,t,this.framebuffer),this.debug&&Ah(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Ip(this.gl,this.outputTexture,this.framebuffer),this.debug&&Ah(this.gl)):S0(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const s=e();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(t,e,s){this.throwIfDisposed();const r=this.gl;Ip(r,t,this.framebuffer),this.debug&&Ah(r),this.outputTexture=t,Rt(r,()=>r.viewport(0,0,e,s)),Rt(r,()=>r.scissor(0,0,e,s))}setOutputMatrixWriteRegionDriver(t,e,s,r){this.throwIfDisposed(),Rt(this.gl,()=>this.gl.scissor(t,e,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function jZ(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:XZ,bincountImpl:t3,bincountReduceImpl:qZ,bitwiseAndImpl:KZ,castImpl:YZ,ceilImpl:QZ,concatImpl:ZZ,equalImpl:JZ,expImpl:tJ,expm1Impl:eJ,floorImpl:nJ,gatherNdImpl:sJ,gatherV2Impl:rJ,greaterImpl:iJ,greaterEqualImpl:aJ,lessImpl:oJ,lessEqualImpl:lJ,linSpaceImpl:uJ,logImpl:cJ,maxImpl:hJ,maximumImpl:dJ,minimumImpl:fJ,multiplyImpl:pJ,negImpl:mJ,notEqualImpl:gJ,prodImpl:yJ,raggedGatherImpl:xJ,raggedRangeImpl:bJ,raggedTensorToTensorImpl:vJ,rangeImpl:wJ,rsqrtImpl:SJ,scatterImpl:CJ,sigmoidImpl:$J,simpleAbsImpl:e3,sliceImpl:TJ,sparseFillEmptyRowsImpl:kJ,sparseReshapeImpl:_J,sparseSegmentReductionImpl:n3,sqrtImpl:NJ,staticRegexReplaceImpl:EJ,stridedSliceImpl:RJ,stringNGramsImpl:IJ,stringSplitImpl:AJ,stringToHashBucketFastImpl:DJ,subImpl:OJ,tileImpl:PJ,topKImpl:FJ,transposeImpl:Ew,uniqueImpl:LJ}=SR;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s3(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function hs(n,t){return t===1?[n]:s3(n,t)}function MJ(n,t){if(n===1)return"rc";let e="";for(let s=0;s<n;s++)e+=t[s],s<n-1&&(e+=",");return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zJ{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=ns(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const e=hs("rc",this.rank),s=Fe(this.rank),r=this.getOutOfBoundsCondition(e),i=this.getSetup(e),a=this.getOutput(e);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(t){const e=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let i=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)i=`${t[t.length-1-a]},`+i;e.push(i)}return e}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let s=this.rank-2;s<this.rank;s++)e+=`${t[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(e+="||");return e}getSetup(t){if(this.rank===1)return"";const e=t.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${e[0]};
      int c = ${e[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(t){const e=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),
            cEdge ? 0. : getA(${e[1]}),
            rEdge ? 0. : getA(${e[2]}),
            rEdge || cEdge ? 0. : getA(${e[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r3{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=ns(this.outputShape.length);let s="";for(let r=0;r<4;r++){let i="thisRC = rc;";r%2===1&&(i+="thisRC.z += 1;"),r>1&&(i+="thisRC.y += 1;"),s+=`
        ${i}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${BJ(e,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Sw():ww(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${s}

        setOutput(result);
      }
    `}}function BJ(n,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?tZ(["r","c","d"],"inputShape"):Rl(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VJ{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,s){const r=KT(e,s),i=YT(t,r,s);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const a=qT(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const u=this.freeTextures[i].pop();return this.usedTextures[i].push(u),u}let o;return r===zn.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===zn.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===zn.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===zn.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===zn.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[i].push(o),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),o}releaseTexture(t,e,s,r){if(this.freeTextures==null)return;const i=KT(s,r),a=YT(e,i,r);a in this.freeTextures||(this.freeTextures[a]=[]);const o=qT(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),u=tt().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=o):(this.freeTextures[a].push(t),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const h=this.usedTextures[a],d=h&&h.indexOf(t);if(d==null||d<0)throw new Error("Cannot release a texture that was never provided by this texture manager");h[d]=h[h.length-1],h.pop(),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function UJ(n,t){const e=n;if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===e.RGBA16F)return 8;if(t===e.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function qT(n,t,e,s,r){const i=WJ(t,s);let a;if(r){const[u,h]=sc(n[0],n[1]);a=u*h}else{const[u,h]=_d(n[0],n[1]);a=u*h}const o=UJ(e,i);return a*o}function WJ(n,t){switch(n){case zn.PACKED_2X2_FLOAT32:return _w(t);case zn.PACKED_2X2_FLOAT16:return Nw(t);case zn.UNPACKED_FLOAT32:return $w(t);case zn.UNPACKED_FLOAT16:return Tw(t);case zn.PACKED_4X1_UNSIGNED_BYTE:return kw(t);default:throw new Error(`Unknown physical texture type ${n}`)}}function GJ(n){return tt().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?zn.PACKED_2X2_FLOAT32:zn.UNPACKED_FLOAT32:n?zn.PACKED_2X2_FLOAT16:zn.UNPACKED_FLOAT16}function KT(n,t){if(n===hr.UPLOAD)return zn.PACKED_2X2_FLOAT32;if(n===hr.RENDER||n==null)return GJ(t);if(n===hr.DOWNLOAD||n===hr.PIXELS)return zn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function YT(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yi{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=ns(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Br="if (isnan(x)) return x;",HJ="return x;",QT="return abs(x);",jJ="return (x >= 0.0) ? x : (exp(x) - 1.0);",XJ=Br+`
  return (x < 0.0) ? 0.0 : x;
`,qJ=Br+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Ua="return x;",KJ="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YJ="return x;",QJ=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,ZJ=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,JJ=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ttt="return 1.0 / (1.0 + exp(-1.0 * x));";class Ha{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=ns(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ett{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=ns(this.outputShape.length);const e=t.length,s=hs("rc",e),r=Fe(e),i=MJ(e,s),a=s.slice(-2),o=e<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${o}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ntt=kE,stt=1e-7,rtt=1e-4,np={};function itt(n){return n in np||(np[n]={}),np[n]}const att=tt().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),ott=600;function ltt(){return tt().global.screen==null?1024:tt().global.screen.height*tt().global.screen.width*window.devicePixelRatio*ott/1024/1024}class Lm extends L0{nextDataId(){return Lm.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!tt().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let e;if(t!=null){if(t instanceof $x)e=t;else{const s=ei(tt().getNumber("WEBGL_VERSION"),t);e=new $x(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=ei(tt().getNumber("WEBGL_VERSION"));e=new $x(s),this.binaryCache=itt(tt().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=e,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new VJ(this.gpgpu),this.numMBBeforeWarning=ltt(),this.texData=new F_(this,Gs())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,e,s,r,i,a){const o=this.makeTensorInfo(e,s),u=this.texData.get(o.dataId);u.isPacked=!1,u.texture={texture:t,texShape:[r,i]},u.texShape=[r,i];const h=Dh(e),d=new XT(h,!1,a),f=this.runWebGLProgram(d,[o],s,[[r,i]]);return f.shape=e,u.texture=null,this.disposeIntermediateTensorInfo(o),f.dataId}write(t,e,s){if((tt().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||tt().getBool("DEBUG"))&&this.checkNumericalProblems(t),s==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:e,dtype:s,values:t,usage:hr.UPLOAD,refCount:1}),r}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){const e=this.texData.get(t);e.refCount++}decRef(t){if(this.texData.has(t)){const e=this.texData.get(t);e.refCount--}}move(t,e,s,r,i){if(tt().getBool("DEBUG")&&this.checkNumericalProblems(e),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:s,dtype:r,values:e,usage:hr.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const e=this.texData.get(t),{values:s,dtype:r,complexTensorInfos:i,slice:a,shape:o,isPacked:u}=e;if(a!=null){let m;u?m=new Ha(o,Ua):m=new yi(o,Ua);const y=this.runWebGLProgram(m,[{dataId:t,shape:o,dtype:r}],r),x=this.readSync(y.dataId);return this.disposeIntermediateTensorInfo(y),x}if(s!=null)return this.convertAndCacheOnCPU(t);if(r==="string")return s;const h=this.activeTimers!=null;let d;h&&(d=Yr());let f;if(r==="complex64"){const m=this.readSync(i.real.dataId),y=this.readSync(i.imag.dataId);f=rd(m,y)}else f=this.getValuesFromTexture(t);return h&&(this.downloadWaitMs+=Yr()-d),this.convertAndCacheOnCPU(t,f)}async read(t){if(this.pendingRead.has(t)){const x=this.pendingRead.get(t);return new Promise(w=>x.push(w))}const e=this.texData.get(t),{values:s,shape:r,slice:i,dtype:a,complexTensorInfos:o,isPacked:u}=e;if(i!=null){let x;u?x=new Ha(r,Ua):x=new yi(r,Ua);const w=this.runWebGLProgram(x,[{dataId:t,shape:r,dtype:a}],a),S=this.read(w.dataId);return this.disposeIntermediateTensorInfo(w),S}if(s!=null)return this.convertAndCacheOnCPU(t);if(tt().getBool("DEBUG")&&!tt().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&tt().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h=null,d;if(a!=="complex64"&&tt().get("WEBGL_BUFFER_SUPPORTED")){d=this.decode(t);const x=this.texData.get(d.dataId);h=this.gpgpu.createBufferFromTexture(x.texture.texture,...tp(r))}this.pendingRead.set(t,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let f;if(a==="complex64"){const x=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),w=x[0],S=x[1];f=rd(w,S)}else if(h==null)f=this.getValuesFromTexture(t);else{const x=ht(r);f=this.gpgpu.downloadFloat32MatrixFromBuffer(h,x)}if(d!=null&&this.disposeIntermediateTensorInfo(d),h!=null){const x=this.gpgpu.gl;Rt(x,()=>x.deleteBuffer(h))}const m=this.convertAndCacheOnCPU(t,f),y=this.pendingRead.get(t);return this.pendingRead.delete(t),y.forEach(x=>x(m)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&Gs().removeDataId(t,this),this.pendingDeletes--),m}readToGPU(t,e={}){const s=this.texData.get(t),{values:r,shape:i,slice:a,dtype:o,isPacked:u,texture:h}=s;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let y;u?y=new Ha(i,Ua):y=new yi(i,Ua);const x=this.runWebGLProgram(y,[{dataId:t,shape:i,dtype:o}],o),w=this.readToGPU(x,e);return this.disposeIntermediateTensorInfo(x),w}if(h==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(t,e.customTexShape),f=Gs().makeTensorFromTensorInfo(d),m=this.texData.get(d.dataId);return Object.assign({tensorRef:f},m.texture)}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const s=e.map(r=>ea(r));return Re(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Re(t.shape,t.dtype,e)}checkNumericalProblems(t){if(t!=null)for(let e=0;e<t.length;e++){const s=t[e];if(!uI(s))throw tt().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(t){const{shape:e,dtype:s,isPacked:r}=this.texData.get(t),i=ht(e);if(tt().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const m=this.decode(t),y=this.texData.get(m.dataId),x=this.gpgpu.downloadMatrixFromPackedTexture(y.texture.texture,...tp(e)).subarray(0,i);return this.disposeIntermediateTensorInfo(m),x}const a=tt().getBool("WEBGL_PACK")&&r===!0,o=a?Dh(e):e,u=a?new WZ(o):new UZ(o),h=this.runWebGLProgram(u,[{shape:o,dtype:s,dataId:t}],"float32"),d=this.texData.get(h.dataId),f=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(h),f}timerAvailable(){return tt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const e=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,t();const i=na(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),a=na(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=e,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(tt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const u=await Promise.all(i);o.kernelMs=L_(u),o.getExtraProfileInfo=()=>u.map((h,d)=>({name:a[d],ms:h})).map(h=>`${h.name}: ${h.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return tt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Yr(),endMs:null}}endTimer(t){return tt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=Yr(),t)}async getQueryTime(t){if(tt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const e=t;return e.endMs-e.startMs}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:s}=this.texData.get(t);return s!=null&&(this.disposeData(s.real.dataId,e),this.disposeData(s.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:e,dtype:s,texShape:r,usage:i,isPacked:a,slice:o}=this.texData.get(t),u=o&&o.origDataId||t,h=this.dataRefCount.get(u);h>1?this.dataRefCount.set(u,h-1):(this.dataRefCount.delete(u),e!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(e,r,i,a)));const d=this.texData.get(t);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,e=att){return tt().getBool("WEBGL_CPU_FORWARD")&&t.every(s=>this.texData.get(s.dataId).texture==null&&ht(s.shape)<e)}getGPGPUContext(){return this.gpgpu}where(t){Jr("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return ntt(t.shape,e)}packedUnaryOp(t,e,s){const r=new Ha(t.shape,e),i=this.compileAndRun(r,[t],s);return Gs().makeTensorFromTensorInfo(i)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){const r=e3(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,r)}if(tt().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,QT,t.dtype);const e=new yi(t.shape,QT),s=this.compileAndRun(e,[t]);return Gs().makeTensorFromTensorInfo(s)}makeTensorInfo(t,e,s){let r;if(e==="string"&&s!=null&&s.length>0&&xd(s[0])){const i=s.map(a=>Ka(a));r=this.write(i,t,e)}else r=this.write(s,t,e);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:e}}makeOutput(t,e,s){return Gs().makeTensorFromTensorInfo(this.makeTensorInfo(t,e,s),this)}unpackTensor(t){const e=new ett(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new zJ(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const s=[vl(t.shape),...wl(t.shape)],r={dtype:t.dtype,shape:s,dataId:t.dataId},i=[vl(e),...wl(e)],a=new r3(i,s),o=!0,u=[s],h=this.runWebGLProgram(a,[r],t.dtype,u,o);return{dataId:h.dataId,shape:e,dtype:h.dtype}}decode(t,e){const s=this.texData.get(t),{isPacked:r,shape:i,dtype:a}=s;if(e!=null){const m=ht(i),y=e[0]*e[1]*4;M(m<=y,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const o=Dh(i);let u;r?u=new VZ(o):u=new BZ(o);const h=!0,d=[e??tp(o)],f=this.runWebGLProgram(u,[{shape:o,dtype:a,dataId:t}],a,d,h,e);return{dtype:a,shape:i,dataId:f.dataId}}runWebGLProgram(t,e,s,r,i=!1,a){const o=this.makeTensorInfo(t.outputShape,s),u=this.texData.get(o.dataId);if(t.packedOutput&&(u.isPacked=!0),t.outPackingScheme===ld.DENSE){const C=a??tp(t.outputShape);u.texShape=C.map(k=>k*2)}if(t.outTexUsage!=null&&(u.usage=t.outTexUsage),ht(o.shape)===0)return u.values=Si(o.dtype,0),o;const h=[],d=e.map(C=>{if(C.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let k=this.texData.get(C.dataId);if(k.texture==null){if(!t.packedInputs&&ht(C.shape)<=tt().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:C.shape,texData:null,isUniform:!0,uniformValues:k.values};t.packedInputs&&(k.isPacked=!0,k.shape=C.shape)}if(this.uploadToGPU(C.dataId),!!k.isPacked!=!!t.packedInputs)C=k.isPacked?this.unpackTensor(C):this.packTensor(C),h.push(C),k=this.texData.get(C.dataId);else if(k.isPacked&&!ud(k.shape,C.shape)){const E=C,R=C.shape;C.shape=k.shape,C=this.packedReshape(C,R),h.push(C),k=this.texData.get(C.dataId),E.shape=R}return{shape:C.shape,texData:k,isUniform:!1}});this.uploadToGPU(o.dataId);const f={shape:o.shape,texData:u,isUniform:!1},m=zZ(t,d,f),y=this.getAndSaveBinary(m,()=>LZ(this.gpgpu,t,d,f)),x=this.activeTimers!=null;let w;x&&(w=this.startTimer()),tt().get("ENGINE_COMPILE_ONLY")||MZ(this.gpgpu,y,d,f,r),h.forEach(C=>this.disposeIntermediateTensorInfo(C)),x&&(w=this.endTimer(w),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(w)}));const S=tt().getNumber("WEBGL_FLUSH_THRESHOLD");if(S>0){const C=Yr();C-this.lastGlFlushTime>S&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=C)}if(!tt().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&i===!1){const C=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),C}return o}compileAndRun(t,e,s,r,i=!1){return s=s||e[0].dtype,this.runWebGLProgram(t,e,s,r,i)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(tt().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Yt(()=>{if(!tt().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=tt().getBool("DEBUG");tt().set("DEBUG",!1);const e=this.abs(ie(1e-8)).dataSync()[0];if(tt().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?stt:rtt}uploadToGPU(t){const e=this.texData.get(t),{shape:s,dtype:r,values:i,texture:a,usage:o,isPacked:u}=e;if(a!=null)return;const h=this.activeTimers!=null;let d;h&&(d=Yr());let f=e.texShape;if(f==null&&(f=kI(s,u),e.texShape=f),i!=null){const m=Dh(s);let y,x=f[1],w=f[0];const S=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(u||!S)&&([x,w]=sc(f[0],f[1])),u?y=new HZ(m,S):y=new XT(m,S);const C=S?[w,x]:f,k=this.makeTensorInfo(C,r),E=this.texData.get(k.dataId);S?E.usage=hr.PIXELS:E.usage=hr.UPLOAD,E.texShape=C,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(k.dataId),x,w,i);const R=[[w,x]],L=this.runWebGLProgram(y,[k],r,R,!0),V=this.texData.get(L.dataId);e.texShape=V.texShape,e.isPacked=V.isPacked,e.usage=V.usage,tt().get("ENGINE_COMPILE_ONLY")?this.disposeData(L.dataId):(e.texture=V.texture,e.values=null,this.texData.delete(L.dataId)),this.disposeIntermediateTensorInfo(k),h&&(this.uploadWaitMs+=Yr()-d)}else{const m=this.acquireTexture(f,o,r,u);e.texture=m}}convertAndCacheOnCPU(t,e){const s=this.texData.get(t),{dtype:r}=s;return e!=null&&(s.values=utt(e,r)),s.values}acquireTexture(t,e,s,r){if(this.numBytesInGPU+=this.computeBytes(t,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,r)}computeBytes(t,e){return t[0]*t[1]*Mp(e)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,e]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(e));return Promise.all(t)}else{for(const[,e]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(e),r(!0)}catch(i){throw i}});t.push(s)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await hW(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(vw(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);const{variablesLocations:e,customUniformLocations:s,infLoc:r,nanLoc:i,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:u}=LI(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=e,t.customUniformLocations=s,t.infLoc=r,t.nanLoc=i,t.outShapeLocation=a,t.outShapeStridesLocation=o,t.outTexShapeLocation=u}}createTensorFromGPUData(t,e,s){t.channels=t.channels||"RGBA";const{texture:r,height:i,width:a,channels:o}=t,u=Gs().backend;if(!u.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const h=u.writeTexture(r,e,s,i,a,o);return Gs().makeTensorFromDataId(h,e,s,u)}}Lm.nextDataId=0;function utt(n,t){if(t==="float32"||t==="complex64")return n;if(t==="int32"||t==="bool"){const e=t==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<e.length;++s)e[s]=Math.round(n[s]);return e}else throw new Error(`Unknown dtype ${t}`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ctt(){tt().set("WEBGL_FORCE_F16_TEXTURES",!0)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_N()&&RN("webgl",()=>new Lm,2);const ppt={forceHalfFloat:ctt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rw=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class Sl{constructor(t,e,s){this.variableNames=["A","B"],this.outputShape=ne(e,s),this.enableShapeUniforms=ns(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Al=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class uc{constructor(t,e,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=ne(e,s);const i=this.outputShape.length;this.enableShapeUniforms=ns(i);let a="";if(r)if(i===0||ht(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${Fe(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const u=hs("coords",i);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${u[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${u[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${u[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${u[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qs(n){const{inputs:t,backend:e}=n,{x:s}=t;return e.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const htt={kernelName:gm,backendName:"webgl",kernelFunc:qs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uo(n){const{inputs:t,backend:e}=n,{real:s,imag:r}=t,i=e.makeTensorInfo(s.shape,"complex64"),a=e.texData.get(i.dataId),o=qs({inputs:{x:s},backend:e}),u=qs({inputs:{x:r},backend:e});return a.complexTensorInfos={real:o,imag:u},i}const dtt={kernelName:lb,backendName:"webgl",kernelFunc:uo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i3="return (a < 0.) ? b * a : a;",a3=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function ftt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{alpha:i}=s,a=e.makeTensorInfo([],"float32",Zu(i,"float32")),o=tt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new uc(a3,r.shape,a.shape):new Sl(i3,r.shape,a.shape),u=e.runWebGLProgram(o,[r,a],"float32");return e.disposeIntermediateTensorInfo(a),u}const ptt={kernelName:Qb,backendName:"webgl",kernelFunc:ftt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o3="return (a < 0.) ? b * a : a;",l3=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function mtt(n){const{inputs:t,backend:e}=n,{x:s,alpha:r}=t,i=tt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new uc(l3,s.shape,r.shape):new Sl(o3,s.shape,r.shape);return e.runWebGLProgram(i,[s,r],"float32")}const gtt={kernelName:N1,backendName:"webgl",kernelFunc:mtt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cc="if (isnan(x)) return x;";function me({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:s}){return({inputs:r,backend:i})=>{const{x:a}=r,o=i,u=s||a.dtype;if(o.shouldExecuteOnCPU([a])&&e!=null){const f=o.texData.get(a.dataId),m=e(f.values,u);return o.makeTensorInfo(a.shape,u,m)}const h=tt().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null;let d;return h?d=new Ha(a.shape,t):d=new yi(a.shape,n),o.runWebGLProgram(d,[a],u)}}function Vn({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}){return({inputs:a,backend:o})=>{const{a:u,b:h}=a,d=o;if(s&&u.dtype==="complex64"){const x=d.texData.get(u.dataId),w=d.texData.get(h.dataId),[S,C]=[[x.complexTensorInfos.real,w.complexTensorInfos.real],[x.complexTensorInfos.imag,w.complexTensorInfos.imag]].map(E=>{const[R,A]=E,L={dataId:R.dataId,dtype:R.dtype,shape:u.shape},V={dataId:A.dataId,dtype:A.dtype,shape:h.shape},B=new Sl(n,u.shape,h.shape);return d.runWebGLProgram(B,[L,V],Ns(R.dtype,A.dtype))}),k=uo({inputs:{real:S,imag:C},backend:d});return d.disposeIntermediateTensorInfo(S),d.disposeIntermediateTensorInfo(C),k}const f=i||Ns(u.dtype,h.dtype);if((u.dtype==="string"||h.dtype==="string"||d.shouldExecuteOnCPU([u,h]))&&r!=null){const x=d.texData.get(u.dataId).values,w=d.texData.get(h.dataId).values,S=u.dtype==="string"?no(x):x,C=u.dtype==="string"?no(w):w,[k,E]=r(u.shape,h.shape,S,C,f),R=d.makeTensorInfo(E,f),A=d.texData.get(R.dataId);return A.values=k,R}const m=tt().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null;let y;return m?y=new uc(t,u.shape,h.shape,e):y=new Sl(n,u.shape,h.shape),d.runWebGLProgram(y,[u,h],f)}}function cd(n,t=!1){if(n==="linear")return t?YJ:HJ;if(n==="relu")return t?ZJ:XJ;if(n==="elu")return t?QJ:jJ;if(n==="relu6")return t?JJ:qJ;if(n==="prelu")return t?l3:o3;if(n==="leakyrelu")return t?a3:i3;if(n==="sigmoid")return t?ttt:KJ;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class u3{constructor(t,e,s,r=!1,i=!1,a=!1,o=null,u=!1,h=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=ns(this.outputShape.length);const d=r?t[1]:t[2],f=Math.ceil(d/2),m=r?"i * 2, rc.y":"rc.y, i * 2",y=i?"rc.z, i * 2":"i * 2, rc.z",x=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],w=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let S="",C="";o&&(u?S=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:h?S=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:S=`vec4 activation(vec4 x) {
          ${o}
        }`,C="result = activation(result);");const k=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),h&&this.variableNames.push("leakyreluAlpha");let E="rc.x",R="rc.x";t[0]<e[0]?E=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&(R=`imod(rc.x, ${e[0]})`),this.userCode=`
      ${S}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${f}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${E};
        int batchB = ${R};
        for (int i = 0; i < ${f}; i++) {
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${y});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${x[0]} * ${w[0]});
          result += (${x[1]} * ${w[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${k}

        ${C}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZT={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class JT{constructor(t,e,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=ne(e,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tk="return a * b;";function Iw(n){const{inputs:t,backend:e}=n,{a:s,b:r}=t,i=Ns(s.dtype,r.dtype);if(s.dtype==="complex64"){const o=e.texData.get(s.dataId),u=e.texData.get(r.dataId),h=new JT(ZT.REAL,s.shape,r.shape),d=new JT(ZT.IMAG,s.shape,r.shape),f=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:s.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:r.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:r.shape}],m=e.runWebGLProgram(h,f,"float32"),y=e.runWebGLProgram(d,f,"float32"),x=uo({inputs:{real:m,imag:y},backend:e});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),x}if(e.shouldExecuteOnCPU([s,r])){const o=e.texData.get(s.dataId),u=e.texData.get(r.dataId),[h,d]=pJ(s.shape,r.shape,o.values,u.values,i),f=e.makeTensorInfo(d,i),m=e.texData.get(f.dataId);return m.values=h,f}let a;return tt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new uc(tk,s.shape,r.shape):a=new Sl(tk,s.shape,r.shape),e.runWebGLProgram(a,[s,r],i)}const ytt={kernelName:x1,backendName:"webgl",kernelFunc:Iw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xtt(n,t,e){const s=[vl(n.shape),...wl(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},i=[vl(t),...wl(t)],a=new r3(i,s),o=!0,u=[s],h=e.runWebGLProgram(a,[r],n.dtype,u,o);return{dataId:h.dataId,shape:t,dtype:h.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Et(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{shape:i}=s,a=e,o=ht(r.shape),u=M_(i,o),h=ht(u);M(o===h,()=>`The new shape (${u}) has ${h} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const d=a.texData.get(r.dataId);return d.isPacked&&!ud(r.shape,u)&&!(d.texture!==null&&ud(d.shape,u))?xtt(r,u,a):(a.incRef(r.dataId),{dataId:r.dataId,shape:u,dtype:r.dtype})}const btt={kernelName:O1,backendName:"webgl",kernelFunc:Et};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ek{constructor(t,e){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:a}=t;this.outputShape=[r,a];const o=Math.floor(s/4)*4,u=s%4;let h="sumValue += dot(values, ones);";if(e!=null){const f=1/e;h=`sumValue += dot(values * ${zu(f)?f.toPrecision(2):f}, ones);`}let d="";i%s>0&&(d=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${o};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${h}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${h}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${h}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vtt{constructor(t,e){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:a}=t;this.outputShape=[r,a];let o="0.0",u="";e==="prod"?o="1.0":e==="min"?(o="1.0 / 1e-20",u="min"):e==="max"&&(o="-1.0 / 1e-20",u="max");let h=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?h="sumValue":e==="prod"?h="prodValue":e==="all"?h="allValue":e==="any"&&(h="anyValue");const d=Math.floor(s/4)*4,f=s%4;let m=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${e==="min"} || ${e==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,y="vec4";e==="all"?(o="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,y="bvec4"):e==="any"&&(o="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,y="bvec4");let x="";i%s>0&&(x=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${x}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${d};
        if (${f===1}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${f===2}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${f===3}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${h});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wtt(n){const t=[];for(;t.length===0||t[t.length-1].outSize!==1;){const e=t.length?t[t.length-1].outSize:n[1],s=Im(e);t.push({inSize:e,windowSize:s,outSize:Math.ceil(e/s)})}return t}function Dl(n,t,e,s){const r=wtt(n.shape);let i=n;for(let a=0;a<r.length;a++){const{inSize:o,windowSize:u,outSize:h}=r[a];let d,f;e==="mean"?d=a===0?new ek({windowSize:u,inSize:o,batchSize:n.shape[0],outSize:h},o):new ek({windowSize:u,inSize:o,batchSize:n.shape[0],outSize:h}):d=new vtt({windowSize:u,inSize:o,batchSize:n.shape[0],outSize:h},e),f=i,i=s.runWebGLProgram(d,[i],t),f.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(f)}return i}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Stt{constructor(t,e){this.variableNames=["A"];const s=new Array(t.length);for(let a=0;a<s.length;a++)s[a]=t[e[a]];this.outputShape=s,this.rank=s.length;const r=Fe(this.rank),i=Ctt(e);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}}function Ctt(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(t);for(let r=0;r<n.length;r++)s[n[r]]=e[r];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $tt{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(t.length);for(let d=0;d<s.length;d++)s[d]=t[e[d]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Fe(this.rank),i=s3("rc",this.rank),a=new Array(this.rank);for(let d=0;d<e.length;d++)a[e[d]]=i[d];const o=`vec2(${a.slice(-2).join()})`,u=`++${i[this.rank-1]} < ${s[this.rank-1]}`,h=`getChannel(getA(${a.join()}), ${o})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${h};
      if(${u}) {
        result[1] = ${h};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${h};
        if(${u}) {
          result[3] = ${h};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mm(n,t,e){const s=tt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new $tt(n.shape,t):new Stt(n.shape,t);return e.runWebGLProgram(s,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ttt(n,t,e,s){const r=t,i=n.shape.length,a=Qe(r,n.shape);let o=a;const u=ts(o,i),h=u!=null;let d=n;h&&(d=Mm(n,u,s),o=es(o.length,i)),Qs("sum",o,i);const[f,m]=mr(d.shape,o);let y=f;e&&(y=Ys(f,a));const x=ht(m),S=ht(n.shape)/x,C=Et({inputs:{x:d},attrs:{shape:[S,x]},backend:s}),k=vm(n.dtype),E=Dl(C,k,"sum",s),R=Et({inputs:{x:E},attrs:{shape:y},backend:s});return s.disposeIntermediateTensorInfo(C),s.disposeIntermediateTensorInfo(E),h&&s.disposeIntermediateTensorInfo(d),R}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zm(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:a}=s;return Ttt(r,i,a,e)}const ktt={kernelName:J1,backendName:"webgl",kernelFunc:zm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fs(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{perm:i}=s,a=e,o=r.shape.length,u=new Array(o);for(let d=0;d<u.length;d++)u[d]=r.shape[i[d]];let h;if(a.shouldExecuteOnCPU([r])){const f=a.texData.get(r.dataId).values,m=Ew(f,r.shape,r.dtype,i,u);h=a.makeTensorInfo(u,r.dtype);const y=a.texData.get(h.dataId);y.values=m}else h=Mm(r,i,a);return h}const _tt={kernelName:zh,backendName:"webgl",kernelFunc:fs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c3=1e3;function sm({a:n,b:t,transposeA:e,transposeB:s,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:u=null}){const h=n.shape.length,d=t.shape.length,f=e?n.shape[h-2]:n.shape[h-1],m=s?t.shape[d-1]:t.shape[d-2],y=e?n.shape[h-1]:n.shape[h-2],x=s?t.shape[d-2]:t.shape[d-1],w=n.shape.slice(0,-2),S=t.shape.slice(0,-2),C=ht(w),k=ht(S),R=ne(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([y,x]);M(f===m,()=>`Error in matMul: inner shapes (${f}) and (${m}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${s} must match.`);const A=e?[C,f,y]:[C,y,f],L=s?[k,x,m]:[k,m,x],V=Et({inputs:{x:n},backend:r,attrs:{shape:A}}),B=Et({inputs:{x:t},backend:r,attrs:{shape:L}}),z=[V,B],U=Math.max(C,k),D=e?V.shape[1]:V.shape[2],Y=i!=null,nt=a!=null,dt=u==="leakyrelu",at=u!=null?cd(u,!0):null,K=Y||nt||dt||at!=null;let ct;if((y===1||x===1)&&D>c3&&K===!1){let $t=V,H=B;e&&($t=fs({inputs:{x:V},backend:r,attrs:{perm:[0,2,1]}}),z.push($t)),s&&(H=fs({inputs:{x:B},backend:r,attrs:{perm:[0,2,1]}}),z.push(H));const ut=x!==1,xt=x===1;let bt=$t;ut&&(bt=Et({inputs:{x:$t},backend:r,attrs:{shape:[U,D,1]}}),z.push(bt));const _t=x===1?2:1;let Kt=H;xt&&(Kt=Et({inputs:{x:H},backend:r,attrs:{shape:[U,1,D]}}),z.push(Kt));const Mt=Iw({inputs:{a:bt,b:Kt},backend:r});ct=zm({inputs:{x:Mt},backend:r,attrs:{axis:_t,keepDims:!0}}),z.push(Mt)}else{const $t=Ns(n.dtype,t.dtype),H=new u3(A,L,[U,y,x],e,s,Y,at,nt,dt),ut=[V,B];if(i!=null&&ut.push(i),nt&&ut.push(a),dt){const xt=r.makeTensorInfo([],"float32",Zu(o,"float32"));ut.push(xt),z.push(xt)}ct=r.runWebGLProgram(H,ut,$t)}const yt=Et({inputs:{x:ct},backend:r,attrs:{shape:R}});z.push(ct);for(const $t of z)r.disposeIntermediateTensorInfo($t);return yt}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ntt(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:i,bias:a,preluActivationWeights:o}=t,{transposeA:u,transposeB:h,activation:d,leakyreluAlpha:f}=s;return sm({a:r,b:i,transposeA:u,transposeB:h,backend:e,bias:a,preluActivationWeights:o,leakyreluAlpha:f,activation:d})}const Ett={kernelName:Bp,backendName:"webgl",kernelFunc:Ntt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nk="return abs(x);";function Rtt(n){const{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const i=e.texData.get(s.dataId),a=e3(i.values);return e.makeTensorInfo(s.shape,s.dtype,a)}let r;return tt().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Ha(s.shape,nk):r=new yi(s.shape,nk),e.runWebGLProgram(r,[s],s.dtype)}const Itt={kernelName:V0,backendName:"webgl",kernelFunc:Rtt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Att=Br+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Dtt=me({opSnippet:Att}),Ott={kernelName:U0,backendName:"webgl",kernelFunc:Dtt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ptt=Br+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Ftt=me({opSnippet:Ptt}),Ltt={kernelName:W0,backendName:"webgl",kernelFunc:Ftt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sk="return a + b;",Mtt=Vn({opSnippet:sk,packedOpSnippet:sk,supportsComplex:!0,cpuKernelImpl:XZ}),ztt={kernelName:pm,backendName:"webgl",kernelFunc:Mtt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Btt{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((i,a)=>`T${a}`);const s=[];this.variableNames.forEach(i=>{s.push(`float v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vtt{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((i,a)=>`T${a}`);const s=[];this.variableNames.forEach(i=>{s.push(`vec4 v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Op(n){const{inputs:t,backend:e}=n,s=t;if(s.length===1)return qs({inputs:{x:s[0]},backend:e});if(s.length>tt().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(s.length/2),h=Op({inputs:s.slice(0,u),backend:e}),d=Op({inputs:s.slice(u),backend:e});return Op({inputs:[h,d],backend:e})}const r=s.map(u=>u.dtype).reduce((u,h)=>Ns(u,h)),i=s.map(u=>u.shape),o=tt().getBool("WEBGL_PACK")?new Vtt(s[0].shape,i):new Btt(s[0].shape,i);return e.runWebGLProgram(o,s,r)}const Utt={kernelName:G0,backendName:"webgl",kernelFunc:Op};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wtt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:a}=s,o=r.shape.length,u=Qe(i,r.shape);let h=u;const d=ts(h,o);let f=r;d!=null&&(f=fs({inputs:{x:r},backend:e,attrs:{perm:d}}),h=es(h.length,o)),Qs("all",h,o);const[m,y]=mr(f.shape,h),x=ht(y),w=Et({inputs:{x:f},backend:e,attrs:{shape:[-1,x]}}),S=Dl(w,w.dtype,"all",e);let C;if(a){const k=Ys(m,u);C=Et({inputs:{x:S},backend:e,attrs:{shape:k}})}else C=Et({inputs:{x:S},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(S),d!=null&&e.disposeIntermediateTensorInfo(f),C}const Gtt={kernelName:H0,backendName:"webgl",kernelFunc:Wtt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Htt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:a}=s,o=r.shape.length,u=Qe(i,r.shape);let h=u;const d=ts(h,o);let f=r;d!=null&&(f=fs({inputs:{x:r},backend:e,attrs:{perm:d}}),h=es(h.length,o)),Qs("any",h,o);const[m,y]=mr(f.shape,h),x=ht(y),w=Et({inputs:{x:f},backend:e,attrs:{shape:[-1,x]}}),S=Dl(w,w.dtype,"any",e);let C;if(a){const k=Ys(m,u);C=Et({inputs:{x:S},backend:e,attrs:{shape:k}})}else C=Et({inputs:{x:S},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(S),d!=null&&e.disposeIntermediateTensorInfo(f),C}const jtt={kernelName:j0,backendName:"webgl",kernelFunc:Htt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xtt{constructor(t,e,s){this.variableNames=["A"];const{windowSize:r,batchSize:i,outSize:a}=t;s||this.variableNames.push("bestIndicesA"),this.outputShape=[i,a];const o=e==="max"?">":"<",u=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${o} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qtt{constructor(t,e,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,M(t.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const i=t[t.length-1],a=Math.ceil(i/e);this.outputShape=t.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const o=this.outputShape,u=o.length,h=Fe(u),d=hs("coords",u);let f,m;if(a===1){m=u+1;const B=Fe(m);f=`
        ${B} sourceLocR = ${B}(${d.join()}, 0);
        ++${d[u-1]};
        ${B} sourceLocG = ${B}(${d.join()}, 0);
        ++${d[u-2]};
        ${B} sourceLocA = ${B}(${d.join()}, 0);
        --${d[u-1]};
        ${B} sourceLocB = ${B}(${d.join()}, 0);
        --${d[u-2]};`}else m=u,f=`
        ${h} sourceLocR = coords;
        ++${d[u-1]};
        ${h} sourceLocG = coords;
        ++${d[u-2]};
        ${h} sourceLocA = coords;
        --${d[u-1]};
        ${h} sourceLocB = coords;
        --${d[u-2]};`;const y=["x","y","z","w","u","v"].slice(0,m),x="."+y[m-1],w=y.map(B=>"int "+B),S=hs("sourceLocR",m-1).concat("inIdx.r"),C=hs("sourceLocG",m-1).concat("inIdx.g"),k=hs("sourceLocB",m-1).concat("inIdx.b"),E=hs("sourceLocA",m-1).concat("inIdx.a"),R=s==="max"?"greaterThan":"lessThan",A=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${S.join()}),
                             getBestIndicesAChannel(${C.join()}),
                             getBestIndicesAChannel(${k.join()}),
                             getBestIndicesAChannel(${E.join()})));`,L=`vec4(
            getAChannel(${S.join()}),
            hasNextCol ? getAChannel(${C.join()}) : 0.,
            hasNextRow ? getAChannel(${k.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${E.join()}) : 0.)`,V=r?"":`
      float getBestIndicesAChannel(${w.join()}) {
        return getChannel(getBestIndicesA(${y.join()}),
                                          vec2(${y.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${w.join()}) {
        return getChannel(getA(${y.join()}),
                               vec2(${y.slice(-2).join()}));
      }
      ${V}
      void main() {
        ${h} coords = getOutputCoords();
        bool hasNextCol = ${d[u-1]} < ${o[u-1]-1};
        bool hasNextRow = ${d[u-2]} < ${o[u-2]-1};
        ${f}
        ivec4 srcIdx = ivec4(sourceLocR${x}, sourceLocG${x},
          sourceLocB${x}, sourceLocA${x}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${L};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${A}
          vec4 candidate = ${L};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${R}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h3(n,t,e,s=null){let r=t.shape[0],i=t.shape[1];s!=null&&(r=s.shape[0],i=s.shape[1]);const a=Im(i),o={windowSize:a,inSize:i,batchSize:r,outSize:Math.ceil(i/a)},u=new Xtt(o,e,s==null),h=[t];s!=null&&h.push(s);const d=n.runWebGLProgram(u,h,"int32");if(d.shape[1]===1)return d;const f=h3(n,t,e,d);return n.disposeIntermediateTensorInfo(d),f}function d3(n,t,e,s=null){const r=s!=null?s.shape:t.shape,i=r[r.length-1],a=Im(i),o=new qtt(r,a,e,s==null),u=s==null?[t]:[t,s],h=n.runWebGLProgram(o,u,"int32");if(h.shape.length===t.shape.length){const d=d3(n,t,e,h);return n.disposeIntermediateTensorInfo(h),d}return h}function f3(n,t,e,s){const r=[e];if(Qs("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,t.shape.length),!tt().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const i=[],a=n.texData.get(t.dataId),o=a!==null&&a.isPacked;let u=t;o&&(u=n.unpackTensor(t),i.push(u));const[h,d]=mr(u.shape,r),f=ht(d),m=Et({inputs:{x:u},backend:n,attrs:{shape:[-1,f]}});i.push(m);const y=h3(n,m,s);i.push(y);const x=Et({inputs:{x:y},backend:n,attrs:{shape:h}});return i.forEach(w=>n.disposeIntermediateTensorInfo(w)),x}return d3(n,t,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ktt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i}=s;let a=Qe(i,r.shape);const o=ts(a,r.shape.length);let u=r;const h=[];o!=null&&(u=fs({inputs:{x:r},backend:e,attrs:{perm:o}}),h.push(u),a=es(a.length,u.shape.length)),Qs("argMax",[a[0]],u.shape.length);const d=f3(e,u,a[0],"max");return h.forEach(f=>e.disposeIntermediateTensorInfo(f)),d}const Ytt={kernelName:X0,backendName:"webgl",kernelFunc:Ktt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qtt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i}=s;let a=Qe(i,r.shape);const o=ts(a,r.shape.length);let u=r;const h=[];o!=null&&(u=fs({inputs:{x:r},backend:e,attrs:{perm:o}}),h.push(u),a=es(a.length,u.shape.length)),Qs("argMin",[a[0]],u.shape.length);const d=f3(e,u,a[0],"min");return h.forEach(f=>e.disposeIntermediateTensorInfo(f)),d}const Ztt={kernelName:q0,backendName:"webgl",kernelFunc:Qtt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jtt=Br+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,tet=me({opSnippet:Jtt}),eet={kernelName:K0,backendName:"webgl",kernelFunc:tet};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const net=Br+"return log(x + sqrt(x * x + 1.0));",set=me({opSnippet:net}),ret={kernelName:Y0,backendName:"webgl",kernelFunc:set};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iet=Br+`
  return atan(x);
`,aet=me({opSnippet:iet}),oet={kernelName:Q0,backendName:"webgl",kernelFunc:aet};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uet=Rw+`
  return atan(a, b);
`,cet=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Al+`
  return result;
`,het=Vn({opSnippet:uet,packedOpSnippet:cet}),det={kernelName:J0,backendName:"webgl",kernelFunc:het};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fet=Br+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,pet=me({opSnippet:fet}),met={kernelName:Z0,backendName:"webgl",kernelFunc:pet};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hd{constructor(t,e,s,r=!1,i=!1){if(this.variableNames=["x"],e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=t.filterWidth,o=t.strideHeight,u=t.strideWidth,h=t.dilationHeight,d=t.dilationWidth,f=t.effectiveFilterHeight,m=t.effectiveFilterWidth,y=t.padInfo.top,x=t.padInfo.left;this.outputShape=t.outShape;const w=e==="avg",S=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,C=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let k="0.0";if(w||(k="-1.0 / 1e-20"),s){this.userCode=`
        const ivec2 strides = ivec2(${o}, ${u});
        const ivec2 pads = ivec2(${y}, ${x});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${f};
              wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${d}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?i?S:C:`wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const E="max";let R=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(R="avgValue / max(count, 1.0)");const A=Math.floor(a/4)*4,L=a%4,V=`
      if (${w}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${E}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${u});
      const ivec2 pads = ivec2(${y}, ${x});
      const float initializationValue = ${k};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${k});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${f};
            wR += ${h}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${A}; wC += 4) {
            int xC = xCCorner + wC * ${d};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              getValue(batch, xR, xC + 3 * ${d}, d)
            );

            ${V}
          }

          int xC = xCCorner + ${A};
          if (${L===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${V}
          } else if (${L===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              initializationValue,
              initializationValue
            );

            ${V}
          } else if (${L===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              initializationValue
            );

            ${V}
          }
        }
        setOutput(${R});
      }
    `}}class Aw{constructor(t,e,s,r=!1,i=!1){if(this.variableNames=["x"],e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=t.filterWidth,o=t.strideDepth,u=t.strideHeight,h=t.strideWidth,d=t.dilationDepth,f=t.dilationHeight,m=t.dilationWidth,y=t.effectiveFilterDepth,x=t.effectiveFilterHeight,w=t.effectiveFilterWidth,S=t.padInfo.front,C=t.padInfo.top,k=t.padInfo.left;this.outputShape=t.outShape;const E=e==="avg";let R="0.0";if(E||(R="-1.0 / 1e-20"),s){this.userCode=`
        const ivec3 strides =
            ivec3(${o}, ${u}, ${h});
        const ivec3 pads = ivec3(${S}, ${C}, ${k});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${y};
              wD += ${d}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${x};
                wR += ${f}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${w};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?i?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${x} * ${w} +
                      wR * ${w} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const A="max";let L=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(L="avgValue / max(count, 1.0)");const V=Math.floor(a/4)*4,B=a%4,z=`
      if (${E}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${A}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${o}, ${u}, ${h});
      const ivec3 pads = ivec3(${S}, ${C}, ${k});
      const float initializationValue = ${R};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${R});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${y};
            wD += ${d}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${x};
            wR += ${f}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${V}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${z}
            }

            int xC = xCCorner + ${V};
            if (${B===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${z}
            } else if (${B===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${z}
            } else if (${B===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${z}
            }
          }
        }
        setOutput(${L});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function get(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;rc(r,"avgPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:u}=s,h=1;M(ps(a,h),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${h}'`);const d=Mr(r.shape,i,a,h,o,u);if(d.filterWidth===1&&d.filterHeight===1&&Ee(d.inShape,d.outShape))return qs({inputs:{x:r},backend:e});const f=new hd(d,"avg",!1);return e.runWebGLProgram(f,[r],"float32")}const yet={kernelName:tb,backendName:"webgl",kernelFunc:get};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xet(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:i,strides:a,pad:o,dimRoundingMode:u,dataFormat:h}=s,d=[1,1,1],f=la(r.shape,i,a,d,o,u,h),m=new Aw(f,"avg",!1);return e.runWebGLProgram(m,[r],"float32")}const bet={kernelName:eb,backendName:"webgl",kernelFunc:xet};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vet{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,r=t.strideHeight,i=t.strideWidth,a=t.dilationHeight,o=t.dilationWidth,u=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=u-1-t.padInfo.top,f=h-1-t.padInfo.left,m=1/(e*s);this.userCode=`
      const ivec2 pads = ivec2(${d}, ${f});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${h};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class wet{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterDepth,s=t.filterHeight,r=t.filterWidth,i=t.strideDepth,a=t.strideHeight,o=t.strideWidth,u=t.dilationDepth,h=t.dilationHeight,d=t.dilationWidth,f=t.effectiveFilterDepth,m=t.effectiveFilterHeight,y=t.effectiveFilterWidth,x=f-1-t.padInfo.front,w=m-1-t.padInfo.top,S=y-1-t.padInfo.left,C=1/(e*s*r);this.userCode=`
      const ivec3 pads = ivec3(${x}, ${w}, ${S});
      const float avgMultiplier = float(${C});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${h}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${y};
                wC += ${d}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cet(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,a=i,{filterSize:o,strides:u,pad:h,dimRoundingMode:d}=s,f=[1,1,1],m=la(a.shape,o,u,f,h,d),y=new wet(m);return e.runWebGLProgram(y,[r],a.dtype)}const $et={kernelName:H_,backendName:"webgl",kernelFunc:Cet};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tet(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,a=i;rc([r,i],"avgPoolGrad");const{filterSize:o,strides:u,pad:h}=s,d=Mr(a.shape,o,u,1,h),f=new vet(d);return e.runWebGLProgram(f,[r],a.dtype)}const ket={kernelName:G_,backendName:"webgl",kernelFunc:Tet};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _et(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:i}=t,{transposeA:a,transposeB:o}=s;return sm({a:r,b:i,transposeA:a,transposeB:o,backend:e})}const Net={kernelName:nb,backendName:"webgl",kernelFunc:_et};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Eet{constructor(t,e,s,r,i,a){this.outputShape=[],this.variableNames=["x","mean","variance"],ne(t,e),ne(t,s);let o="0.0";r!=null&&(ne(t,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let u="1.0";i!=null&&(ne(t,i),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ret{constructor(t,e,s,r,i,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],ne(t,e),ne(t,s);let o="vec4(0.0)";r!=null&&(ne(t,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let u="vec4(1.0)";i!=null&&(ne(t,i),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iet=({inputs:n,backend:t,attrs:e})=>{const{x:s,mean:r,variance:i,offset:a,scale:o}=n;M(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),M(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),M(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=e;u==null&&(u=.001);const h=[s,r,i];let d=null;a!=null&&(d=a.shape,h.push(a));let f=null;o!=null&&(f=o.shape,h.push(o));const m=tt().getBool("WEBGL_PACK_NORMALIZATION")?new Ret(s.shape,r.shape,i.shape,d,f,u):new Eet(s.shape,r.shape,i.shape,d,f,u);return t.runWebGLProgram(m,h,h[0].dtype)},Aet={kernelName:Vb,backendName:"webgl",kernelFunc:Iet};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Det{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=Fe(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=Oet(this.rank);let r;const i=t.map((a,o)=>`sourceLoc.${T0[o]} = start[${o}] + coords.${T0[o]};`);r=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const T0=["x","y","z","w","u","v"];function Oet(n){if(n===1)return"sourceLoc";if(n<=6)return T0.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pet{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=Fe(this.rank),s=hs("coords",this.rank),r=hs("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${i})`,o=`
      result.x = ${a};
      if (++${s[this.rank-1]} < ${t[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${a};
        --${r[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${t[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${a};
        if (++${s[this.rank-1]} < ${t[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${a};
        }
      }
    `,h=this.rank<=4?`sourceLoc = coords +
            ${e}(${t.map((d,f)=>`start[${f}]`).join()});`:t.map((d,f)=>`${r[f]} = ${s[f]} + start[${f}];`).join(`
`);this.userCode=`
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${h}
        vec4 result = vec4(0.);
        ${o}
        ${u}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fet(n,t,e,s){const r=s.texData.get(n.dataId),i=s.makeTensorInfo(e,n.dtype),a=s.texData.get(i.dataId);Object.assign(a,r),a.refCount=1,a.shape=e,a.dtype=n.dtype;let o=Wv(t,cn(n.shape));r.slice&&(o+=r.slice.flatOffset),a.slice={flatOffset:o,origDataId:r.slice&&r.slice.origDataId||n.dataId};const u=s.dataRefCount.get(a.slice.origDataId)||1;return s.dataRefCount.set(a.slice.origDataId,u+1),i}function hc(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:i,size:a}=s,[o,u]=Gv(r,i,a);if(Bv(r,o,u),ht(u)===0)return e.makeTensorInfo(u,r.dtype,[]);if(e.shouldExecuteOnCPU([r])||r.dtype==="string"){const f=e.texData.get(r.dataId),m=TJ(f.values,o,u,r.shape,r.dtype);return e.makeTensorInfo(u,r.dtype,m)}const{isPacked:h}=e.texData.get(r.dataId),d=Uv(r.shape,o,u);if(h||!d){const f=tt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Pet(u):new Det(u),m=[o];return e.runWebGLProgram(f,[r],r.dtype,m)}return e.uploadToGPU(r.dataId),Fet(r,o,u,e)}const Let={kernelName:j1,backendName:"webgl",kernelFunc:hc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Met=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:i,crops:a}=s;M(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=i.reduce((k,E)=>k*E),u=Cd(r.shape,i,o),h=$d(u.length,i.length),d=Td(r.shape,i,o),f=Kv(a,i.length),m=Yv(d,a,i.length),y=[],x=Et({inputs:{x:r},backend:e,attrs:{shape:u}}),w=fs({inputs:{x},backend:e,attrs:{perm:h}}),S=Et({inputs:{x:w},backend:e,attrs:{shape:d}}),C=hc({inputs:{x:S},backend:e,attrs:{begin:f,size:m}});return y.push(x),y.push(w),y.push(S),y.forEach(k=>e.disposeIntermediateTensorInfo(k)),C},zet={kernelName:sb,backendName:"webgl",kernelFunc:Met};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bet(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:i}=t,{size:a}=s,o=e.readSync(r.dataId),u=e.readSync(i.dataId),h=t3(o,u,i.dtype,i.shape,a);return e.makeTensorInfo([a],i.dtype,h)}const Vet={kernelName:rb,backendName:"webgl",kernelFunc:Bet};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uet=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,Wet=`
  return float(int(a.r) & int(b.r));
`;function Get(n){const{inputs:t,backend:e}=n,{a:s,b:r}=t,i=tt().getBool("WEBGL_PACK_BINARY_OPERATIONS"),a=tt().getNumber("WEBGL_VERSION");if(e.shouldExecuteOnCPU([s,r])||a===1){const u=e.texData.get(s.dataId).values,h=e.texData.get(r.dataId).values,[d,f]=KZ(s.shape,r.shape,u,h,s.dtype),m=e.makeTensorInfo(f,s.dtype),y=e.texData.get(m.dataId);return y.values=d,m}let o;return i?o=new uc(Uet,s.shape,r.shape,!1):o=new Sl(Wet,s.shape,r.shape),e.runWebGLProgram(o,[s,r],s.dtype)}const Het={kernelName:j_,backendName:"webgl",kernelFunc:Get};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jet(n){const{inputs:t,backend:e}=n,{s0:s,s1:r}=t,i=e.readSync(s.dataId),a=e.readSync(r.dataId),o=ne(Array.from(i),Array.from(a));return e.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const Xet={kernelName:ib,backendName:"webgl",kernelFunc:jet};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qet="return float(a != b);",p3=Vn({opSnippet:qet,cpuKernelImpl:gJ,dtype:"bool"}),Ket={kernelName:v1,backendName:"webgl",kernelFunc:p3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ed(n){const{inputs:t,backend:e}=n,{input:s}=t,r=e.texData.get(s.dataId);return qs({inputs:{x:r.complexTensorInfos.real},backend:e})}const Yet={kernelName:I1,backendName:"webgl",kernelFunc:Ed};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qet="return float(int(x));";function Zet(n,t){const e=new yi(n.shape,Qet),s=t.runWebGLProgram(e,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k0(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return qs({inputs:{x:r},backend:e});const a=aa(r.shape),o=k0({inputs:{x:r},backend:e,attrs:{dtype:"float32"}}),u=uo({inputs:{real:o,imag:a},backend:e});return a.dispose(),e.disposeIntermediateTensorInfo(o),u}if(r.dtype==="complex64"){const a=Ed({inputs:{input:r},backend:e}),o=k0({inputs:{x:a},backend:e,attrs:{dtype:i}});return e.disposeIntermediateTensorInfo(a),o}if(!z_(r.dtype,i)){const a=qs({inputs:{x:r},backend:e});return{dataId:a.dataId,shape:a.shape,dtype:i}}if(e.shouldExecuteOnCPU([r])){const a=e.texData.get(r.dataId).values,[o,u,h]=YZ(a,r.shape,r.dtype,i);return e.makeTensorInfo(o,u,h)}if(i==="int32")return Zet(r,e);if(i==="bool"){const a=e.makeTensorInfo([],"bool",Si("bool",1)),u=p3({inputs:{a:r,b:a},backend:e});return e.disposeIntermediateTensorInfo(a),u}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const Jet={kernelName:mm,backendName:"webgl",kernelFunc:k0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rk="return ceil(x);",tnt=me({opSnippet:rk,packedOpSnippet:rk,cpuKernelImpl:QZ}),ent={kernelName:ab,backendName:"webgl",kernelFunc:tnt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nnt{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class snt{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rnt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{clipValueMin:i,clipValueMax:a}=s;let o;tt().getBool("WEBGL_PACK_CLIP")?o=new snt(r.shape):o=new nnt(r.shape);const u=[[i],[a]];return e.runWebGLProgram(o,[r],r.dtype,u)}const int={kernelName:ob,backendName:"webgl",kernelFunc:rnt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ant{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ik(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}function ont(n){const{inputs:t,backend:e}=n,{x:s}=t,r=e.texData.get(s.dataId),i=new ant(s.shape),a=[ik(s,r.complexTensorInfos.real),ik(s,r.complexTensorInfos.imag)];return e.runWebGLProgram(i,a,a[0].dtype)}const lnt={kernelName:ub,backendName:"webgl",kernelFunc:ont};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class unt{constructor(t){this.outputShape=[],this.outputShape=Fr(t,1),this.variableNames=t.map((a,o)=>`T${o}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let a=1;a<e.length;a++)e[a]=e[a-1]+t[a][1];const s=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<e.length;a++){const o=e[a-1];s.push(`else if (yC < ${e[a]}) setOutput(getT${a}(yR, yC-${o}));`)}const r=e.length,i=e[e.length-1];s.push(`else setOutput(getT${r}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cnt{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Fr(t,e);const s=this.outputShape,r=s.length,i=Fe(r),a=hs("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map((w,S)=>`T${S}`);const u=new Array(t.length-1);u[0]=t[0][e];for(let w=1;w<u.length;w++)u[w]=u[w-1]+t[w][e];const h=o[e],d=o.slice(-2),f=o.join();let m=`if (${h} < ${u[0]}) {
        return getChannel(
            getT0(${f}), vec2(${d.join()}));
        }`;for(let w=1;w<u.length;w++){const S=u[w-1];m+=`
        if (${h} < ${u[w]}  && ${h} >= ${u[w-1]}) {
          return getChannel(
            getT${w}(${sp(o,h,S)}),
            vec2(${sp(d,h,S)}));
        }`}const y=u.length,x=u[u.length-1];m+=`
        return getChannel(
          getT${y}(${sp(o,h,x)}),
          vec2(${sp(d,h,x)}));`,this.userCode=`
      float getValue(${o.map(w=>"int "+w)}) {
        ${m}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[r-1]} = ${a[r-1]} + 1;
        if (${a[r-1]} < ${s[r-1]}) {
          result.g = getValue(${a});
        }

        ${a[r-2]} = ${a[r-2]} + 1;
        if (${a[r-2]} < ${s[r-2]}) {
          result.a = getValue(${a});
        }

        ${a[r-1]} = ${a[r-1]} - 1;
        if (${a[r-2]} < ${s[r-2]} &&
            ${a[r-1]} < ${s[r-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}}function sp(n,t,e){const s=n.indexOf(t);return n.map((i,a)=>a===s?`${i} - ${e}`:i).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bm(n){const{inputs:t,backend:e}=n,{input:s}=t,r=e.texData.get(s.dataId);return qs({inputs:{x:r.complexTensorInfos.imag},backend:e})}const hnt={kernelName:Xb,backendName:"webgl",kernelFunc:Bm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oh(n,t,e){const s=n[0].dtype;if(s==="complex64"){const y=n.map(k=>Ed({inputs:{input:k},backend:e})),x=n.map(k=>Bm({inputs:{input:k},backend:e})),w=Oh(y,t,e),S=Oh(x,t,e),C=uo({inputs:{real:w,imag:S},backend:e});return y.forEach(k=>e.disposeIntermediateTensorInfo(k)),x.forEach(k=>e.disposeIntermediateTensorInfo(k)),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(S),C}let r=e.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const y=n.map(R=>{const L=[-1,ht(R.shape.slice(t))];return Et({inputs:{x:R},backend:e,attrs:{shape:L}})}),x=y.map(R=>({vals:e.readSync(R.dataId),shape:R.shape})),w=Fr(y.map(R=>R.shape),1),S=y[0].shape[0]===1,C=ZZ(x,w,s,S),k=Fr(n.map(R=>R.shape),t),E=e.makeTensorInfo(k,s,C);return y.forEach(R=>e.disposeIntermediateTensorInfo(R)),E}const i=n.filter(y=>ht(y.shape)>0),a=tt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const y=a?new yi(n[0].shape,Ua):new Ha(n[0].shape,Ua);return e.runWebGLProgram(y,n,s)}const o=tt().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>o){const y=[];for(let w=0;w<i.length;w+=o){const S=i.slice(w,w+o);y.push(Oh(S,t,e))}const x=Oh(y,t,e);for(const w of y)e.disposeIntermediateTensorInfo(w);return x}if(a){const y=new cnt(i.map(x=>x.shape),t);return e.runWebGLProgram(y,i,s)}const{tensors2D:u,outShape:h}=dnt(i,t,e),d=new unt(u.map(y=>y.shape)),f=e.runWebGLProgram(d,u,s);u.forEach(y=>e.disposeIntermediateTensorInfo(y));const m=Et({inputs:{x:f},attrs:{shape:h},backend:e});return e.disposeIntermediateTensorInfo(f),m}function dnt(n,t,e){const s=Fr(n.map(i=>i.shape),t);return{tensors2D:n.map(i=>Et({inputs:{x:i},attrs:{shape:[-1,ht(i.shape.slice(t))]},backend:e})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m3(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s,i=Qe(r,t[0].shape)[0],a=t.map(h=>h.shape);jv(a,i);const o=Fr(t.map(h=>h.shape),i);if(ht(o)===0)return e.makeTensorInfo(o,t[0].dtype,[]);const u=t.filter(h=>ht(h.shape)>0);return u.length===1?qs({inputs:{x:u[0]},backend:e}):Oh(u,i,e)}const fnt={kernelName:cb,backendName:"webgl",kernelFunc:m3};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class g3{constructor(t,e=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const a=t.padInfo.top,o=t.padInfo.left,u=t.strideHeight,h=t.strideWidth,d=t.dilationHeight,f=t.dilationWidth,m=t.filterHeight,y=t.filterWidth,x=Math.floor(t.inChannels/4)*4,w=t.inChannels%4,S=t.dataFormat==="channelsLast",C=S?1:2,k=S?2:3,E=S?3:1;let R="",A="";s&&(r?R=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?R=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:R=`
          float activation(float x) {
            ${s}
          }
        `,A="result = activation(result);");const L=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${R}

      const ivec2 strides = ivec2(${u}, ${h});
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${E}];

        ivec2 xRCCorner =
            ivec2(coords[${C}], coords[${k}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${d};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${y}; wC++) {
            int xC = xCCorner + wC * ${f};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${x}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${S}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${w===1}) {

              if (${S}) {
                dotProd +=
                    getX(batch, xR, xC, ${x}) *
                    getW(wR, wC, ${x}, d2);
              } else {
                dotProd +=
                    getX(batch, ${x}, xR, xC) *
                    getW(wR, wC, ${x}, d2);
              }

            } else if (${w===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${x}, d2),
                getW(wR, wC, ${x} + 1, d2)
              );

              if (${S}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${x}),
                  getX(batch, xR, xC, ${x} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${x}, xR, xC),
                  getX(batch, ${x} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${w===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${x}, d2),
                getW(wR, wC, ${x} + 1, d2),
                getW(wR, wC, ${x} + 2, d2)
              );

              if (${S}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${x}),
                  getX(batch, xR, xC, ${x} + 1),
                  getX(batch, xR, xC, ${x} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${x}, xR, xC),
                  getX(batch, ${x} + 1, xR, xC),
                  getX(batch, ${x} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${L}
        ${A}
        setOutput(result);
      }
    `}}class pnt{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,s=t.padInfo.top,r=t.padInfo.left,i=t.strideDepth,a=t.strideHeight,o=t.strideWidth,u=t.dilationDepth,h=t.dilationHeight,d=t.dilationWidth,f=t.filterDepth,m=t.filterHeight,y=t.filterWidth,x=Math.floor(t.inChannels/4)*4,w=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${a}, ${o});
      const ivec3 pads = ivec3(${e}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${f}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${h};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${y}; wC++) {
              int xC = xCCorner + wC * ${d};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${x}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${w===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${x}) *
                  getW(wF, wR, wC, ${x}, d2);
              } else if (${w===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${x}),
                  getX(batch, xF, xR, xC, ${x} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${x}, d2),
                  getW(wF, wR, wC, ${x} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${w===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${x}),
                  getX(batch, xF, xR, xC, ${x} + 1),
                  getX(batch, xF, xR, xC, ${x} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${x}, d2),
                  getW(wF, wR, wC, ${x} + 1, d2),
                  getW(wF, wR, wC, ${x} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class y3{constructor(t,e=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ns(this.outputShape.length);const a=t.padInfo.left,o=t.strideWidth,u=t.dilationWidth,h=t.filterHeight,d=t.filterWidth,f=d;let m=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let S=0;S<d;S++)m+=`
           vec4 xTexelC${S*2};
           int xTexelC${S*2}Ready;
           vec4 xTexelC${S*2+1};
           int xTexelC${S*2+1}Ready;
           vec4 xC${S};`;m+=`
     for (int r = 0; r < ${h}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let S=0;S<d;S++)m+=`
           xTexelC${S*2} = vec4(0.0);
           xTexelC${S*2}Ready = 0;
           xTexelC${S*2+1} = vec4(0.0);
           xTexelC${S*2+1}Ready = 0;
           xC${S} = vec4(0.0);`;m+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let S=0;S<(f+1)/2;S++){const C=S*2;if(m+=`
           xC = xCCorner + ${C*u};
           `,o===1){if(C<d&&(a%2===1?(m+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C}Ready == 0) {
                   xTexelC${C} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${C}.zw = vec2(0.0);
                   }
                   xTexelC${C}Ready = 1;
                 }
               `,u===1&&C>0?m+=`
                 xC${C} = vec4(xTexelC${C-2}.zw, xTexelC${C}.xy);
                 `:m+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${C} = vec4(previous.zw, xTexelC${C}.xy);
                   } else {
                     xC${C} = vec4(0.0, 0.0, xTexelC${C}.xy);
                   }
                   `):m+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${C}Ready == 0) {
                   xTexelC${C} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${C}.zw = vec2(0.0);
                   }
                   xTexelC${C}Ready = 1;
                 }

                 xC${C} = xTexelC${C};
                 `,C+1<d)){const k=a%2===0?M0(u):u;u%2===0&&a%2===1||u%2!==0&&a%2!==1?(m+=`
                   xCOffset = xC + imod(pads[1], 2) + ${k};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C+1}Ready == 0) {
                     xTexelC${C+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${C+1}.zw = vec2(0.0);
                     }
                     xTexelC${C+1}Ready = 1;
                   }
                   `,u>1?m+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${C+1} = vec4(previous.zw, xTexelC${C+1}.xy);
                     } else {
                      xC${C+1} = vec4(0.0, 0.0, xTexelC${C+1}.xy);
                     }
                     `:m+=`
                     xC${C+1} = vec4(xTexelC${C}.zw, xTexelC${C+1}.xy);
                     `):k===1?m+=`
                     xC${C+1} = xTexelC${C};
                     `:m+=`
                     xCOffset = xC + ${k};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C+1}Ready == 0) {
                       xTexelC${C+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${C+1}.zw = vec2(0.0);
                       }
                       xTexelC${C+1}Ready = 1;
                     }

                     xC${C+1} = xTexelC${C+1};
                     `}}else C<d&&(a%2===1?(m+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C}Ready == 0) {
                   xTexelC${C} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${C}.zw = vec2(0.0);
                   }
                   xTexelC${C}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${C+1}Ready == 0) {
                   xTexelC${C+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${C+1}.zw = vec2(0.0);
                   }
                   xTexelC${C+1}Ready = 1;
                 }

                 xC${C} = vec4(xTexelC${C}.zw, xTexelC${C+1}.zw);
               `,C+1<d&&(m+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${C+1} = vec4(xTexelC${C+1}.xy, final.xy);
                 `)):(m+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${C}Ready == 0) {
                   xTexelC${C} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${C}.zw = vec2(0.0);
                   }
                   xTexelC${C}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C+1}Ready == 0) {
                   xTexelC${C+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${C+1}.zw = vec2(0.);
                   }
                   xTexelC${C+1}Ready = 1;
                 }

                 xC${C} = vec4(
                   xTexelC${C}.xy, xTexelC${C+1}.xy);
               `,C+1<d&&(m+=`
                   xC${C+1} = vec4(xTexelC${C}.zw, xTexelC${C+1}.zw);
                 `)));C<d&&(m+=`
             wTexel = getW(r, ${C}, d1, d2);
             dotProd += xC${C}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${C}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,C+1<d&&(m+=`
               wTexel = getW(r, ${C+1}, d1, d2);
               dotProd += xC${C+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${C+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}m+=`
     }
   `,m+=`
     }
   `,m+=`
     }
   `;let y="",x="";s&&(r?y=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:i?y=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:y=`vec4 activation(vec4 x) {
           ${s}
         }`,x="result = activation(result);");const w=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${y}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${m}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${w}
         ${x}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mnt{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=ns(this.outputShape.length);const{dataFormat:s}=e,r=ms(),i=s==="channelsLast",a=i?1:2,o=i?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let h="";for(let d=0;d<=1;d++)for(let f=0;f<=1;f++)h+=`
          blockIndex = rc.z + ${f};
          pos = rc.y + ${d};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${d*2+f}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${d*2+f}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${h}

        ${r.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rm(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&e===1&&n[0]>1?[n[0],1]:null}function x3({x:n,filter:t,convInfo:e,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const u=n.shape,h=s.texData.get(n.dataId),d=e.inChannels,f=u[0]*u[1]*u[2],m=e.outChannels,y=e.dataFormat==="channelsLast",x=!1,w=!1;let S;const C=[];if(i!=null){const R=rm(i.shape,y);R!=null&&(i=Et({inputs:{x:i},backend:s,attrs:{shape:R}}),C.push(i))}if(r!=null){const R=rm(r.shape,y);R!=null&&(r=Et({inputs:{x:r},backend:s,attrs:{shape:R}}),C.push(r))}if(!((f===1||m===1)&&d>c3)&&h.isPacked&&y&&h.texture!=null&&u[2]%2!==0&&Ee(h.shape.slice(-3),u.slice(-3))){const R=u[0]*u[1]*(u[2]+1),A={dataId:n.dataId,shape:[1,R,e.inChannels],dtype:n.dtype},L=h.shape;h.shape=h.shape.slice(),h.shape[h.shape.length-2]++,M(ud(h.shape,A.shape),()=>`packed reshape ${h.shape} to ${A.shape} isn't free`);const V=Et({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}});C.push(V);const B=sm({a:A,b:V,backend:s,transposeA:x,transposeB:w,bias:r,activation:o,preluActivationWeights:i,leakyreluAlpha:a}),z=s.texData.get(B.dataId);M(z.isPacked,()=>"batchMatMul result is expected to be packed"),h.shape=L,z.shape=e.outShape,S=qs({inputs:{x:B},backend:s}),S.shape=e.outShape,C.push(B)}else{const R=e.outHeight*e.outWidth,A=Et({inputs:{x:n},backend:s,attrs:{shape:y?[e.batchSize,R,e.inChannels]:[e.batchSize,e.inChannels,R]}}),L=Et({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}}),V=sm({a:y?A:L,b:y?L:A,transposeA:!y,transposeB:w,backend:s,bias:r,activation:o,preluActivationWeights:i,leakyreluAlpha:a});S=Et({inputs:{x:V},backend:s,attrs:{shape:e.outShape}}),C.push(A),C.push(L),C.push(V)}for(const R of C)s.disposeIntermediateTensorInfo(R);return S}function b3({x:n,filter:t,convInfo:e,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const{filterWidth:u,filterHeight:h,inChannels:d,outWidth:f,outHeight:m,dataFormat:y}=e,x=y==="channelsLast",w=u*h*d,S=m*f,C=[e.batchSize,w,S],k=!0,E=!1,R=[];if(i!=null){const yt=rm(i.shape,x);yt!=null&&(i=Et({inputs:{x:i},backend:s,attrs:{shape:yt}}),R.push(i))}if(r!=null){const yt=rm(r.shape,x);yt!=null&&(r=Et({inputs:{x:r},backend:s,attrs:{shape:yt}}),R.push(r))}const A=Et({inputs:{x:t},backend:s,attrs:{shape:[1,w,ht(t.shape)/w]}});R.push(A);const L=new mnt(C,e),V=[n.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]],B=s.runWebGLProgram(L,[n],"float32",V),z=Et({inputs:{x:B},backend:s,attrs:{shape:C}});R.push(B),R.push(z);const U=r!=null,D=i!=null,Y=o==="leakyrelu",nt=o?cd(o,!0):null,dt=new u3(x?z.shape:A.shape,x?A.shape:z.shape,x?[e.batchSize,S,e.outChannels]:[e.batchSize,e.outChannels,S],k,E,U,nt,D,Y),at=x?[z,A]:[A,z];if(r&&at.push(r),D&&at.push(i),Y){const yt=s.makeTensorInfo([],"float32",Zu(a,"float32"));at.push(yt),R.push(yt)}const K=s.runWebGLProgram(dt,at,"float32"),ct=Et({inputs:{x:K},backend:s,attrs:{shape:e.outShape}});R.push(K);for(const yt of R)s.disposeIntermediateTensorInfo(yt);return ct}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gnt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:a,pad:o,dataFormat:u,dilations:h,dimRoundingMode:d}=s,f=ri(u),m=vn(r.shape,i.shape,a,h,o,d,!1,f);let y;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))y=x3({x:r,filter:i,convInfo:m,backend:e});else if(m.strideWidth<=2&&f==="channelsLast"&&tt().getBool("WEBGL_EXP_CONV")){const w=new y3(m),S=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];y=e.runWebGLProgram(w,[r,i],"float32",S)}else if(tt().getBool("WEBGL_CONV_IM2COL"))y=b3({x:r,filter:i,convInfo:m,backend:e});else{const w=new g3(m);y=e.runWebGLProgram(w,[r,i],"float32")}const x=Et({inputs:{x:y},backend:e,attrs:{shape:m.outShape}});return e.disposeIntermediateTensorInfo(y),x}const ynt={kernelName:hb,backendName:"webgl",kernelFunc:gnt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xnt{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,s=t.strideWidth,r=t.padInfo.top,i=t.padInfo.left,a=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${r};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              ${a?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class bnt{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,r=t.strideHeight,i=t.strideWidth,a=t.dataFormat==="channelsLast",o=e-1-t.padInfo.top,u=s-1-t.padInfo.left,h=a?1:2,d=a?2:3,f=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${f}];

        ivec2 dyCorner = ivec2(coords[${h}], coords[${d}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class vnt{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideDepth,s=t.strideHeight,r=t.strideWidth,i=t.padInfo.front,a=t.padInfo.top,o=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${i};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${a};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${o};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class wnt{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,s=t.filterHeight,r=t.filterWidth,i=t.strideDepth,a=t.strideHeight,o=t.strideWidth,u=e-1-t.padInfo.front,h=s-1-t.padInfo.top,d=r-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${h}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Snt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:a,pad:o,dataFormat:u,dimRoundingMode:h,filterShape:d}=s,f=ri(u),m=vn(r.shape,d,a,1,o,h,!1,f),y=new xnt(m);return e.runWebGLProgram(y,[r,i],"float32")}const Cnt={kernelName:db,backendName:"webgl",kernelFunc:Snt};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $nt{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=ns(this.outputShape.length);const e=t.filterHeight,s=t.filterWidth,r=e-1-t.padInfo.top,i=s-1-t.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tnt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{inputShape:a,strides:o,pad:u,dataFormat:h,dimRoundingMode:d}=s,f=ri(h),m=vn(a,i.shape,o,1,u,d,!1,f);if(tt().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&f==="channelsLast"){const y=[[m.strideHeight,m.strideWidth]],x=new $nt(m);return e.runWebGLProgram(x,[r,i],"float32",y)}else{const y=new bnt(m);return e.runWebGLProgram(y,[r,i],"float32")}}const knt={kernelName:fb,backendName:"webgl",kernelFunc:Tnt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _nt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:a,pad:o,dilations:u}=s,h=oo(r.shape,i.shape,a,u,o),d=new pnt(h);return e.runWebGLProgram(d,[r,i],"float32")}const Nnt={kernelName:pb,backendName:"webgl",kernelFunc:_nt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ent(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:a,pad:o,filterShape:u}=s,h=oo(r.shape,u,a,1,o),d=new vnt(h);return e.runWebGLProgram(d,[r,i],"float32")}const Rnt={kernelName:X_,backendName:"webgl",kernelFunc:Ent};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Int(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{pad:a,strides:o,inputShape:u}=s,h=oo(u,i.shape,o,1,a),d=new wnt(h);return e.runWebGLProgram(d,[r,i],"float32")}const Ant={kernelName:mb,backendName:"webgl",kernelFunc:Int};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dnt=cc+`
  return cos(x);
`,Ont=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Al}
  return result;
`,Pnt=me({opSnippet:Dnt,packedOpSnippet:Ont}),Fnt={kernelName:gb,backendName:"webgl",kernelFunc:Pnt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lnt=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Mnt=me({opSnippet:Lnt}),znt={kernelName:yb,backendName:"webgl",kernelFunc:Mnt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bnt{constructor(t,e,s,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,o,u,h]=t,[d]=e,[f,m]=s;this.outputShape=[d,f,m,h];const y=r==="bilinear"?1:0,[x,w]=[`${o-1}.0`,`${u-1}.0`],[S,C,k]=f>1?[`${(o-1)/(f-1)}`,"(y2-y1) * height_ratio",`y1*${x} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${x}`],[E,R,A]=m>1?[`${(u-1)/(m-1)}`,"(x2-x1) * width_ratio",`x1*${w} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${w}`];this.userCode=`
      const float height_ratio = float(${S});
      const float width_ratio = float(${E});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${C};
        float width_scale = ${R};

        float in_y = ${k};
        if( in_y < 0.0 || in_y > ${x} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${A};
        if( in_x < 0.0 || in_x > ${w} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${y} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vnt=n=>{const{inputs:t,backend:e,attrs:s}=n,{image:r,boxes:i,boxInd:a}=t,{cropSize:o,method:u,extrapolationValue:h}=s,d=new Bnt(r.shape,i.shape,o,u,h);return e.runWebGLProgram(d,[r,i,a],"float32")},Unt={kernelName:vb,backendName:"webgl",kernelFunc:Vnt};var dd;(function(n){n.Prod="*",n.Sum="+"})(dd||(dd={}));class ak{constructor(t,e,s,r){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,a=this.op===dd.Prod?"1.0":"0.0",o=s?a:`getX(${ok(i,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1];let h="",d="";s?(h=r?`end != ${u-1}`:"end != 0",d=r?"end + 1":"end - 1"):(h=r?`end + pow2 < ${u}`:"end >= pow2",d=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Fe(i)} coords = getOutputCoords();
        int end = ${lk(i,"coords",this.op)};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${h}) {
          int idx = ${d};
          ${lk(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${ok(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function ok(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.x, ${t}.y`;if(n===3)return`${t}.x, ${t}.y, ${t}.z`;if(n===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function lk(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.y`;if(n===3)return`${t}.z`;if(n===4)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v3(n,t,e,s,r,i){const a=t.shape.length,o=ts([s],a);let u=t;o!=null&&(u=fs({inputs:{x:t},backend:e,attrs:{perm:o}}));const h=es(1,a)[0];if(h!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${s}`);const d=u.shape[h];let f=qs({inputs:{x:u},backend:e});for(let m=0;m<=Math.ceil(Math.log2(d))-1;m++){const y=new ak(n,u.shape,!1,i),x=[[m]],w=f;f=e.runWebGLProgram(y,[f],f.dtype,x),e.disposeIntermediateTensorInfo(w)}if(r){const m=new ak(n,u.shape,r,i),y=f;f=e.runWebGLProgram(m,[f],f.dtype),e.disposeIntermediateTensorInfo(y)}if(o!=null){const m=Sd(o),y=fs({inputs:{x:f},backend:e,attrs:{perm:m}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(u),y}return f}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wnt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,exclusive:a,reverse:o}=s;return v3(dd.Prod,r,e,i,a,o)}const Gnt={kernelName:xb,backendName:"webgl",kernelFunc:Wnt};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hnt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,exclusive:a,reverse:o}=s;return v3(dd.Sum,r,e,i,a,o)}const jnt={kernelName:bb,backendName:"webgl",kernelFunc:Hnt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xnt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:i}=t,{size:a,binaryOutput:o}=s;if(r.shape.length===1){const u=e.readSync(r.dataId),h=e.readSync(i.dataId),d=t3(u,h,i.dtype,i.shape,a);return e.makeTensorInfo([a],i.dtype,d)}else if(r.shape.length===2){const u=e.bufferSync(r),h=e.bufferSync(i),d=qZ(u,h,a,o);return e.makeTensorInfo(d.shape,i.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const qnt={kernelName:wb,backendName:"webgl",kernelFunc:Xnt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Knt{constructor(t,e,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ynt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockSize:i,dataFormat:a}=s,o=r.shape[0],u=a==="NHWC"?r.shape[1]:r.shape[2],h=a==="NHWC"?r.shape[2]:r.shape[3],d=a==="NHWC"?r.shape[3]:r.shape[1],f=u*i,m=h*i,y=d/(i*i),x=a==="NHWC"?[o,f,m,y]:[o,y,f,m],w=new Knt(x,i,a);return e.runWebGLProgram(w,[r],r.dtype)}const Qnt={kernelName:Sb,backendName:"webgl",kernelFunc:Ynt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class w3{constructor(t,e=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ns(this.outputShape.length);const a=t.filterHeight,o=t.filterWidth,u=t.outChannels/t.inChannels;let h="",d="";s&&(r?h=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?h=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:h=`
          float activation(float x) {
            ${s}
          }
        `,d="result = activation(result);");const f=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${h}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${f}
        ${d}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class S3{constructor(t,e=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ns(this.outputShape.length);const a=t.outChannels/t.inChannels,o=t.padInfo.left,u=t.strideWidth,h=t.dilationWidth,d=t.filterHeight,f=t.filterWidth,m=f;let y=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let C=0;C<f;C++)y+=`
          vec4 xTexelC${C*2};
          int xTexelC${C*2}Ready;
          vec4 xTexelC${C*2+1};
          int xTexelC${C*2+1}Ready;
          vec4 xC${C};`;y+=`
    for (int r = 0; r < ${d}; r++) {
      `;for(let C=0;C<f;C++)y+=`
          xTexelC${C*2} = vec4(0.0);
          xTexelC${C*2}Ready = 0;
          xTexelC${C*2+1} = vec4(0.0);
          xTexelC${C*2+1}Ready = 0;
          xC${C} = vec4(0.0);`;y+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let C=0;C<(m+1)/2;C++){const k=C*2;if(y+=`
          xC = xCCorner + ${k*h};
          `,u===1){if(k<f&&(o%2===1?(y+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${k}Ready == 0) {
                  xTexelC${k} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${k}.zw = vec2(0.0);
                  }
                  xTexelC${k}Ready = 1;
                }
              `,h===1&&k>0?y+=`
                xC${k} = vec4(xTexelC${k-2}.zw, xTexelC${k}.xy);
                `:y+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${k} = vec4(previous.zw, xTexelC${k}.xy);
                  } else {
                    xC${k} = vec4(0.0, 0.0, xTexelC${k}.xy);
                  }
                  `):y+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${k}Ready == 0) {
                  xTexelC${k} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${k}.zw = vec2(0.0);
                  }
                  xTexelC${k}Ready = 1;
                }

                xC${k} = xTexelC${k};
                `,k+1<f)){const E=o%2===0?M0(h):h;h%2===0&&o%2===1||h%2!==0&&o%2!==1?(y+=`
                  xCOffset = xC + imod(pads[1], 2) + ${E};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${k+1}Ready == 0) {
                    xTexelC${k+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${k+1}.zw = vec2(0.0);
                    }
                    xTexelC${k+1}Ready = 1;
                  }
                  `,h>1?y+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${k+1} = vec4(previous.zw, xTexelC${k+1}.xy);
                    } else {
                     xC${k+1} = vec4(0.0, 0.0, xTexelC${k+1}.xy);
                    }
                    `:y+=`
                    xC${k+1} = vec4(xTexelC${k}.zw, xTexelC${k+1}.xy);
                    `):E===1?y+=`
                    xC${k+1} = xTexelC${k};
                    `:y+=`
                    xCOffset = xC + ${E};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${k+1}Ready == 0) {
                      xTexelC${k+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${k+1}.zw = vec2(0.0);
                      }
                      xTexelC${k+1}Ready = 1;
                    }

                    xC${k+1} = xTexelC${k+1};
                    `}}else k<f&&(o%2===1?(y+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${k}Ready == 0) {
                  xTexelC${k} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${k}.zw = vec2(0.0);
                  }
                  xTexelC${k}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${k+1}Ready == 0) {
                  xTexelC${k+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${k+1}.zw = vec2(0.0);
                  }
                  xTexelC${k+1}Ready = 1;
                }

                xC${k} = vec4(xTexelC${k}.zw, xTexelC${k+1}.zw);
              `,k+1<f&&(y+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${k+1} = vec4(xTexelC${k+1}.xy, final.xy);
                `)):(y+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${k}Ready == 0) {
                  xTexelC${k} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${k}.zw = vec2(0.0);
                  }
                  xTexelC${k}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${k+1}Ready == 0) {
                  xTexelC${k+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${k+1}.zw = vec2(0.);
                  }
                  xTexelC${k+1}Ready = 1;
                }

                xC${k} = vec4(
                  xTexelC${k}.xy, xTexelC${k+1}.xy);
              `,k+1<f&&(y+=`
                  xC${k+1} = vec4(xTexelC${k}.zw, xTexelC${k+1}.zw);
                `)));k<f&&(y+=`
            wTexel = getW(r, ${k}, d1, q);
            dotProd += xC${k} * vec4(wTexel.xz, wTexel.xz);
          `,k+1<f&&(y+=`
              wTexel = getW(r, ${k+1}, d1, q);
              dotProd += xC${k+1} * vec4(wTexel.xz, wTexel.xz);
            `))}y+=`
    }
  `,y+=`
      }
    `;let x="",w="";s&&(r?x=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?x=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:x=`vec4 activation(vec4 x) {
          ${s}
        }`,w="result = activation(result);");const S=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${x}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${y}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${S}
        ${w}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Znt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:a,pad:o,dilations:u,dimRoundingMode:h}=s;let d=u;d==null&&(d=[1,1]),M(ps(a,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`);const f=vn(r.shape,i.shape,a,d,o,h,!0);let m;tt().getBool("WEBGL_PACK_DEPTHWISECONV")&&f.strideWidth<=2&&f.outChannels/f.inChannels===1?m=new S3(f):m=new w3(f);const y=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];return e.runWebGLProgram(m,[r,i],"float32",y)}const Jnt={kernelName:Cb,backendName:"webgl",kernelFunc:Znt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tst{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,s=t.strideWidth,r=t.padInfo.top,i=t.padInfo.left,a=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${r};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class est{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,r=t.strideHeight,i=t.strideWidth,a=e-1-t.padInfo.top,o=s-1-t.padInfo.left,u=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nst(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:a,dilations:o,pad:u,dimRoundingMode:h,filterShape:d}=s,f=vn(r.shape,d,a,o,u,h,!0),m=new tst(f);return e.runWebGLProgram(m,[r,i],"float32")}const sst={kernelName:$b,backendName:"webgl",kernelFunc:nst};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rst(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{strides:a,dilations:o,pad:u,dimRoundingMode:h,inputShape:d}=s,f=vn(d,i.shape,a,o,u,h,!0),m=new est(f);return e.runWebGLProgram(m,[r,i],"float32")}const ist={kernelName:Tb,backendName:"webgl",kernelFunc:rst};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ast{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ost(n){const{inputs:t,backend:e}=n,{x:s}=t,r=[...s.shape,...s.shape],i=ht(s.shape),a=Et({inputs:{x:s},backend:e,attrs:{shape:[i]}}),o=new ast(i),u=e.runWebGLProgram(o,[a],a.dtype),h=Et({inputs:{x:u},backend:e,attrs:{shape:r}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),h}const lst={kernelName:kb,backendName:"webgl",kernelFunc:ost};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ust{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:s,padInfo:r,strideHeight:i,strideWidth:a,filterHeight:o,filterWidth:u,dilationHeight:h,dilationWidth:d}=t,{top:f,left:m}=r;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${a});
      const ivec2 pads = ivec2(${f}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${h};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${d};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cst(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:a,pad:o,dilations:u}=s,h=vd(r.shape,i.shape,a,o,"NHWC",u);let d;const f=new ust(h);d=e.runWebGLProgram(f,[r,i],"float32");const m=Et({inputs:{x:d},backend:e,attrs:{shape:h.outShape}});return e.disposeIntermediateTensorInfo(d),m}const hst={kernelName:_b,backendName:"webgl",kernelFunc:cst};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dst(n){const{inputs:t,backend:e,attrs:s}=n,{equation:r}=s,i=t,{allDims:a,summedDims:o,idDims:u}=iw(r,i.length);ow(a.length,u,i);const{path:h,steps:d}=lw(o,u),f=d.length;let m=null,y=a.length;const x=[];for(let w=0;w<f;++w){for(const S of d[w]){const{permutationIndices:C,expandDims:k}=aw(y,u[S]);let E;uw(C)?E=i[S]:(E=fs({inputs:{x:i[S]},backend:e,attrs:{perm:C}}),x.push(E));const R=E.shape.slice();for(let A=0;A<k.length;++A)R.splice(k[A],0,1);Ee(E.shape,R)||(E=Et({inputs:{x:E},backend:e,attrs:{shape:R}}),x.push(E)),m===null?m=E:(m=Iw({inputs:{a:E,b:m},backend:e}),x.push(m))}w<f-1&&(h[w]>=0&&(m=zm({inputs:{x:m},backend:e,attrs:{axis:h[w]-(a.length-y),keepDims:!1}}),x.push(m)),y--)}for(const w of x)w!==m&&e.disposeIntermediateTensorInfo(w);return m}const fst={kernelName:Eb,backendName:"webgl",kernelFunc:dst};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pst="return (x >= 0.0) ? x : (exp(x) - 1.0);",mst=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,gst=me({opSnippet:pst,packedOpSnippet:mst}),yst={kernelName:Rb,backendName:"webgl",kernelFunc:gst};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xst="return (b >= 0.0) ? a : a * (b + 1.0);",bst=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,vst=n=>{const{inputs:t,backend:e}=n,{dy:s,y:r}=t,i=tt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new uc(bst,s.shape,r.shape):new Sl(xst,s.shape,r.shape);return e.runWebGLProgram(i,[s,r],s.dtype)},wst={kernelName:K_,backendName:"webgl",kernelFunc:vst};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sst=`
  return vec4(equal(a, b));
`,Cst="return float(a == b);",$st=Vn({opSnippet:Cst,packedOpSnippet:Sst,dtype:"bool",cpuKernelImpl:JZ}),Tst={kernelName:Ab,backendName:"webgl",kernelFunc:$st};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kst=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${Jv};
  float a1 = ${tw};
  float a2 = ${ew};
  float a3 = ${nw};
  float a4 = ${sw};
  float a5 = ${rw};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,_st=me({opSnippet:kst}),Nst={kernelName:Ib,backendName:"webgl",kernelFunc:_st};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Est=cc+`
  return exp(x);
`,Rst=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,C3=me({opSnippet:Est,packedOpSnippet:Rst,cpuKernelImpl:tJ,dtype:"float32"}),Ist={kernelName:Db,backendName:"webgl",kernelFunc:C3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _0(n){const{inputs:t,attrs:e,backend:s}=n,{dim:r}=e,{input:i}=t,a=i.shape.length,o=i.shape.slice();let u=r;return r<0&&(M(-(a+1)<=r,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+r+1),o.splice(u,0,1),Et({inputs:{x:i},backend:s,attrs:{shape:o}})}const Ast={kernelName:Ob,backendName:"webgl",kernelFunc:_0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uk="return exp(x) - 1.0;",Dst=me({opSnippet:uk,packedOpSnippet:uk,cpuKernelImpl:eJ}),Ost={kernelName:Pb,backendName:"webgl",kernelFunc:Dst};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ck{constructor(t,e,s){this.variableNames=["real","imag"];const r=e[1];this.outputShape=e;const i=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=s?`${r}.0`:"1.0";let o;if(t==="real")o="return real * expR - imag * expI;";else if(t==="imag")o="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $3(n,t,e){const s=e.texData.get(n.dataId),r=ht(n.shape),i=n.shape[n.shape.length-1],a=r/i,o=Et({inputs:{x:n},backend:e,attrs:{shape:[a,i]}}),u=o.shape,h=new ck("real",u,t),d=new ck("imag",u,t),f=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:u},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:u}],m=e.runWebGLProgram(h,f,"float32"),y=e.runWebGLProgram(d,f,"float32"),x=uo({inputs:{real:m,imag:y},backend:e});e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y);const w=Et({inputs:{x},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(x),w}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pst(n){const{inputs:t,backend:e}=n,{input:s}=t;return $3(s,!1,e)}const Fst={kernelName:Fb,backendName:"webgl",kernelFunc:Pst};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lst{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rd(n){const{backend:t,attrs:e}=n,{shape:s,value:r}=e;let{dtype:i}=e;if(i=i||Qu(r),i==="string"){const a=kn(i,ht(s));return a.fill(r),t.makeTensorInfo(s,i,a)}else{const a=new Lst(s,r),o=[[r]];return t.runWebGLProgram(a,[],i,o)}}const Mst={kernelName:Lb,backendName:"webgl",kernelFunc:Rd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zst{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bst={kernelName:Mb,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,s=t,r=new zst(e.shape);return s.runWebGLProgram(r,[e],e.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hk="return floor(x);",Vst=me({opSnippet:hk,packedOpSnippet:hk,cpuKernelImpl:nJ}),Ust={kernelName:zb,backendName:"webgl",kernelFunc:Vst};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wst=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Gst=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Hst=Vn({opSnippet:Wst,packedOpSnippet:Gst,dtype:"int32"}),jst={kernelName:Bb,backendName:"webgl",kernelFunc:Hst};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xst{constructor(t){this.variableNames=["A"];const e=ms(),[s,r]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qst{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=ms(),[s,r]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kst={kernelName:zp,backendName:"webgl",kernelFunc:Yst};let Nu,Tx=tt().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Yst(n){const{inputs:t,backend:e,attrs:s}=n;let{pixels:r}=t;const{numChannels:i}=s,a=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[u,h]=a?[r.videoWidth,r.videoHeight]:[r.width,r.height],d=[h,u],f=[h,u,i];if(o||a){const w=tt().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Nu==null||w!==Tx)&&(Tx=w,Nu=document.createElement("canvas").getContext("2d",{willReadFrequently:Tx})),Nu.canvas.width=u,Nu.canvas.height=h,Nu.drawImage(r,0,0,u,h),r=Nu.canvas}const m=e.makeTensorInfo(d,"int32");e.texData.get(m.dataId).usage=hr.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(m.dataId),r);const y=tt().getBool("WEBGL_PACK")?new qst(f):new Xst(f),x=e.runWebGLProgram(y,[m],"int32");return e.disposeData(m.dataId),x}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qst(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=t,{strides:u,pad:h,dataFormat:d,dilations:f,dimRoundingMode:m,activation:y,leakyreluAlpha:x}=s,w=ri(d),S=vn(r.shape,i.shape,u,f,h,m,!1,w);let C;const k=[],E=a!=null,R=o!=null,A=y==="leakyrelu",L=()=>{const B=[r,i],z=(U,D)=>{if(D==="NCHW"&&U.shape.length===1&&U.shape[0]!==1){const Y=Et({inputs:{x:U},backend:e,attrs:{shape:[U.shape[0],1,1]}});return k.push(Y),Y}return U};if(E&&B.push(z(a,d)),R&&B.push(z(o,d)),A){const U=e.makeTensorInfo([],"float32",Zu(x,"float32"));B.push(U),k.push(U)}return B};if(S.filterHeight===1&&S.filterWidth===1&&S.dilationHeight===1&&S.dilationWidth===1&&S.strideHeight===1&&S.strideWidth===1&&(S.padInfo.type==="SAME"||S.padInfo.type==="VALID"))C=x3({x:r,filter:i,convInfo:S,backend:e,bias:a,activation:y,preluActivationWeights:o,leakyreluAlpha:x});else if(S.strideWidth<=2&&w==="channelsLast"&&tt().getBool("WEBGL_EXP_CONV")){const B=y?cd(y,!0):null,z=new y3(S,E,B,R,A),U=[[S.padInfo.top,S.padInfo.left],[S.strideHeight,S.strideWidth],[S.dilationHeight,S.dilationWidth],[S.inHeight,S.inWidth]],D=L();C=e.runWebGLProgram(z,D,"float32",U)}else if(tt().getBool("WEBGL_CONV_IM2COL"))C=b3({x:r,filter:i,convInfo:S,backend:e,bias:a,activation:y,preluActivationWeights:o,leakyreluAlpha:x});else{const B=y?cd(y,!1):null,z=new g3(S,E,B,R,A),U=L();C=e.runWebGLProgram(z,U,"float32")}const V=Et({inputs:{x:C},backend:e,attrs:{shape:S.outShape}});return k.push(C),k.forEach(B=>e.disposeIntermediateTensorInfo(B)),V}const Zst={kernelName:Vp,backendName:"webgl",kernelFunc:Qst};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jst(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=t,{strides:u,pad:h,dilations:d,dimRoundingMode:f,activation:m,leakyreluAlpha:y}=s,x=[];let w=d;w==null&&(w=[1,1]),M(ps(u,w),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${w}'`);const S=vn(r.shape,i.shape,u,w,h,f,!0),C=tt().getBool("WEBGL_PACK_DEPTHWISECONV")&&S.strideWidth<=2&&S.outChannels/S.inChannels===1,k=m?cd(m,C):null,E=[r,i],R=a!=null,A=o!=null,L=m==="leakyrelu";if(R&&E.push(a),A&&E.push(o),L){const U=e.makeTensorInfo([],"float32",Zu(y,"float32"));E.push(U),x.push(U)}let V;C?V=new S3(S,R,k,A,L):V=new w3(S,R,k,A,L);const B=[[S.padInfo.top,S.padInfo.left],[S.strideHeight,S.strideWidth],[S.dilationHeight,S.dilationWidth],[S.inHeight,S.inWidth]],z=e.runWebGLProgram(V,E,"float32",B);return x.forEach(U=>e.disposeIntermediateTensorInfo(U)),z}const trt={kernelName:Up,backendName:"webgl",kernelFunc:Jst};class ert{constructor(t,e,s,r){this.sliceDim=t,this.strides=e,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const i=Fe(s.length);let a=`
    int index;`;for(let o=0;o<this.sliceDim;o++)a+=`
          index = round(getIndices(coords[0], ${o}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};
          flattenIndex += index * ${this.strides[o]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nrt(n){const{inputs:t,backend:e}=n,{params:s,indices:r}=t,i=r.shape,a=i[i.length-1],o=ht(s.shape),[u,h,d,f]=zv(s,r),m=Et({inputs:{x:r},backend:e,attrs:{shape:[h,a]}}),y=Et({inputs:{x:s},backend:e,attrs:{shape:[ht(s.shape)/d,d]}});if(e.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const C=e.readSync(r.dataId),k=e.bufferSync(s),E=sJ(C,k,s.dtype,h,a,d,f,s.shape,o);return e.makeTensorInfo(u,s.dtype,E.values)}const x=new ert(a,f,[h,d],s.shape),w=e.runWebGLProgram(x,[y,m],y.dtype),S=Et({inputs:{x:w},backend:e,attrs:{shape:u}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(w),S}const srt={kernelName:Wb,backendName:"webgl",kernelFunc:nrt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rrt{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const s=Fe(this.rank),r=irt(t);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function irt(n,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("index"):s.push(`${e[r]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T3(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,indices:i}=t,{axis:a,batchDims:o}=s,u=Qe(a,r.shape)[0];if(tt().get("DEBUG")){const k=e.readSync(i.dataId),E=r.shape[u];for(let R=0;R<k.length;++R){const A=k[R];M(A<=E-1&&A>=0,()=>`GatherV2: the index value ${A} is not in [0, ${E-1}]`)}}const h=dw(r,i,u,o),d=ht(i.shape),f=[],m=Et({inputs:{x:r},backend:e,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),y=Et({inputs:{x:i},backend:e,attrs:{shape:[h.batchSize,d/h.batchSize]}});f.push(m),f.push(y);const x=[h.batchSize,h.outerSize,d/h.batchSize,h.sliceSize];if(e.shouldExecuteOnCPU([r,i])||r.dtype==="string"){const k=e.bufferSync(y),E=e.bufferSync(m),R=rJ(E,k,x);return f.forEach(A=>e.disposeIntermediateTensorInfo(A)),e.makeTensorInfo(h.outputShape,R.dtype,R.values)}const w=new rrt(m.shape,x),S=e.runWebGLProgram(w,[m,y],m.dtype);f.push(S);const C=Et({inputs:{x:S},backend:e,attrs:{shape:h.outputShape}});return f.forEach(k=>e.disposeIntermediateTensorInfo(k)),C}const art={kernelName:Ub,backendName:"webgl",kernelFunc:T3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ort="return float(a > b);",lrt=`
  return vec4(greaterThan(a, b));
`,urt=Vn({opSnippet:ort,packedOpSnippet:lrt,cpuKernelImpl:iJ,dtype:"bool"}),crt={kernelName:Gb,backendName:"webgl",kernelFunc:urt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hrt="return float(a >= b);",drt=`
  return vec4(greaterThanEqual(a, b));
`,frt=Vn({opSnippet:hrt,packedOpSnippet:drt,dtype:"bool",cpuKernelImpl:aJ}),prt={kernelName:Hb,backendName:"webgl",kernelFunc:frt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mrt(n){const{inputs:t,backend:e}=n,{input:s}=t;return $3(s,!0,e)}const grt={kernelName:jb,backendName:"webgl",kernelFunc:mrt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yrt="return float(!isnan(x) && !isinf(x));",xrt=me({opSnippet:yrt,dtype:"bool"}),brt={kernelName:qb,backendName:"webgl",kernelFunc:xrt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vrt="return float(isinf(x));",wrt=me({opSnippet:vrt,dtype:"bool"}),Srt={kernelName:Kb,backendName:"webgl",kernelFunc:wrt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Crt="return float(isnan(x));",$rt=me({opSnippet:Crt,dtype:"bool"}),Trt={kernelName:Yb,backendName:"webgl",kernelFunc:$rt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const krt="return float(a < b);",_rt=`
  return vec4(lessThan(a, b));
`,Nrt=Vn({opSnippet:krt,packedOpSnippet:_rt,cpuKernelImpl:oJ,dtype:"bool"}),Ert={kernelName:Zb,backendName:"webgl",kernelFunc:Nrt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rrt="return float(a <= b);",Irt=`
  return vec4(lessThanEqual(a, b));
`,Art=Vn({opSnippet:Rrt,packedOpSnippet:Irt,cpuKernelImpl:lJ,dtype:"bool"}),Drt={kernelName:Jb,backendName:"webgl",kernelFunc:Art};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ort(n){const{backend:t,attrs:e}=n,{start:s,stop:r,num:i}=e,a=uJ(s,r,i);return t.makeTensorInfo([a.length],"float32",a)}const Prt={kernelName:t1,backendName:"webgl",kernelFunc:Ort};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Frt=cc+`
  return x < 0.0 ? 0./0. : log(x);
`,Lrt=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Mrt=me({opSnippet:Frt,packedOpSnippet:Lrt,cpuKernelImpl:cJ}),zrt={kernelName:e1,backendName:"webgl",kernelFunc:Mrt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Brt=cc+`
  return log(1.0 + x);
`,Vrt=me({opSnippet:Brt}),Urt={kernelName:n1,backendName:"webgl",kernelFunc:Vrt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wrt="return float(a >= 1.0 && b >= 1.0);",Grt=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Hrt=Vn({opSnippet:Wrt,packedOpSnippet:Grt,dtype:"bool"}),jrt={kernelName:s1,backendName:"webgl",kernelFunc:Hrt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xrt="return float(!(x >= 1.0));",qrt=me({opSnippet:Xrt}),Krt={kernelName:r1,backendName:"webgl",kernelFunc:qrt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yrt="return float(a >= 1.0 || b >= 1.0);",Qrt=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,Zrt=Vn({opSnippet:Yrt,packedOpSnippet:Qrt,dtype:"bool"}),Jrt={kernelName:i1,backendName:"webgl",kernelFunc:Zrt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tit{constructor(t,e,s,r,i){this.variableNames=["x"],this.outputShape=[];const a=e,o=t[3]-1;this.outputShape=t;let u;const h=`float(${s}) + float(${r}) * sum`;i===.5?u=`inversesqrt(${h})`:i===1?u=`1.0/(${h})`:u=`exp(log(${h}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eit{constructor(t,e,s,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=e,o=t[3]-1;this.outputShape=t;let u;const h=`float(${s}) + float(${r}) * sum`;i===.5?u=`inversesqrt(${h})`:i===1?u=`1.0/(${h})`:u=`exp(log(${h}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nit=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{depthRadius:i,bias:a,alpha:o,beta:u}=s,h=tt().getBool("WEBGL_PACK_NORMALIZATION")?new eit(r.shape,i,a,o,u):new tit(r.shape,i,a,o,u);return e.runWebGLProgram(h,[r],r.dtype)},sit={kernelName:a1,backendName:"webgl",kernelFunc:nit};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rit{constructor(t,e,s,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=s,this.alpha=r,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iit=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r,y:i,dy:a}=t,{depthRadius:o,bias:u,alpha:h,beta:d}=s,f=new rit(r.shape,o,u,h,d);return e.runWebGLProgram(f,[r,i,a],r.dtype)},ait={kernelName:Y_,backendName:"webgl",kernelFunc:iit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oit(n,t,e,s){const r=ht(t),a=ht(n.shape)/r,o=Et({inputs:{x:n},attrs:{shape:[a,r]},backend:s}),u=Dl(o,n.dtype,"max",s),h=Et({inputs:{x:u},attrs:{shape:e},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(u),h}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k3(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reductionIndices:i,keepDims:a}=s,o=r.shape.length,u=Qe(i,r.shape);let h=u;const d=ts(h,o),f=d!=null,m=e.shouldExecuteOnCPU([r]);let y=r;if(f){if(m){const E=e.texData.get(y.dataId).values,R=new Array(o);for(let V=0;V<R.length;V++)R[V]=r.shape[d[V]];const A=Ew(E,r.shape,r.dtype,d,R);y=e.makeTensorInfo(R,r.dtype);const L=e.texData.get(y.dataId);L.values=A}else y=Mm(r,d,e);h=es(h.length,o)}Qs("max",h,o);const[x,w]=mr(y.shape,h);let S=x;a&&(S=Ys(x,u));let C;if(m){const E=e.texData.get(y.dataId).values,R=hJ(E,ht(w),S,r.dtype);C=e.makeTensorInfo(S,r.dtype);const A=e.texData.get(C.dataId);A.values=R}else C=oit(y,w,S,e);return f&&e.disposeIntermediateTensorInfo(y),C}const lit={kernelName:o1,backendName:"webgl",kernelFunc:k3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uit=Rw+`
  return max(a, b);
`,cit=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Al+`
  return result;
`,hit=Vn({opSnippet:uit,packedOpSnippet:cit,cpuKernelImpl:dJ}),dit={kernelName:l1,backendName:"webgl",kernelFunc:hit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fit(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;rc(r,"maxPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:u}=s,h=1;M(ps(a,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${h}'`);const d=Mr(r.shape,i,a,h,o,u);if(d.filterWidth===1&&d.filterHeight===1&&Ee(d.inShape,d.outShape))return qs({inputs:{x:r},backend:e});const f=new hd(d,"max",!1);return e.runWebGLProgram(f,[r],r.dtype)}const pit={kernelName:u1,backendName:"webgl",kernelFunc:fit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mit(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:i,strides:a,pad:o,dataFormat:u,dimRoundingMode:h}=s,d=[1,1,1],f=la(r.shape,i,a,d,o,h,u),m=new Aw(f,"max",!1);return e.runWebGLProgram(m,[r],r.dtype)}const git={kernelName:c1,backendName:"webgl",kernelFunc:mit};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yit{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideHeight,s=t.strideWidth,r=t.dilationHeight,i=t.effectiveFilterHeight,a=t.effectiveFilterWidth,o=i-1-t.padInfo.top,u=a-1-t.padInfo.left,h=i*a-1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${h} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class xit{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideDepth,s=t.strideHeight,r=t.strideWidth,i=t.dilationDepth,a=t.dilationHeight,o=t.dilationWidth,u=t.effectiveFilterDepth,h=t.effectiveFilterHeight,d=t.effectiveFilterWidth,f=u-1-t.padInfo.front,m=h-1-t.padInfo.top,y=d-1-t.padInfo.left,x=u*h*d-1;this.userCode=`
      const ivec3 pads = ivec3(${f}, ${m}, ${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${x} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${h} * ${d} +
                  wR * ${d} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bit(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,a=i,{filterSize:o,strides:u,pad:h,dimRoundingMode:d}=s,f=[1,1,1],m=la(a.shape,o,u,f,h,d),y=new Aw(m,"max",!0),x=e.runWebGLProgram(y,[a],a.dtype),w=new xit(m),S=e.runWebGLProgram(w,[r,x],a.dtype);return e.disposeIntermediateTensorInfo(x),S}const vit={kernelName:Z_,backendName:"webgl",kernelFunc:bit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wit(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i,output:a}=t,o=i;rc([i,a],"maxPoolGrad");const{filterSize:u,strides:h,pad:d,dimRoundingMode:f}=s,m=Mr(o.shape,u,h,1,d,f),y=!0,x=new hd(m,"max",y),w=e.runWebGLProgram(x,[o],o.dtype),S=new yit(m),C=e.runWebGLProgram(S,[r,w],o.dtype);return e.disposeIntermediateTensorInfo(w),C}const Sit={kernelName:Q_,backendName:"webgl",kernelFunc:wit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cit(n,t,e,s){let r=new hd(e,"max",!1);const i=s.runWebGLProgram(r,[n],"float32");r=new hd(e,"max",!0,!0,t);const a=s.runWebGLProgram(r,[n],"float32");return[i,a]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $it={kernelName:h1,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{filterSize:r,strides:i,pad:a,includeBatchInIndex:o}=t,u=e;M(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const h=[1,1];M(ps(i,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const d=Mr(s.shape,r,i,h,a),[f,m]=Cit(s,o,d,u);return[f,m]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tit(n,t,e,s){const r=ht(t),a=ht(n.shape)/r,o=Et({inputs:{x:n},attrs:{shape:[a,r]},backend:s}),u=Dl(o,"float32","mean",s),h=Et({inputs:{x:u},attrs:{shape:e},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(u),h}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kit={kernelName:d1,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{keepDims:r,axis:i}=t,a=e,o=s.shape.length,u=Qe(i,s.shape);let h=u;const d=ts(h,o),f=d!=null,m=a.shouldExecuteOnCPU([s]),y=[];let x=s;if(f){if(m){const R=a.texData.get(x.dataId).values,A=new Array(o);for(let B=0;B<A.length;B++)A[B]=s.shape[d[B]];const L=Ew(R,s.shape,s.dtype,d,A);x=a.makeTensorInfo(A,s.dtype);const V=a.texData.get(x.dataId);V.values=L}else x=Mm(s,d,a);y.push(x),h=es(h.length,o)}Qs("sum",h,o);const[w,S]=mr(x.shape,h);let C=w;r&&(C=Ys(w,u));const k=Tit(x,S,C,a);for(const E of y)a.disposeIntermediateTensorInfo(E);return k}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _it(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:a}=s,o=r.shape.length,u=Qe(i,r.shape);let h=u;const d=ts(h,o);let f=r;d!=null&&(f=fs({inputs:{x:r},backend:e,attrs:{perm:d}}),h=es(h.length,r.shape.length)),Qs("min",h,o);const[m,y]=mr(f.shape,h),x=ht(y),w=Et({inputs:{x:f},backend:e,attrs:{shape:[-1,x]}}),S=Dl(w,w.dtype,"min",e);let C;if(a){const k=Ys(m,u);C=Et({inputs:{x:S},backend:e,attrs:{shape:k}})}else C=Et({inputs:{x:S},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(S),d!=null&&e.disposeIntermediateTensorInfo(f),C}const Nit={kernelName:f1,backendName:"webgl",kernelFunc:_it};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eit=Rw+`
  return min(a, b);
`,Rit=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Al+`
  return result;
`,Iit=Vn({opSnippet:Eit,packedOpSnippet:Rit,cpuKernelImpl:fJ}),Ait={kernelName:p1,backendName:"webgl",kernelFunc:Iit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dit{constructor(t,e,s){this.variableNames=["x"],this.outputShape=e.map((d,f)=>d[0]+t[f]+d[1]);const r=t.length,i=Fe(r),a=e.map(d=>d[0]).join(","),o=e.map((d,f)=>d[0]+t[f]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),h=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${h};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${h};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${a});
      ${i} end = ${i}(${o});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${h};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${h};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Oit{constructor(t,e,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((x,w)=>x[0]+t[w]+x[1]);const r=t.length,i=Fe(r),a=e.map(x=>x[0]).join(","),o=e.map((x,w)=>x[0]+t[w]).join(","),u=hs("rc",r),h=hs("source",r),d=`${u[r-1]} < ${this.outputShape[r-1]}`,f=r===1?"source":`vec2(${h.slice(-2).join()})`,m=s==="reflect"?0:1;let y="";if(r===1){const x=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;y=`
        ${i} rc = outputLoc;
        ${x}
        result[0] = getChannel(getX(${h.join()}), ${f});
        ${u[r-1]} += 1;
        if(${d}) {
          ${x}
          result[1] = getChannel(getX(${h.join()}), ${f});
        }
      `}else{const x=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;y=`
        ${i} rc = outputLoc;
        ${x}
        result[0] = getChannel(getX(${h.join()}), ${f});
        ${u[r-1]} += 1;
        if(${d}) {
          ${x}
          result[1] = getChannel(getX(${h.join()}), ${f});
        }
        rc = outputLoc;
        ${u[r-2]} += 1;
        if(${u[r-2]} < ${this.outputShape[r-2]}) {
          ${x}
          result[2] = getChannel(getX(${h.join()}), ${f});
          ${u[r-1]} += 1;
          if(${d}) {
            ${x}
            result[3] = getChannel(getX(${h.join()}), ${f});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${a});
      const ${i} end = ${i}(${o});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${y}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pit=({inputs:n,backend:t,attrs:e})=>{const{x:s}=n,{paddings:r,mode:i}=e,a=tt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Oit(s.shape,r,i):new Dit(s.shape,r,i);return t.runWebGLProgram(a,[s],s.dtype)},Fit={kernelName:m1,backendName:"webgl",kernelFunc:Pit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lit=`if (b == 0.0) return NAN;
  return mod(a, b);`,Mit=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Al+`
  return result;
`,zit=Vn({opSnippet:Lit,packedOpSnippet:Mit}),Bit={kernelName:g1,backendName:"webgl",kernelFunc:zit};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vit{constructor(t,e,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uit=`
if (a == b) {
  return 1.0;
};
return a / b;`,Wit=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,_3=Vn({opSnippet:Uit,packedOpSnippet:Wit,checkOutOfBounds:!0}),Git={kernelName:Nb,backendName:"webgl",kernelFunc:_3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dk="return a - b;",N3=Vn({opSnippet:dk,packedOpSnippet:dk,supportsComplex:!0,cpuKernelImpl:OJ}),Hit={kernelName:uv,backendName:"webgl",kernelFunc:N3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E3(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{dim:i}=s,a=Qe([i],r.shape),o=k3({inputs:{x:r},backend:e,attrs:{reductionIndices:a,keepDims:!1}}),u=Ys(o.shape,a),h=Et({inputs:{x:o},backend:e,attrs:{shape:u}}),d=N3({inputs:{a:r,b:h},backend:e}),f=C3({inputs:{x:d},backend:e}),m=zm({inputs:{x:f},backend:e,attrs:{axis:a,keepDims:!1}}),y=Et({inputs:{x:m},backend:e,attrs:{shape:u}}),x=_3({inputs:{a:f,b:y},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),x}const jit={kernelName:nv,backendName:"webgl",kernelFunc:E3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xit(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{numSamples:i,seed:a,normalized:o}=s,u=o?r:E3({inputs:{logits:r},backend:e,attrs:{dim:r.shape.length-1}}),h=u.shape[0],d=u.shape[1],f=new Vit(h,d,i),m=[[a]],y=e.runWebGLProgram(f,[u],"int32",m);return o||e.disposeIntermediateTensorInfo(u),y}const qit={kernelName:y1,backendName:"webgl",kernelFunc:Xit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kit=Br+`
  return -x;
`,Yit=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Qit(n){const{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])){const i=e.texData.get(s.dataId),[a,o]=mJ(i.values,s.shape,s.dtype);return e.makeTensorInfo(o,s.dtype,a)}let r;return tt().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Ha(s.shape,Yit):r=new yi(s.shape,Kit),e.runWebGLProgram(r,[s],s.dtype)}const Zit={kernelName:b1,backendName:"webgl",kernelFunc:Qit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jit=Dv;function tat(n){Jr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u}=s,h=e.readSync(r.dataId),d=e.readSync(i.dataId),{selectedIndices:f}=Jit(h,d,a,o,u);return e.makeTensorInfo([f.length],"int32",new Int32Array(f))}const eat={kernelName:w1,backendName:"webgl",kernelFunc:tat};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nat=IE;function sat(n){Jr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:h}=s,d=e.readSync(r.dataId),f=e.readSync(i.dataId),{selectedIndices:m,validOutputs:y}=nat(d,f,a,o,u,h);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([],"int32",new Int32Array([y]))]}const rat={kernelName:J_,backendName:"webgl",kernelFunc:sat};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iat=Ov;function aat(n){Jr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u,softNmsSigma:h}=s,d=e.readSync(r.dataId),f=e.readSync(i.dataId),m=a,y=o,x=u,w=h,{selectedIndices:S,selectedScores:C}=iat(d,f,m,y,x,w);return[e.makeTensorInfo([S.length],"int32",new Int32Array(S)),e.makeTensorInfo([C.length],"float32",new Float32Array(C))]}const oat={kernelName:S1,backendName:"webgl",kernelFunc:aat};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lat{constructor(t,e,s,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uat=n=>{const{inputs:t,backend:e,attrs:s}=n,{indices:r}=t,{dtype:i,depth:a,onValue:o,offValue:u}=s,h=ht(r.shape),d=new lat(h,a,o,u),f=Et({inputs:{x:r},backend:e,attrs:{shape:[h]}}),m=e.runWebGLProgram(d,[f],i);e.disposeIntermediateTensorInfo(f);const y=[...r.shape,a],x=Et({inputs:{x:m},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(m),x},cat={kernelName:$1,backendName:"webgl",kernelFunc:uat};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function im(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="complex64"){const r=Ed({inputs:{input:s},backend:e}),i=im({inputs:{x:r},backend:e}),a=Bm({inputs:{input:s},backend:e}),o=im({inputs:{x:a},backend:e}),u=uo({inputs:{real:i,imag:o},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(o),u}else return Rd({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:e})}const hat={kernelName:gv,backendName:"webgl",kernelFunc:im};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R3(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=Ed({inputs:{input:s},backend:e}),i=R3({inputs:{x:r},backend:e}),a=Bm({inputs:{input:s},backend:e}),o=im({inputs:{x:a},backend:e}),u=uo({inputs:{real:i,imag:o},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(o),u}else return Rd({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:e})}const dat={kernelName:C1,backendName:"webgl",kernelFunc:R3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fat(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s;if(t.length===1)return _0({inputs:{input:t[0]},backend:e,attrs:{dim:r}});const i=t[0].shape,a=t[0].dtype;t.forEach(d=>{Ks(i,d.shape,"All tensors passed to stack must have matching shapes"),M(a===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],u=t.map(d=>{const f=_0({inputs:{input:d},backend:e,attrs:{dim:r}});return o.push(f),f}),h=m3({inputs:u,backend:e,attrs:{axis:r}});return o.forEach(d=>e.disposeIntermediateTensorInfo(d)),h}const pat={kernelName:T1,backendName:"webgl",kernelFunc:fat};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mat{constructor(t,e,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((h,d)=>h[0]+t[d]+h[1]);const r=t.length,i=Fe(r),a=e.map(h=>h[0]).join(","),o=e.map((h,d)=>h[0]+t[d]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${a});
      ${i} end = ${i}(${o});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gat{constructor(t,e,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((w,S)=>w[0]+t[S]+w[1]);const r=t.length,i=Fe(r),a=e.map(w=>w[0]).join(","),o=e.map((w,S)=>w[0]+t[S]).join(","),u=hs("rc",r),h=hs("source",r),d=`${u[r-1]} < ${this.outputShape[r-1]}`,f=r===1?"source":`vec2(${h.slice(-2).join()})`,m=[`${i} rc = outputLoc;`,`${u[r-1]} += 1;
       if(${d}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${u[r-2]} += 1;
       if(${u[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${u[r-1]} += 1;
         if(${d}) {`],y=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let x="";for(let w=0,S=r===1?2:4;w<S;w++)x+=`
        ${m[w]}
        if (${y}) {
          result[${w}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${w}] = getChannel(getX(${h.join()}), ${f});
        }
      `;x+=r===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${a});
      const ${i} end = ${i}(${o});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${x}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I3=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{paddings:i,constantValue:a}=s;if(ht(r.shape)===0){const h=i.map((d,f)=>d[0]+r.shape[f]+d[1]);return Rd({backend:e,attrs:{shape:h,value:a,dtype:r.dtype}})}const o=tt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new gat(r.shape,i,a):new mat(r.shape,i,a),u=[[a]];return e.runWebGLProgram(o,[r],r.dtype,u)},yat={kernelName:k1,backendName:"webgl",kernelFunc:I3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xat=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,bat=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Al+`
  return result;
`,vat=Vn({opSnippet:xat,packedOpSnippet:bat}),wat={kernelName:_1,backendName:"webgl",kernelFunc:vat};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sat(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:a}=s,o=r.shape.length,u=[],h=Qe(i,r.shape);let d=h;const f=ts(d,o);let m=r;f!=null&&(m=fs({inputs:{x:r},backend:e,attrs:{perm:f}}),d=es(d.length,o),u.push(m)),Qs("prod",d,o);let y;if(e.shouldExecuteOnCPU([m])){const x=e.texData.get(m.dataId).values,{outVals:w,outShape:S,outDtype:C}=yJ(m.shape,m.dtype,x,d);y=e.makeTensorInfo(S,C,w)}else{const[x,w]=mr(m.shape,d),S=ht(w),C=Et({inputs:{x:m},backend:e,attrs:{shape:[-1,S]}}),k=vm(r.dtype),E=Dl(C,k,"prod",e);y=Et({inputs:{x:E},backend:e,attrs:{shape:x}}),u.push(C),u.push(E)}if(a){u.push(y);const x=Ys(y.shape,h);y=Et({inputs:{x:y},backend:e,attrs:{shape:x}})}return u.forEach(x=>e.disposeIntermediateTensorInfo(x)),y}const Cat={kernelName:E1,backendName:"webgl",kernelFunc:Sat};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $at(n){const{inputs:t,backend:e,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:a}=t,{outputRaggedRank:o}=s,u=r.map(C=>e.readSync(C.dataId)),h=r.map(C=>C.shape),d=e.readSync(i.dataId),f=e.readSync(a.dataId),[m,y,x]=xJ(u,h,d,i.shape,i.dtype,f,a.shape,o),w=m.map(C=>e.makeTensorInfo([C.length],"int32",C)),S=e.makeTensorInfo(x,i.dtype,y);return w.concat([S])}const Tat={kernelName:tN,backendName:"webgl",kernelFunc:$at};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kat(n){const{inputs:t,backend:e}=n,{starts:s,limits:r,deltas:i}=t,a=e.readSync(s.dataId),o=e.readSync(r.dataId),u=e.readSync(i.dataId),[h,d]=bJ(a,s.shape,s.dtype,o,r.shape,u,i.shape),f=e.makeTensorInfo([h.length],"int32",h),m=e.makeTensorInfo([d.length],s.dtype,d);return[f,m]}const _at={kernelName:eN,backendName:"webgl",kernelFunc:kat};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nat(n){const{inputs:t,backend:e,attrs:s}=n,{shape:r,values:i,defaultValue:a,rowPartitionTensors:o}=t,{rowPartitionTypes:u}=s,h=e.readSync(r.dataId),d=e.readSync(i.dataId),f=e.readSync(a.dataId),m=o.map(S=>e.readSync(S.dataId)),y=o.map(S=>S.shape),[x,w]=vJ(h,r.shape,d,i.shape,i.dtype,f,a.shape,m,y,u);return e.makeTensorInfo(x,i.dtype,w)}const Eat={kernelName:nN,backendName:"webgl",kernelFunc:Nat};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A3=n=>{const{backend:t,attrs:e}=n,{start:s,stop:r,step:i,dtype:a}=e,o=wJ(s,r,i,a);return t.makeTensorInfo([o.length],a,o)},Rat={kernelName:R1,backendName:"webgl",kernelFunc:A3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iat="return 1.0 / x;",Aat=me({opSnippet:Iat}),Dat={kernelName:A1,backendName:"webgl",kernelFunc:Aat};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oat=Br+`
  return (x < 0.0) ? 0.0 : x;
`,Pat=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Fat=me({opSnippet:Oat,packedOpSnippet:Pat}),Lat={kernelName:D1,backendName:"webgl",kernelFunc:Fat};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mat=Br+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,zat=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Bat=me({opSnippet:Mat,packedOpSnippet:zat}),Vat={kernelName:L1,backendName:"webgl",kernelFunc:Bat};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uat{constructor(t,e,s,r,i){this.variableNames=["A"],this.outputShape=[];const[a,o,u,h]=t;this.outputShape=[a,e,s,h];const d=[r&&e>1?o-1:o,r&&s>1?u-1:u],f=[r&&e>1?e-1:e,r&&s>1?s-1:s];let m;i?m="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/f[0]},
          ${d[1]/f[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wat{constructor(t,e,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,o,u,h]=t;this.outputShape=[a,e,s,h];const d=[r&&e>1?o-1:o,r&&s>1?u-1:u],f=[r&&e>1?e-1:e,r&&s>1?s-1:s];let m;i?m="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/f[0]},
          ${d[1]/f[1]},
          ${d[1]/f[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${h-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gat(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:i,halfPixelCenters:a,size:o}=s,[u,h]=o,d=tt().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Wat(r.shape,u,h,i,a):new Uat(r.shape,u,h,i,a);return e.runWebGLProgram(d,[r],"float32")}const Hat={kernelName:F1,backendName:"webgl",kernelFunc:Gat};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jat{constructor(t,e,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,i]=e,[,a,o]=t,u=[s&&a>1?r-1:r,s&&o>1?i-1:i],h=[s&&a>1?a-1:a,s&&o>1?o-1:o],d=u[0]/h[0],f=u[1]/h[1],m=1/d,y=1/f,x=Math.ceil(m)*2+2,w=Math.ceil(y)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${f});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${y});

        const int winHeight = int(${x});
        const int winWidth = int(${w});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xat(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:i}=t,{alignCorners:a}=s,o=new jat(i.shape,r.shape,a);return e.runWebGLProgram(o,[i],i.dtype)}const qat={kernelName:rN,backendName:"webgl",kernelFunc:Xat};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kat{constructor(t,e,s,r,i){this.variableNames=["A"],this.outputShape=[];const[a,o,u,h]=t;this.outputShape=[a,e,s,h];const d=[r&&e>1?o-1:o,r&&s>1?u-1:u],f=[r&&e>1?e-1:e,r&&s>1?s-1:s],m=r?"0.5":"0.0";let y;i?y="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":y="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/f[0]},
          ${d[1]/f[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${y};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yat{constructor(t,e,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,o,u,h]=t;this.outputShape=[a,e,s,h];const d=[r&&e>1?o-1:o,r&&s>1?u-1:u],f=[r&&e>1?e-1:e,r&&s>1?s-1:s],m=r?"0.5":"0.0";let y;i?y="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":y="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/f[0]},
          ${d[1]/f[1]},
          ${d[1]/f[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${y};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${h-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qat(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:i,halfPixelCenters:a,size:o}=s,[u,h]=o,d=tt().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Yat(r.shape,u,h,i,a):new Kat(r.shape,u,h,i,a);return e.runWebGLProgram(d,[r],r.dtype)}const Zat={kernelName:P1,backendName:"webgl",kernelFunc:Qat};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jat{constructor(t,e,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,i]=e,[,a,o]=t,u=[s&&a>1?r-1:r,s&&o>1?i-1:i],h=[s&&a>1?a-1:a,s&&o>1?o-1:o],d=u[0]/h[0],f=u[1]/h[1],m=1/d,y=1/f,x=Math.ceil(m)*2+2,w=Math.ceil(y)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${f});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${y});

        const int winHeight = int(${x});
        const int winWidth = int(${w});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${h[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${h[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tot(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:i}=t,{alignCorners:a}=s,o=new Jat(i.shape,r.shape,a);return e.runWebGLProgram(o,[i],i.dtype)}const eot={kernelName:sN,backendName:"webgl",kernelFunc:tot};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class not{constructor(t,e){this.variableNames=["x"];const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=t,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}const r=o=>e.indexOf(o)!==-1&&t[o]!==1?`${t[o]} - coords[${o}] - 1`:`coords[${o}]`,i=t.map((o,u)=>r(u)).join(","),a=Fe(s);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sot{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=t;const r=hs("rc",s),i=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,a=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,o=Fe(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(r.slice())};
          if(${i}){
            result.g = ${h(r.slice())};
          }
          if(${a}) {
            result.b = ${d(r.slice())};
            if(${i}) {
              result.a = ${f(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(x){return m(x)}function h(x){return x[s-1]="("+x[s-1]+" + 1)",m(x)}function d(x){return x[s-2]="("+x[s-2]+" + 1)",m(x)}function f(x){return x[s-1]="("+x[s-1]+" + 1)",x[s-2]="("+x[s-2]+" + 1)",m(x)}function m(x){const w=t.map((k,E)=>y(E,x)),S=w.join(","),C=w.slice(-2).join(",");return`getChannel(getX(${S}), vec2(${C}))`}function y(x,w){return e.indexOf(x)!==-1&&t[x]!==1?`${t[x]} - ${w[x]} - 1`:`${w[x]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rot(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dims:i}=s,a=r.shape.length,o=Qe(i,r.shape);if(a===0)return qs({inputs:{x:r},backend:e});const u=tt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new sot(r.shape,o):new not(r.shape,o);return e.runWebGLProgram(u,[r],r.dtype)}const iot={kernelName:M1,backendName:"webgl",kernelFunc:rot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aot{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=t[1],r=t[2];this.outputShape=t;let i="";typeof e=="number"?i=`float outputValue = ${e.toFixed(2)};`:i=`
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oot={kernelName:xv,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:r,fillValue:i,center:a}=t,o=e,u=new aot(s.shape,i),[h,d]=qv(a,s.shape[1],s.shape[2]),f=[[h,d,Math.sin(r),Math.cos(r)]];return o.runWebGLProgram(u,[s],s.dtype,f)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lot=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,uot=me({opSnippet:lot}),cot={kernelName:z1,backendName:"webgl",kernelFunc:uot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hot="return inversesqrt(x);",dot=me({opSnippet:hot,cpuKernelImpl:SJ}),fot={kernelName:B1,backendName:"webgl",kernelFunc:dot};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dw{constructor(t,e,s,r,i,a,o=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const h=Fe(i.length),d=Fe(a.length);let f="";s===1?f="i":s===2&&(f="i, j");const m=`getIndices(${f})`;let y="";r===1?y="i":r===2&&(y="i, coords[1]");const x=`getUpdates(${y})`;let w="";u&&(w="coords[0], coords[1]");const S=`getDefaultValue(${w})`,C=e>1?"strides[j]":"strides";this.userCode=`
        ${h} strides = ${h}(${i});

        void main() {
          ${d} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${m});
              flattenedIndex += index * ${C};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${x};
              found = true;
            }
          }
          setOutput(mix(${S}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pot{constructor(t,e,s,r,i,a,o=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const h=Fe(i.length),d=Fe(a.length);let f="";s===1?f="i":s===2&&(f="i, j");const m=`getIndices(${f})`;let y="";r===1?y="i":r===2&&(y="i, coords[1]");const x=`getUpdates(${y})`;let w="";u&&(w="coords[0], coords[1]");const S=`getDefaultValue(${w})`,C=e>1?"strides[j]":"strides",k=e>1?"strides[j + 1]":"strides";this.userCode=`
        ${h} strides = ${h}(${i});

        void main() {
          ${d} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${t}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${e}; j+=2) {
              ivec4 index = round(${m});
              flattenedIndex += index.xz * ${C};
              if (j + 1 < ${e}) {
                flattenedIndex += index.yw * ${k};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${x};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${S}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mot(n){const{inputs:t,backend:e,attrs:s}=n,{indices:r,updates:i}=t,{shape:a}=s,{sliceRank:o,numUpdates:u,sliceSize:h,strides:d,outputSize:f}=$l(i,r,a),m=[f/h,h];if(f===0)return e.makeTensorInfo(a,r.dtype);const y=Et({inputs:{x:r},backend:e,attrs:{shape:[u,o]}}),x=Et({inputs:{x:i},backend:e,attrs:{shape:[u,h]}}),w=e.makeTensorInfo([],"float32",new Float32Array([0]));let S;tt().getBool("WEBGL_PACK")?S=new pot(u,o,y.shape.length,x.shape.length,d,m):S=new Dw(u,o,y.shape.length,x.shape.length,d,m);const C=e.runWebGLProgram(S,[x,y,w],x.dtype),k=Et({inputs:{x:C},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(C),e.disposeIntermediateTensorInfo(w),k}const got={kernelName:V1,backendName:"webgl",kernelFunc:mot};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yot{constructor(t,e,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,s];const i="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,o=tt().getNumber("WEBGL_VERSION")===2?i:a,u=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${o}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xot(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:r,values:i}=t,{side:a}=s,o=new yot(r.shape[0],r.shape[1],i.shape[1],a),u=[[r.shape[1]]];return e.runWebGLProgram(o,[r,i],"int32",u)}const bot={kernelName:W1,backendName:"webgl",kernelFunc:xot};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vot{constructor(t,e,s){this.variableNames=["c","a","b"],this.outputShape=e;let r,i;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)i="resRC",r="resRC";else{const o=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],h=[];for(let d=0;d<e.length;d++)h.push(`${o[d]}`),d<t&&u.push(`${o[d]}`);r=u.join(),i=h.join()}const a=Fe(s);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wot(n){const{inputs:t,backend:e}=n,{condition:s,t:r,e:i}=t,a=new vot(s.shape.length,r.shape,r.shape.length);return e.runWebGLProgram(a,[s,r,i],Ns(r.dtype,i.dtype))}const Sot={kernelName:G1,backendName:"webgl",kernelFunc:wot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cot=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${Qv};
  float scale = ${Zv};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,$ot=me({opSnippet:Cot}),Tot={kernelName:H1,backendName:"webgl",kernelFunc:$ot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kot=cc+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,_ot=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Not=me({opSnippet:kot,packedOpSnippet:_ot,cpuKernelImpl:$J}),Eot={kernelName:Y1,backendName:"webgl",kernelFunc:Not};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rot=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Iot=me({opSnippet:Rot}),Aot={kernelName:K1,backendName:"webgl",kernelFunc:Iot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dot=cc+`
  return sin(x);
`,Oot=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Al}
  return result;
`,Pot=me({opSnippet:Dot,packedOpSnippet:Oot}),Fot={kernelName:X1,backendName:"webgl",kernelFunc:Pot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lot=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Mot=me({opSnippet:Lot}),zot={kernelName:q1,backendName:"webgl",kernelFunc:Mot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bot=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Vot=me({opSnippet:Bot}),Uot={kernelName:Q1,backendName:"webgl",kernelFunc:Vot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wot=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:i,paddings:a}=s;M(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=i.reduce((C,k)=>C*k),u=[[0,0]];u.push(...a);for(let C=1+i.length;C<r.shape.length;++C)u.push([0,0]);const h=[],d=I3({inputs:{x:r},backend:e,attrs:{paddings:u,constantValue:0}}),f=Cd(d.shape,i,o,!1),m=$d(f.length,i.length,!1),y=Td(d.shape,i,o,!1),x=Et({inputs:{x:d},backend:e,attrs:{shape:f}}),w=fs({inputs:{x},backend:e,attrs:{perm:m}}),S=Et({inputs:{x:w},backend:e,attrs:{shape:y}});return h.push(d),h.push(x),h.push(w),h.forEach(C=>e.disposeIntermediateTensorInfo(C)),S},Got={kernelName:tv,backendName:"webgl",kernelFunc:Wot};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hot(n){const{inputs:t,backend:e}=n,{indices:s,values:r,denseShape:i,defaultValue:a}=t;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const o=e.readSync(s.dataId),u=e.readSync(r.dataId),h=e.readSync(i.dataId),d=e.readSync(a.dataId)[0],[f,m,y,x,w]=kJ(o,s.shape,s.dtype,u,r.dtype,h,d);return[e.makeTensorInfo(m,s.dtype,f),e.makeTensorInfo([m[0]],r.dtype,y),e.makeTensorInfo([x.length],"bool",new Uint8Array(x.map(S=>Number(S)))),e.makeTensorInfo([w.length],s.dtype,new Int32Array(w))]}const jot={kernelName:iN,backendName:"webgl",kernelFunc:Hot};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xot(n){const{inputs:t,backend:e}=n,{inputIndices:s,inputShape:r,newShape:i}=t;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const a=Array.from(e.readSync(r.dataId)),o=e.readSync(s.dataId),u=Array.from(e.readSync(i.dataId)),[h,d,f]=_J(o,s.shape,s.dtype,a,u);return[e.makeTensorInfo(d,s.dtype,h),e.makeTensorInfo([f.length],i.dtype,new Int32Array(f))]}const qot={kernelName:aN,backendName:"webgl",kernelFunc:Xot};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kot(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const a=e.readSync(s.dataId),o=e.readSync(r.dataId),u=e.readSync(i.dataId),[h,d]=n3(a,s.shape,s.dtype,o,u,!0);return e.makeTensorInfo(d,s.dtype,h)}const Yot={kernelName:sv,backendName:"webgl",kernelFunc:Kot};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qot(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const a=e.readSync(s.dataId),o=e.readSync(r.dataId),u=e.readSync(i.dataId),[h,d]=n3(a,s.shape,s.dtype,o,u);return e.makeTensorInfo(d,s.dtype,h)}const Zot={kernelName:rv,backendName:"webgl",kernelFunc:Qot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jot(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:a}=t,{outputShape:o}=s,{sliceRank:u,numUpdates:h,sliceSize:d,strides:f,outputSize:m}=$l(i,r,o),y=!1;if(i.dtype==="string"){const C=e.bufferSync(r),k=e.bufferSync(i),E=ea(e.readSync(a.dataId)[0]),R=CJ(C,k,o,m,d,h,u,f,E,y);return e.makeTensorInfo(o,R.dtype,R.values)}const x=new Dw(h,u,r.shape.length,i.shape.length,f,[m,1],y),w=e.runWebGLProgram(x,[i,r,a],i.dtype),S=Et({inputs:{x:w},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(w),S}const tlt={kernelName:iv,backendName:"webgl",kernelFunc:Jot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function elt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{numOrSizeSplits:i,axis:a}=s,o=Qe(a,r.shape)[0],u=cw(r,i,o),h=r.shape.length,d=new Array(h).fill(0),f=r.shape.slice();return u.map(m=>{const y=[...f];y[o]=m;const x=hc({inputs:{x:r},backend:e,attrs:{begin:d,size:y}});return d[o]+=m,x})}const nlt={kernelName:ev,backendName:"webgl",kernelFunc:elt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fk="return sqrt(x);",slt=me({opSnippet:fk,packedOpSnippet:fk,cpuKernelImpl:NJ}),rlt={kernelName:Z1,backendName:"webgl",kernelFunc:slt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ilt="return x * x;",alt=me({opSnippet:ilt}),olt={kernelName:oN,backendName:"webgl",kernelFunc:alt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pk="return (a - b) * (a - b);",llt=Vn({opSnippet:pk,packedOpSnippet:pk}),ult={kernelName:av,backendName:"webgl",kernelFunc:llt};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function clt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const i=e.readSync(r.dataId),a=no(i),o=EJ(a,"string",s);return e.makeTensorInfo(r.shape,"string",o)}const hlt={kernelName:lN,backendName:"webgl",kernelFunc:clt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dlt({inputs:n,attrs:t,backend:e}){const{x:s}=n,r=Br+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,i=new yi(s.shape,r);return e.runWebGLProgram(i,[s],s.dtype)}const flt={kernelName:yv,backendName:"webgl",kernelFunc:dlt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class plt{constructor(t,e,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,i=Fe(s.length),a=Fe(s.length);let o="";if(r===1)o="coords * strides + begin";else{let u=0;o=s.map((h,d)=>(u++,s.length===1?`coords * strides[${d}] + begin[${d}]`:`coords[${u-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${t});
      ${i} strides = ${i}(${e});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mlt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:i,end:a,strides:o,beginMask:u,endMask:h,ellipsisMask:d,newAxisMask:f,shrinkAxisMask:m}=s,{finalShapeSparse:y,finalShape:x,isIdentity:w,sliceDim0:S,isSimpleSlice:C,begin:k,end:E,strides:R}=Hv(r.shape,i,a,o,u,h,d,f,m);let A;if(w)A=Et({inputs:{x:r},backend:e,attrs:{shape:x}});else if(S||C){M(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const V=Vv(k,E,R),B=hc({inputs:{x:r},backend:e,attrs:{begin:k,size:V}});A=Et({inputs:{x:B},backend:e,attrs:{shape:x}}),e.disposeIntermediateTensorInfo(B)}else if(e.shouldExecuteOnCPU([r])){const B=e.readSync(r.dataId),z=Re(r.shape,r.dtype,B),U=RJ(y,z,R,k);A=e.makeTensorInfo(x,r.dtype,U.values)}else{const B=new plt(k,R,y);A=e.runWebGLProgram(B,[r],r.dtype)}const L=Et({inputs:{x:A},backend:e,attrs:{shape:x}});return e.disposeIntermediateTensorInfo(A),L}const glt={kernelName:ov,backendName:"webgl",kernelFunc:mlt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ylt(n){const{inputs:t,backend:e,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:a,rightPad:o,padWidth:u,preserveShortSequences:h}=s,{data:d,dataSplits:f}=t,m=e.readSync(d.dataId),y=e.readSync(f.dataId),[x,w]=IJ(m,y,r,i,a,o,u,h);return[e.makeTensorInfo([x.length],"string",x),e.makeTensorInfo(f.shape,"int32",w)]}const xlt={kernelName:lv,backendName:"webgl",kernelFunc:ylt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function blt(n){const{inputs:t,backend:e,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:a}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=e.readSync(i.dataId),u=e.readSync(a.dataId)[0],[h,d,f]=AJ(o,u,r),m=d.length;return[e.makeTensorInfo([m,2],"int32",h),e.makeTensorInfo([m],"string",d),e.makeTensorInfo([2],"int32",new Int32Array(f))]}const vlt={kernelName:uN,backendName:"webgl",kernelFunc:blt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wlt(n){const{inputs:t,backend:e,attrs:s}=n,{numBuckets:r}=s,{input:i}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=e.readSync(i.dataId),o=DJ(a,r);return e.makeTensorInfo(i.shape,"int32",o)}const Slt={kernelName:cN,backendName:"webgl",kernelFunc:wlt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Clt="return tan(x);",$lt=me({opSnippet:Clt}),Tlt={kernelName:cv,backendName:"webgl",kernelFunc:$lt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const klt=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,_lt=me({opSnippet:klt}),Nlt={kernelName:hv,backendName:"webgl",kernelFunc:_lt};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Elt(n){const{inputs:t,backend:e,attrs:s}=n,{tensor:r,indices:i,updates:a}=t,{sliceRank:o,numUpdates:u,sliceSize:h,strides:d,outputSize:f}=$l(a,i,r.shape),m=[f/h,h];if(f===0)return e.makeTensorInfo(r.shape,i.dtype);const y=Et({inputs:{x:i},backend:e,attrs:{shape:[u,o]}}),x=Et({inputs:{x:a},backend:e,attrs:{shape:[u,h]}}),w=Et({inputs:{x:r},backend:e,attrs:{shape:m}}),S=new Dw(u,o,y.shape.length,x.shape.length,d,m,!1,!0),C=e.runWebGLProgram(S,[x,y,w],w.dtype),k=Et({inputs:{x:C},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(C),k}const Rlt={kernelName:U1,backendName:"webgl",kernelFunc:Elt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ilt{constructor(t,e){this.variableNames=["A"];const s=new Array(t.length);for(let a=0;a<s.length;a++)s[a]=t[a]*e[a];this.outputShape=s,this.rank=s.length;const r=Fe(this.rank),i=Alt(t);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}}function Alt(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${e[r]}, ${n[r]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D3(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reps:i}=s;if(r.dtype==="string"||r.shape.length>5){const u=e.readSync(r.dataId),h=r.dtype==="string"?u.map(m=>ea(m)):u,d=Re(r.shape,r.dtype,h),f=PJ(d,i);return e.makeTensorInfo(f.shape,f.dtype,f.values)}const a=new Ilt(r.shape,i);return e.runWebGLProgram(a,[r],r.dtype)}const Dlt={kernelName:ym,backendName:"webgl",kernelFunc:D3};class Olt{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class Plt{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Go(n,t){t!==null&&n.disposeIntermediateTensorInfo(t)}function mk(n){let t=1;for(;t<n;)t*=2;return t}function Flt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{k:i,sorted:a}=s,o=tt().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=tt().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),h=r.shape,d=h[h.length-1];if(e.shouldExecuteOnCPU([r])||d<o||i>u){const U=e.readSync(r.dataId),[D,Y]=FJ(U,h,r.dtype,i,a);return[e.makeTensorInfo(D.shape,D.dtype,D.values),e.makeTensorInfo(Y.shape,Y.dtype,Y.values)]}if(i===0)return h[h.length-1]=0,[e.makeTensorInfo(h,r.dtype,[]),e.makeTensorInfo(h,"int32",[])];if(d===1)return[r,Rd({attrs:{shape:h,dtype:"int32",value:0},backend:e})];const f=e.texData.get(r.dataId),m=f!==null&&f.isPacked,y=m?e.unpackTensor(r):r,w=ht(h)/d,S=Et({inputs:{x:y},attrs:{shape:[w,d]},backend:e});m&&Go(e,y);const C=mk(i),k=mk(d);let E=null;const R=()=>E===null?[S,S]:[S,E],A=(U,D,Y)=>{const nt=R(),dt=new Olt(Y),K=[[d],[E===null?1:0],[Number.NEGATIVE_INFINITY],[U],[D]],ct=E;E=e.runWebGLProgram(dt,nt,"int32",K),Go(e,ct)};for(let U=1;U<C;U*=2){const D=U*2;for(let Y=U;Y>=1;Y/=2)A(D,Y,[w,k])}for(let U=k;U>C;U/=2){const D=R(),Y=new Plt([w,U/2]),dt=[[d],[E===null?1:0],[C]],at=E;E=e.runWebGLProgram(Y,D,"int32",dt),Go(e,at);const K=C/2,ct=K*2;for(let yt=K;yt>=1;yt/=2)A(ct,yt,E.shape)}let L=E;E=hc({inputs:{x:E},backend:e,attrs:{begin:0,size:[w,i]}}),Go(e,L);let V=T3({inputs:{x:S,indices:E},backend:e,attrs:{axis:1,batchDims:1}});Go(e,S);const B=h.slice(0,-1);B.push(i),L=E,E=Et({inputs:{x:E},attrs:{shape:B},backend:e}),Go(e,L);const z=V;return V=Et({inputs:{x:V},attrs:{shape:B},backend:e}),Go(e,z),[V,E]}const Llt={kernelName:dv,backendName:"webgl",kernelFunc:Flt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mlt{constructor(t,e,s,r,i,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const o=s==="nearest"?1:2;let u;switch(r){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${t}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zlt(n){const{inputs:t,backend:e,attrs:s}=n,{image:r,transforms:i}=t,{interpolation:a,fillMode:o,fillValue:u,outputShape:h}=s,[d,f,m,y]=r.shape,[x,w]=h??[f,m],S=[d,x,w,y],C=new Mlt(f,m,a,o,u,S);return e.runWebGLProgram(C,[r,i],"float32")}const Blt={kernelName:fv,backendName:"webgl",kernelFunc:zlt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vlt(n){const{inputs:t,attrs:e,backend:s}=n,{axis:r}=e,{x:i}=t;rc(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=s.readSync(i.dataId),{outputValues:o,outputShape:u,indices:h}=LJ(a,r,i.shape,i.dtype);return[s.makeTensorInfo(u,i.dtype,o),s.makeTensorInfo([h.length],"int32",h)]}const Ult={kernelName:hN,backendName:"webgl",kernelFunc:Vlt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wlt(n){const{inputs:t,backend:e,attrs:s}=n,{value:r}=t;let{axis:i}=s;i<0&&(i+=r.shape.length);const a=r,o=a.shape.length,u=r.shape[i],h=new Array(o-1);let d=0;for(let w=0;w<o;w++)w!==i&&(h[d++]=a.shape[w]);const f=[],m=new Array(o).fill(0),y=a.shape.slice();y[i]=1;const x=new Array(u);for(let w=0;w<x.length;w++){m[i]=w;const S=hc({inputs:{x:a},backend:e,attrs:{begin:m,size:y}}),C=Et({inputs:{x:S},backend:e,attrs:{shape:h}});x[w]=C,f.push(S)}return f.forEach(w=>e.disposeIntermediateTensorInfo(w)),x}const Glt={kernelName:pv,backendName:"webgl",kernelFunc:Wlt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hlt{constructor(t,e){this.variableNames=["x","segmentIds"];const s=t.windowSize,r=t.batchSize,i=t.inSize,a=t.numSegments,o=a*Math.ceil(i/s);this.outputShape=[r,o];const u="0.0",h="sumValue",d=Math.floor(s/4)*4,f=s%4,m=`
        sumValue += dot(values, segFilter);
    `;let y="";i%s>0&&(y=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let x="";i%s>0&&(x=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${y}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${x}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${d};
        if (${f===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${f===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${f===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${h});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jlt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,segmentIds:i}=t,{numSegments:a}=s,o=r.shape.length,u=[];let h=0;const d=ts([h],o);let f=r;d!=null&&(f=fs({inputs:{x:r},backend:e,attrs:{perm:d}}),u.push(f),h=es(1,o)[0]);const m=hw(f.shape,h,a),y=ht([f.shape[h]]),x=Et({inputs:{x:f},backend:e,attrs:{shape:[-1,y]}});u.push(x);const w=vm(r.dtype),S=(R,A,L,V,B)=>{const z=R.shape[0],U=R.shape[1],D=uR(U,B),Y={windowSize:D,inSize:U,batchSize:z,numSegments:B},nt=new Hlt(Y,A),dt=e.compileAndRun(nt,[R,L],V);if(u.push(dt),dt.shape[1]===B)return dt;const at=A3({backend:e,attrs:{start:0,stop:B,step:1,dtype:"float32"}}),K=D3({inputs:{x:at},backend:e,attrs:{reps:[U/D]}});return u.push(at),u.push(K),S(dt,A,K,V,B)},C=S(x,"unsortedSegmentSum",i,w,a),k=Et({inputs:{x:C},backend:e,attrs:{shape:m}});let E=k;if(d!=null){u.push(k);const R=Sd(d);E=fs({inputs:{x:E},backend:e,attrs:{perm:R}})}return u.forEach(R=>e.disposeIntermediateTensorInfo(R)),E}const Xlt={kernelName:mv,backendName:"webgl",kernelFunc:jlt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qlt=[Ett,Itt,Ott,Ltt,ztt,Utt,Gtt,jtt,Ytt,Ztt,eet,ret,oet,det,met,yet,bet,$et,ket,Net,Aet,zet,Vet,Het,Xet,Jet,ent,int,dtt,lnt,fnt,ynt,Cnt,knt,Nnt,Rnt,Ant,Fnt,znt,Unt,Gnt,jnt,qnt,Qnt,Jnt,sst,ist,lst,hst,fst,yst,wst,Tst,Nst,Ist,Ast,Ost,Fst,Mst,Bst,Ust,jst,Kst,Zst,trt,srt,art,crt,prt,htt,grt,hnt,brt,Srt,Trt,ptt,Ert,Drt,Prt,zrt,Urt,jrt,Krt,Jrt,sit,ait,lit,dit,pit,git,vit,Sit,$it,kit,Nit,Ait,Fit,Bit,qit,ytt,Zit,eat,rat,oat,Ket,cat,dat,pat,yat,wat,gtt,Cat,Tat,_at,Eat,Rat,Yet,Git,Dat,Lat,Vat,btt,Hat,qat,Zat,eot,iot,oot,cot,fot,got,bot,Sot,Tot,Eot,Aot,Fot,zot,Let,jit,Uot,Got,jot,qot,Yot,Zot,tlt,nlt,rlt,olt,ult,hlt,flt,glt,xlt,vlt,Slt,Hit,ktt,Tlt,Nlt,Rlt,Dlt,Llt,Blt,_tt,Ult,Glt,Xlt,hat];for(const n of qlt)dN(n);/*!
 * @kurkle/color v0.3.4
 * https://github.com/kurkle/color#readme
 * (c) 2024 Jukka Kurkela
 * Released under the MIT License
 */function Id(n){return n+.5|0}const ja=(n,t,e)=>Math.max(Math.min(n,e),t);function Ph(n){return ja(Id(n*2.55),0,255)}function Za(n){return ja(Id(n*255),0,255)}function Yi(n){return ja(Id(n/2.55)/100,0,1)}function gk(n){return ja(Id(n*100),0,100)}const Er={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15},N0=[..."0123456789ABCDEF"],Klt=n=>N0[n&15],Ylt=n=>N0[(n&240)>>4]+N0[n&15],rp=n=>(n&240)>>4===(n&15),Qlt=n=>rp(n.r)&&rp(n.g)&&rp(n.b)&&rp(n.a);function Zlt(n){var t=n.length,e;return n[0]==="#"&&(t===4||t===5?e={r:255&Er[n[1]]*17,g:255&Er[n[2]]*17,b:255&Er[n[3]]*17,a:t===5?Er[n[4]]*17:255}:(t===7||t===9)&&(e={r:Er[n[1]]<<4|Er[n[2]],g:Er[n[3]]<<4|Er[n[4]],b:Er[n[5]]<<4|Er[n[6]],a:t===9?Er[n[7]]<<4|Er[n[8]]:255})),e}const Jlt=(n,t)=>n<255?t(n):"";function tut(n){var t=Qlt(n)?Klt:Ylt;return n?"#"+t(n.r)+t(n.g)+t(n.b)+Jlt(n.a,t):void 0}const eut=/^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;function O3(n,t,e){const s=t*Math.min(e,1-e),r=(i,a=(i+n/30)%12)=>e-s*Math.max(Math.min(a-3,9-a,1),-1);return[r(0),r(8),r(4)]}function nut(n,t,e){const s=(r,i=(r+n/60)%6)=>e-e*t*Math.max(Math.min(i,4-i,1),0);return[s(5),s(3),s(1)]}function sut(n,t,e){const s=O3(n,1,.5);let r;for(t+e>1&&(r=1/(t+e),t*=r,e*=r),r=0;r<3;r++)s[r]*=1-t-e,s[r]+=t;return s}function rut(n,t,e,s,r){return n===r?(t-e)/s+(t<e?6:0):t===r?(e-n)/s+2:(n-t)/s+4}function Ow(n){const e=n.r/255,s=n.g/255,r=n.b/255,i=Math.max(e,s,r),a=Math.min(e,s,r),o=(i+a)/2;let u,h,d;return i!==a&&(d=i-a,h=o>.5?d/(2-i-a):d/(i+a),u=rut(e,s,r,d,i),u=u*60+.5),[u|0,h||0,o]}function Pw(n,t,e,s){return(Array.isArray(t)?n(t[0],t[1],t[2]):n(t,e,s)).map(Za)}function Fw(n,t,e){return Pw(O3,n,t,e)}function iut(n,t,e){return Pw(sut,n,t,e)}function aut(n,t,e){return Pw(nut,n,t,e)}function P3(n){return(n%360+360)%360}function out(n){const t=eut.exec(n);let e=255,s;if(!t)return;t[5]!==s&&(e=t[6]?Ph(+t[5]):Za(+t[5]));const r=P3(+t[2]),i=+t[3]/100,a=+t[4]/100;return t[1]==="hwb"?s=iut(r,i,a):t[1]==="hsv"?s=aut(r,i,a):s=Fw(r,i,a),{r:s[0],g:s[1],b:s[2],a:e}}function lut(n,t){var e=Ow(n);e[0]=P3(e[0]+t),e=Fw(e),n.r=e[0],n.g=e[1],n.b=e[2]}function uut(n){if(!n)return;const t=Ow(n),e=t[0],s=gk(t[1]),r=gk(t[2]);return n.a<255?`hsla(${e}, ${s}%, ${r}%, ${Yi(n.a)})`:`hsl(${e}, ${s}%, ${r}%)`}const yk={x:"dark",Z:"light",Y:"re",X:"blu",W:"gr",V:"medium",U:"slate",A:"ee",T:"ol",S:"or",B:"ra",C:"lateg",D:"ights",R:"in",Q:"turquois",E:"hi",P:"ro",O:"al",N:"le",M:"de",L:"yello",F:"en",K:"ch",G:"arks",H:"ea",I:"ightg",J:"wh"},xk={OiceXe:"f0f8ff",antiquewEte:"faebd7",aqua:"ffff",aquamarRe:"7fffd4",azuY:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"0",blanKedOmond:"ffebcd",Xe:"ff",XeviTet:"8a2be2",bPwn:"a52a2a",burlywood:"deb887",caMtXe:"5f9ea0",KartYuse:"7fff00",KocTate:"d2691e",cSO:"ff7f50",cSnflowerXe:"6495ed",cSnsilk:"fff8dc",crimson:"dc143c",cyan:"ffff",xXe:"8b",xcyan:"8b8b",xgTMnPd:"b8860b",xWay:"a9a9a9",xgYF:"6400",xgYy:"a9a9a9",xkhaki:"bdb76b",xmagFta:"8b008b",xTivegYF:"556b2f",xSange:"ff8c00",xScEd:"9932cc",xYd:"8b0000",xsOmon:"e9967a",xsHgYF:"8fbc8f",xUXe:"483d8b",xUWay:"2f4f4f",xUgYy:"2f4f4f",xQe:"ced1",xviTet:"9400d3",dAppRk:"ff1493",dApskyXe:"bfff",dimWay:"696969",dimgYy:"696969",dodgerXe:"1e90ff",fiYbrick:"b22222",flSOwEte:"fffaf0",foYstWAn:"228b22",fuKsia:"ff00ff",gaRsbSo:"dcdcdc",ghostwEte:"f8f8ff",gTd:"ffd700",gTMnPd:"daa520",Way:"808080",gYF:"8000",gYFLw:"adff2f",gYy:"808080",honeyMw:"f0fff0",hotpRk:"ff69b4",RdianYd:"cd5c5c",Rdigo:"4b0082",ivSy:"fffff0",khaki:"f0e68c",lavFMr:"e6e6fa",lavFMrXsh:"fff0f5",lawngYF:"7cfc00",NmoncEffon:"fffacd",ZXe:"add8e6",ZcSO:"f08080",Zcyan:"e0ffff",ZgTMnPdLw:"fafad2",ZWay:"d3d3d3",ZgYF:"90ee90",ZgYy:"d3d3d3",ZpRk:"ffb6c1",ZsOmon:"ffa07a",ZsHgYF:"20b2aa",ZskyXe:"87cefa",ZUWay:"778899",ZUgYy:"778899",ZstAlXe:"b0c4de",ZLw:"ffffe0",lime:"ff00",limegYF:"32cd32",lRF:"faf0e6",magFta:"ff00ff",maPon:"800000",VaquamarRe:"66cdaa",VXe:"cd",VScEd:"ba55d3",VpurpN:"9370db",VsHgYF:"3cb371",VUXe:"7b68ee",VsprRggYF:"fa9a",VQe:"48d1cc",VviTetYd:"c71585",midnightXe:"191970",mRtcYam:"f5fffa",mistyPse:"ffe4e1",moccasR:"ffe4b5",navajowEte:"ffdead",navy:"80",Tdlace:"fdf5e6",Tive:"808000",TivedBb:"6b8e23",Sange:"ffa500",SangeYd:"ff4500",ScEd:"da70d6",pOegTMnPd:"eee8aa",pOegYF:"98fb98",pOeQe:"afeeee",pOeviTetYd:"db7093",papayawEp:"ffefd5",pHKpuff:"ffdab9",peru:"cd853f",pRk:"ffc0cb",plum:"dda0dd",powMrXe:"b0e0e6",purpN:"800080",YbeccapurpN:"663399",Yd:"ff0000",Psybrown:"bc8f8f",PyOXe:"4169e1",saddNbPwn:"8b4513",sOmon:"fa8072",sandybPwn:"f4a460",sHgYF:"2e8b57",sHshell:"fff5ee",siFna:"a0522d",silver:"c0c0c0",skyXe:"87ceeb",UXe:"6a5acd",UWay:"708090",UgYy:"708090",snow:"fffafa",sprRggYF:"ff7f",stAlXe:"4682b4",tan:"d2b48c",teO:"8080",tEstN:"d8bfd8",tomato:"ff6347",Qe:"40e0d0",viTet:"ee82ee",JHt:"f5deb3",wEte:"ffffff",wEtesmoke:"f5f5f5",Lw:"ffff00",LwgYF:"9acd32"};function cut(){const n={},t=Object.keys(xk),e=Object.keys(yk);let s,r,i,a,o;for(s=0;s<t.length;s++){for(a=o=t[s],r=0;r<e.length;r++)i=e[r],o=o.replace(i,yk[i]);i=parseInt(xk[a],16),n[o]=[i>>16&255,i>>8&255,i&255]}return n}let ip;function hut(n){ip||(ip=cut(),ip.transparent=[0,0,0,0]);const t=ip[n.toLowerCase()];return t&&{r:t[0],g:t[1],b:t[2],a:t.length===4?t[3]:255}}const dut=/^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;function fut(n){const t=dut.exec(n);let e=255,s,r,i;if(t){if(t[7]!==s){const a=+t[7];e=t[8]?Ph(a):ja(a*255,0,255)}return s=+t[1],r=+t[3],i=+t[5],s=255&(t[2]?Ph(s):ja(s,0,255)),r=255&(t[4]?Ph(r):ja(r,0,255)),i=255&(t[6]?Ph(i):ja(i,0,255)),{r:s,g:r,b:i,a:e}}}function put(n){return n&&(n.a<255?`rgba(${n.r}, ${n.g}, ${n.b}, ${Yi(n.a)})`:`rgb(${n.r}, ${n.g}, ${n.b})`)}const kx=n=>n<=.0031308?n*12.92:Math.pow(n,1/2.4)*1.055-.055,Eu=n=>n<=.04045?n/12.92:Math.pow((n+.055)/1.055,2.4);function mut(n,t,e){const s=Eu(Yi(n.r)),r=Eu(Yi(n.g)),i=Eu(Yi(n.b));return{r:Za(kx(s+e*(Eu(Yi(t.r))-s))),g:Za(kx(r+e*(Eu(Yi(t.g))-r))),b:Za(kx(i+e*(Eu(Yi(t.b))-i))),a:n.a+e*(t.a-n.a)}}function ap(n,t,e){if(n){let s=Ow(n);s[t]=Math.max(0,Math.min(s[t]+s[t]*e,t===0?360:1)),s=Fw(s),n.r=s[0],n.g=s[1],n.b=s[2]}}function F3(n,t){return n&&Object.assign(t||{},n)}function bk(n){var t={r:0,g:0,b:0,a:255};return Array.isArray(n)?n.length>=3&&(t={r:n[0],g:n[1],b:n[2],a:255},n.length>3&&(t.a=Za(n[3]))):(t=F3(n,{r:0,g:0,b:0,a:1}),t.a=Za(t.a)),t}function gut(n){return n.charAt(0)==="r"?fut(n):out(n)}class fd{constructor(t){if(t instanceof fd)return t;const e=typeof t;let s;e==="object"?s=bk(t):e==="string"&&(s=Zlt(t)||hut(t)||gut(t)),this._rgb=s,this._valid=!!s}get valid(){return this._valid}get rgb(){var t=F3(this._rgb);return t&&(t.a=Yi(t.a)),t}set rgb(t){this._rgb=bk(t)}rgbString(){return this._valid?put(this._rgb):void 0}hexString(){return this._valid?tut(this._rgb):void 0}hslString(){return this._valid?uut(this._rgb):void 0}mix(t,e){if(t){const s=this.rgb,r=t.rgb;let i;const a=e===i?.5:e,o=2*a-1,u=s.a-r.a,h=((o*u===-1?o:(o+u)/(1+o*u))+1)/2;i=1-h,s.r=255&h*s.r+i*r.r+.5,s.g=255&h*s.g+i*r.g+.5,s.b=255&h*s.b+i*r.b+.5,s.a=a*s.a+(1-a)*r.a,this.rgb=s}return this}interpolate(t,e){return t&&(this._rgb=mut(this._rgb,t._rgb,e)),this}clone(){return new fd(this.rgb)}alpha(t){return this._rgb.a=Za(t),this}clearer(t){const e=this._rgb;return e.a*=1-t,this}greyscale(){const t=this._rgb,e=Id(t.r*.3+t.g*.59+t.b*.11);return t.r=t.g=t.b=e,this}opaquer(t){const e=this._rgb;return e.a*=1+t,this}negate(){const t=this._rgb;return t.r=255-t.r,t.g=255-t.g,t.b=255-t.b,this}lighten(t){return ap(this._rgb,2,t),this}darken(t){return ap(this._rgb,2,-t),this}saturate(t){return ap(this._rgb,1,t),this}desaturate(t){return ap(this._rgb,1,-t),this}rotate(t){return lut(this._rgb,t),this}}/*!
 * Chart.js v4.5.0
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */function Hi(){}const yut=(()=>{let n=0;return()=>n++})();function Ye(n){return n==null}function Zn(n){if(Array.isArray&&Array.isArray(n))return!0;const t=Object.prototype.toString.call(n);return t.slice(0,7)==="[object"&&t.slice(-6)==="Array]"}function Te(n){return n!==null&&Object.prototype.toString.call(n)==="[object Object]"}function Lr(n){return(typeof n=="number"||n instanceof Number)&&isFinite(+n)}function di(n,t){return Lr(n)?n:t}function xe(n,t){return typeof n>"u"?t:n}const xut=(n,t)=>typeof n=="string"&&n.endsWith("%")?parseFloat(n)/100*t:+n;function en(n,t,e){if(n&&typeof n.call=="function")return n.apply(e,t)}function Oe(n,t,e,s){let r,i,a;if(Zn(n))for(i=n.length,r=0;r<i;r++)t.call(e,n[r],r);else if(Te(n))for(a=Object.keys(n),i=a.length,r=0;r<i;r++)t.call(e,n[a[r]],a[r])}function am(n,t){let e,s,r,i;if(!n||!t||n.length!==t.length)return!1;for(e=0,s=n.length;e<s;++e)if(r=n[e],i=t[e],r.datasetIndex!==i.datasetIndex||r.index!==i.index)return!1;return!0}function om(n){if(Zn(n))return n.map(om);if(Te(n)){const t=Object.create(null),e=Object.keys(n),s=e.length;let r=0;for(;r<s;++r)t[e[r]]=om(n[e[r]]);return t}return n}function L3(n){return["__proto__","prototype","constructor"].indexOf(n)===-1}function but(n,t,e,s){if(!L3(n))return;const r=t[n],i=e[n];Te(r)&&Te(i)?pd(r,i,s):t[n]=om(i)}function pd(n,t,e){const s=Zn(t)?t:[t],r=s.length;if(!Te(n))return n;e=e||{};const i=e.merger||but;let a;for(let o=0;o<r;++o){if(a=s[o],!Te(a))continue;const u=Object.keys(a);for(let h=0,d=u.length;h<d;++h)i(u[h],n,a,e)}return n}function Wh(n,t){return pd(n,t,{merger:vut})}function vut(n,t,e){if(!L3(n))return;const s=t[n],r=e[n];Te(s)&&Te(r)?Wh(s,r):Object.prototype.hasOwnProperty.call(t,n)||(t[n]=om(r))}const vk={"":n=>n,x:n=>n.x,y:n=>n.y};function wut(n){const t=n.split("."),e=[];let s="";for(const r of t)s+=r,s.endsWith("\\")?s=s.slice(0,-1)+".":(e.push(s),s="");return e}function Sut(n){const t=wut(n);return e=>{for(const s of t){if(s==="")break;e=e&&e[s]}return e}}function lm(n,t){return(vk[t]||(vk[t]=Sut(t)))(n)}function Lw(n){return n.charAt(0).toUpperCase()+n.slice(1)}const um=n=>typeof n<"u",so=n=>typeof n=="function",wk=(n,t)=>{if(n.size!==t.size)return!1;for(const e of n)if(!t.has(e))return!1;return!0};function Cut(n){return n.type==="mouseup"||n.type==="click"||n.type==="contextmenu"}const ds=Math.PI,wi=2*ds,$ut=wi+ds,cm=Number.POSITIVE_INFINITY,Tut=ds/180,ti=ds/2,Ho=ds/4,Sk=ds*2/3,M3=Math.log10,Xu=Math.sign;function Gh(n,t,e){return Math.abs(n-t)<e}function Ck(n){const t=Math.round(n);n=Gh(n,t,n/1e3)?t:n;const e=Math.pow(10,Math.floor(M3(n))),s=n/e;return(s<=1?1:s<=2?2:s<=5?5:10)*e}function kut(n){const t=[],e=Math.sqrt(n);let s;for(s=1;s<e;s++)n%s===0&&(t.push(s),t.push(n/s));return e===(e|0)&&t.push(e),t.sort((r,i)=>r-i).pop(),t}function _ut(n){return typeof n=="symbol"||typeof n=="object"&&n!==null&&!(Symbol.toPrimitive in n||"toString"in n||"valueOf"in n)}function md(n){return!_ut(n)&&!isNaN(parseFloat(n))&&isFinite(n)}function Nut(n,t){const e=Math.round(n);return e-t<=n&&e+t>=n}function Eut(n,t,e){let s,r,i;for(s=0,r=n.length;s<r;s++)i=n[s][e],isNaN(i)||(t.min=Math.min(t.min,i),t.max=Math.max(t.max,i))}function al(n){return n*(ds/180)}function Rut(n){return n*(180/ds)}function $k(n){if(!Lr(n))return;let t=1,e=0;for(;Math.round(n*t)/t!==n;)t*=10,e++;return e}function Iut(n,t){const e=t.x-n.x,s=t.y-n.y,r=Math.sqrt(e*e+s*s);let i=Math.atan2(s,e);return i<-.5*ds&&(i+=wi),{angle:i,distance:r}}function E0(n,t){return Math.sqrt(Math.pow(t.x-n.x,2)+Math.pow(t.y-n.y,2))}function Aut(n,t){return(n-t+$ut)%wi-ds}function Va(n){return(n%wi+wi)%wi}function z3(n,t,e,s){const r=Va(n),i=Va(t),a=Va(e),o=Va(i-r),u=Va(a-r),h=Va(r-i),d=Va(r-a);return r===i||r===a||s&&i===a||o>u&&h<d}function Ar(n,t,e){return Math.max(t,Math.min(e,n))}function Dut(n){return Ar(n,-32768,32767)}function Fh(n,t,e,s=1e-6){return n>=Math.min(t,e)-s&&n<=Math.max(t,e)+s}function Mw(n,t,e){e=e||(a=>n[a]<t);let s=n.length-1,r=0,i;for(;s-r>1;)i=r+s>>1,e(i)?r=i:s=i;return{lo:r,hi:s}}const ol=(n,t,e,s)=>Mw(n,e,s?r=>{const i=n[r][t];return i<e||i===e&&n[r+1][t]===e}:r=>n[r][t]<e),Out=(n,t,e)=>Mw(n,e,s=>n[s][t]>=e);function Put(n,t,e){let s=0,r=n.length;for(;s<r&&n[s]<t;)s++;for(;r>s&&n[r-1]>e;)r--;return s>0||r<n.length?n.slice(s,r):n}const B3=["push","pop","shift","splice","unshift"];function Fut(n,t){if(n._chartjs){n._chartjs.listeners.push(t);return}Object.defineProperty(n,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[t]}}),B3.forEach(e=>{const s="_onData"+Lw(e),r=n[e];Object.defineProperty(n,e,{configurable:!0,enumerable:!1,value(...i){const a=r.apply(this,i);return n._chartjs.listeners.forEach(o=>{typeof o[s]=="function"&&o[s](...i)}),a}})})}function Tk(n,t){const e=n._chartjs;if(!e)return;const s=e.listeners,r=s.indexOf(t);r!==-1&&s.splice(r,1),!(s.length>0)&&(B3.forEach(i=>{delete n[i]}),delete n._chartjs)}function Lut(n){const t=new Set(n);return t.size===n.length?n:Array.from(t)}const V3=(function(){return typeof window>"u"?function(n){return n()}:window.requestAnimationFrame})();function U3(n,t){let e=[],s=!1;return function(...r){e=r,s||(s=!0,V3.call(window,()=>{s=!1,n.apply(t,e)}))}}function Mut(n,t){let e;return function(...s){return t?(clearTimeout(e),e=setTimeout(n,t,s)):n.apply(this,s),t}}const W3=n=>n==="start"?"left":n==="end"?"right":"center",lr=(n,t,e)=>n==="start"?t:n==="end"?e:(t+e)/2,zut=(n,t,e,s)=>n===(s?"left":"right")?e:n==="center"?(t+e)/2:t;function But(n,t,e){const s=t.length;let r=0,i=s;if(n._sorted){const{iScale:a,vScale:o,_parsed:u}=n,h=n.dataset&&n.dataset.options?n.dataset.options.spanGaps:null,d=a.axis,{min:f,max:m,minDefined:y,maxDefined:x}=a.getUserBounds();if(y){if(r=Math.min(ol(u,d,f).lo,e?s:ol(t,d,a.getPixelForValue(f)).lo),h){const w=u.slice(0,r+1).reverse().findIndex(S=>!Ye(S[o.axis]));r-=Math.max(0,w)}r=Ar(r,0,s-1)}if(x){let w=Math.max(ol(u,a.axis,m,!0).hi+1,e?0:ol(t,d,a.getPixelForValue(m),!0).hi+1);if(h){const S=u.slice(w-1).findIndex(C=>!Ye(C[o.axis]));w+=Math.max(0,S)}i=Ar(w,r,s)-r}else i=s-r}return{start:r,count:i}}function Vut(n){const{xScale:t,yScale:e,_scaleRanges:s}=n,r={xmin:t.min,xmax:t.max,ymin:e.min,ymax:e.max};if(!s)return n._scaleRanges=r,!0;const i=s.xmin!==t.min||s.xmax!==t.max||s.ymin!==e.min||s.ymax!==e.max;return Object.assign(s,r),i}const op=n=>n===0||n===1,kk=(n,t,e)=>-(Math.pow(2,10*(n-=1))*Math.sin((n-t)*wi/e)),_k=(n,t,e)=>Math.pow(2,-10*n)*Math.sin((n-t)*wi/e)+1,Hh={linear:n=>n,easeInQuad:n=>n*n,easeOutQuad:n=>-n*(n-2),easeInOutQuad:n=>(n/=.5)<1?.5*n*n:-.5*(--n*(n-2)-1),easeInCubic:n=>n*n*n,easeOutCubic:n=>(n-=1)*n*n+1,easeInOutCubic:n=>(n/=.5)<1?.5*n*n*n:.5*((n-=2)*n*n+2),easeInQuart:n=>n*n*n*n,easeOutQuart:n=>-((n-=1)*n*n*n-1),easeInOutQuart:n=>(n/=.5)<1?.5*n*n*n*n:-.5*((n-=2)*n*n*n-2),easeInQuint:n=>n*n*n*n*n,easeOutQuint:n=>(n-=1)*n*n*n*n+1,easeInOutQuint:n=>(n/=.5)<1?.5*n*n*n*n*n:.5*((n-=2)*n*n*n*n+2),easeInSine:n=>-Math.cos(n*ti)+1,easeOutSine:n=>Math.sin(n*ti),easeInOutSine:n=>-.5*(Math.cos(ds*n)-1),easeInExpo:n=>n===0?0:Math.pow(2,10*(n-1)),easeOutExpo:n=>n===1?1:-Math.pow(2,-10*n)+1,easeInOutExpo:n=>op(n)?n:n<.5?.5*Math.pow(2,10*(n*2-1)):.5*(-Math.pow(2,-10*(n*2-1))+2),easeInCirc:n=>n>=1?n:-(Math.sqrt(1-n*n)-1),easeOutCirc:n=>Math.sqrt(1-(n-=1)*n),easeInOutCirc:n=>(n/=.5)<1?-.5*(Math.sqrt(1-n*n)-1):.5*(Math.sqrt(1-(n-=2)*n)+1),easeInElastic:n=>op(n)?n:kk(n,.075,.3),easeOutElastic:n=>op(n)?n:_k(n,.075,.3),easeInOutElastic(n){return op(n)?n:n<.5?.5*kk(n*2,.1125,.45):.5+.5*_k(n*2-1,.1125,.45)},easeInBack(n){return n*n*((1.70158+1)*n-1.70158)},easeOutBack(n){return(n-=1)*n*((1.70158+1)*n+1.70158)+1},easeInOutBack(n){let t=1.70158;return(n/=.5)<1?.5*(n*n*(((t*=1.525)+1)*n-t)):.5*((n-=2)*n*(((t*=1.525)+1)*n+t)+2)},easeInBounce:n=>1-Hh.easeOutBounce(1-n),easeOutBounce(n){return n<1/2.75?7.5625*n*n:n<2/2.75?7.5625*(n-=1.5/2.75)*n+.75:n<2.5/2.75?7.5625*(n-=2.25/2.75)*n+.9375:7.5625*(n-=2.625/2.75)*n+.984375},easeInOutBounce:n=>n<.5?Hh.easeInBounce(n*2)*.5:Hh.easeOutBounce(n*2-1)*.5+.5};function zw(n){if(n&&typeof n=="object"){const t=n.toString();return t==="[object CanvasPattern]"||t==="[object CanvasGradient]"}return!1}function Nk(n){return zw(n)?n:new fd(n)}function _x(n){return zw(n)?n:new fd(n).saturate(.5).darken(.1).hexString()}const Uut=["x","y","borderWidth","radius","tension"],Wut=["color","borderColor","backgroundColor"];function Gut(n){n.set("animation",{delay:void 0,duration:1e3,easing:"easeOutQuart",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0}),n.describe("animation",{_fallback:!1,_indexable:!1,_scriptable:t=>t!=="onProgress"&&t!=="onComplete"&&t!=="fn"}),n.set("animations",{colors:{type:"color",properties:Wut},numbers:{type:"number",properties:Uut}}),n.describe("animations",{_fallback:"animation"}),n.set("transitions",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:"transparent"},visible:{type:"boolean",duration:0}}},hide:{animations:{colors:{to:"transparent"},visible:{type:"boolean",easing:"linear",fn:t=>t|0}}}})}function Hut(n){n.set("layout",{autoPadding:!0,padding:{top:0,right:0,bottom:0,left:0}})}const Ek=new Map;function jut(n,t){t=t||{};const e=n+JSON.stringify(t);let s=Ek.get(e);return s||(s=new Intl.NumberFormat(n,t),Ek.set(e,s)),s}function G3(n,t,e){return jut(t,e).format(n)}const Xut={values(n){return Zn(n)?n:""+n},numeric(n,t,e){if(n===0)return"0";const s=this.chart.options.locale;let r,i=n;if(e.length>1){const h=Math.max(Math.abs(e[0].value),Math.abs(e[e.length-1].value));(h<1e-4||h>1e15)&&(r="scientific"),i=qut(n,e)}const a=M3(Math.abs(i)),o=isNaN(a)?1:Math.max(Math.min(-1*Math.floor(a),20),0),u={notation:r,minimumFractionDigits:o,maximumFractionDigits:o};return Object.assign(u,this.options.ticks.format),G3(n,s,u)}};function qut(n,t){let e=t.length>3?t[2].value-t[1].value:t[1].value-t[0].value;return Math.abs(e)>=1&&n!==Math.floor(n)&&(e=n-Math.floor(n)),e}var H3={formatters:Xut};function Kut(n){n.set("scale",{display:!0,offset:!1,reverse:!1,beginAtZero:!1,bounds:"ticks",clip:!0,grace:0,grid:{display:!0,lineWidth:1,drawOnChartArea:!0,drawTicks:!0,tickLength:8,tickWidth:(t,e)=>e.lineWidth,tickColor:(t,e)=>e.color,offset:!1},border:{display:!0,dash:[],dashOffset:0,width:1},title:{display:!1,text:"",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:!1,textStrokeWidth:0,textStrokeColor:"",padding:3,display:!0,autoSkip:!0,autoSkipPadding:3,labelOffset:0,callback:H3.formatters.values,minor:{},major:{},align:"center",crossAlign:"near",showLabelBackdrop:!1,backdropColor:"rgba(255, 255, 255, 0.75)",backdropPadding:2}}),n.route("scale.ticks","color","","color"),n.route("scale.grid","color","","borderColor"),n.route("scale.border","color","","borderColor"),n.route("scale.title","color","","color"),n.describe("scale",{_fallback:!1,_scriptable:t=>!t.startsWith("before")&&!t.startsWith("after")&&t!=="callback"&&t!=="parser",_indexable:t=>t!=="borderDash"&&t!=="tickBorderDash"&&t!=="dash"}),n.describe("scales",{_fallback:"scale"}),n.describe("scale.ticks",{_scriptable:t=>t!=="backdropPadding"&&t!=="callback",_indexable:t=>t!=="backdropPadding"})}const Cl=Object.create(null),R0=Object.create(null);function jh(n,t){if(!t)return n;const e=t.split(".");for(let s=0,r=e.length;s<r;++s){const i=e[s];n=n[i]||(n[i]=Object.create(null))}return n}function Nx(n,t,e){return typeof t=="string"?pd(jh(n,t),e):pd(jh(n,""),t)}class Yut{constructor(t,e){this.animation=void 0,this.backgroundColor="rgba(0,0,0,0.1)",this.borderColor="rgba(0,0,0,0.1)",this.color="#666",this.datasets={},this.devicePixelRatio=s=>s.chart.platform.getDevicePixelRatio(),this.elements={},this.events=["mousemove","mouseout","click","touchstart","touchmove"],this.font={family:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",size:12,style:"normal",lineHeight:1.2,weight:null},this.hover={},this.hoverBackgroundColor=(s,r)=>_x(r.backgroundColor),this.hoverBorderColor=(s,r)=>_x(r.borderColor),this.hoverColor=(s,r)=>_x(r.color),this.indexAxis="x",this.interaction={mode:"nearest",intersect:!0,includeInvisible:!1},this.maintainAspectRatio=!0,this.onHover=null,this.onClick=null,this.parsing=!0,this.plugins={},this.responsive=!0,this.scale=void 0,this.scales={},this.showLine=!0,this.drawActiveElementsOnTop=!0,this.describe(t),this.apply(e)}set(t,e){return Nx(this,t,e)}get(t){return jh(this,t)}describe(t,e){return Nx(R0,t,e)}override(t,e){return Nx(Cl,t,e)}route(t,e,s,r){const i=jh(this,t),a=jh(this,s),o="_"+e;Object.defineProperties(i,{[o]:{value:i[e],writable:!0},[e]:{enumerable:!0,get(){const u=this[o],h=a[r];return Te(u)?Object.assign({},h,u):xe(u,h)},set(u){this[o]=u}}})}apply(t){t.forEach(e=>e(this))}}var bn=new Yut({_scriptable:n=>!n.startsWith("on"),_indexable:n=>n!=="events",hover:{_fallback:"interaction"},interaction:{_scriptable:!1,_indexable:!1}},[Gut,Hut,Kut]);function Qut(n){return!n||Ye(n.size)||Ye(n.family)?null:(n.style?n.style+" ":"")+(n.weight?n.weight+" ":"")+n.size+"px "+n.family}function Rk(n,t,e,s,r){let i=t[r];return i||(i=t[r]=n.measureText(r).width,e.push(r)),i>s&&(s=i),s}function jo(n,t,e){const s=n.currentDevicePixelRatio,r=e!==0?Math.max(e/2,.5):0;return Math.round((t-r)*s)/s+r}function Ik(n,t){!t&&!n||(t=t||n.getContext("2d"),t.save(),t.resetTransform(),t.clearRect(0,0,n.width,n.height),t.restore())}function I0(n,t,e,s){j3(n,t,e,s,null)}function j3(n,t,e,s,r){let i,a,o,u,h,d,f,m;const y=t.pointStyle,x=t.rotation,w=t.radius;let S=(x||0)*Tut;if(y&&typeof y=="object"&&(i=y.toString(),i==="[object HTMLImageElement]"||i==="[object HTMLCanvasElement]")){n.save(),n.translate(e,s),n.rotate(S),n.drawImage(y,-y.width/2,-y.height/2,y.width,y.height),n.restore();return}if(!(isNaN(w)||w<=0)){switch(n.beginPath(),y){default:r?n.ellipse(e,s,r/2,w,0,0,wi):n.arc(e,s,w,0,wi),n.closePath();break;case"triangle":d=r?r/2:w,n.moveTo(e+Math.sin(S)*d,s-Math.cos(S)*w),S+=Sk,n.lineTo(e+Math.sin(S)*d,s-Math.cos(S)*w),S+=Sk,n.lineTo(e+Math.sin(S)*d,s-Math.cos(S)*w),n.closePath();break;case"rectRounded":h=w*.516,u=w-h,a=Math.cos(S+Ho)*u,f=Math.cos(S+Ho)*(r?r/2-h:u),o=Math.sin(S+Ho)*u,m=Math.sin(S+Ho)*(r?r/2-h:u),n.arc(e-f,s-o,h,S-ds,S-ti),n.arc(e+m,s-a,h,S-ti,S),n.arc(e+f,s+o,h,S,S+ti),n.arc(e-m,s+a,h,S+ti,S+ds),n.closePath();break;case"rect":if(!x){u=Math.SQRT1_2*w,d=r?r/2:u,n.rect(e-d,s-u,2*d,2*u);break}S+=Ho;case"rectRot":f=Math.cos(S)*(r?r/2:w),a=Math.cos(S)*w,o=Math.sin(S)*w,m=Math.sin(S)*(r?r/2:w),n.moveTo(e-f,s-o),n.lineTo(e+m,s-a),n.lineTo(e+f,s+o),n.lineTo(e-m,s+a),n.closePath();break;case"crossRot":S+=Ho;case"cross":f=Math.cos(S)*(r?r/2:w),a=Math.cos(S)*w,o=Math.sin(S)*w,m=Math.sin(S)*(r?r/2:w),n.moveTo(e-f,s-o),n.lineTo(e+f,s+o),n.moveTo(e+m,s-a),n.lineTo(e-m,s+a);break;case"star":f=Math.cos(S)*(r?r/2:w),a=Math.cos(S)*w,o=Math.sin(S)*w,m=Math.sin(S)*(r?r/2:w),n.moveTo(e-f,s-o),n.lineTo(e+f,s+o),n.moveTo(e+m,s-a),n.lineTo(e-m,s+a),S+=Ho,f=Math.cos(S)*(r?r/2:w),a=Math.cos(S)*w,o=Math.sin(S)*w,m=Math.sin(S)*(r?r/2:w),n.moveTo(e-f,s-o),n.lineTo(e+f,s+o),n.moveTo(e+m,s-a),n.lineTo(e-m,s+a);break;case"line":a=r?r/2:Math.cos(S)*w,o=Math.sin(S)*w,n.moveTo(e-a,s-o),n.lineTo(e+a,s+o);break;case"dash":n.moveTo(e,s),n.lineTo(e+Math.cos(S)*(r?r/2:w),s+Math.sin(S)*w);break;case!1:n.closePath();break}n.fill(),t.borderWidth>0&&n.stroke()}}function gd(n,t,e){return e=e||.5,!t||n&&n.x>t.left-e&&n.x<t.right+e&&n.y>t.top-e&&n.y<t.bottom+e}function Bw(n,t){n.save(),n.beginPath(),n.rect(t.left,t.top,t.right-t.left,t.bottom-t.top),n.clip()}function Vw(n){n.restore()}function Zut(n,t,e,s,r){if(!t)return n.lineTo(e.x,e.y);if(r==="middle"){const i=(t.x+e.x)/2;n.lineTo(i,t.y),n.lineTo(i,e.y)}else r==="after"!=!!s?n.lineTo(t.x,e.y):n.lineTo(e.x,t.y);n.lineTo(e.x,e.y)}function Jut(n,t,e,s){if(!t)return n.lineTo(e.x,e.y);n.bezierCurveTo(s?t.cp1x:t.cp2x,s?t.cp1y:t.cp2y,s?e.cp2x:e.cp1x,s?e.cp2y:e.cp1y,e.x,e.y)}function tct(n,t){t.translation&&n.translate(t.translation[0],t.translation[1]),Ye(t.rotation)||n.rotate(t.rotation),t.color&&(n.fillStyle=t.color),t.textAlign&&(n.textAlign=t.textAlign),t.textBaseline&&(n.textBaseline=t.textBaseline)}function ect(n,t,e,s,r){if(r.strikethrough||r.underline){const i=n.measureText(s),a=t-i.actualBoundingBoxLeft,o=t+i.actualBoundingBoxRight,u=e-i.actualBoundingBoxAscent,h=e+i.actualBoundingBoxDescent,d=r.strikethrough?(u+h)/2:h;n.strokeStyle=n.fillStyle,n.beginPath(),n.lineWidth=r.decorationWidth||2,n.moveTo(a,d),n.lineTo(o,d),n.stroke()}}function nct(n,t){const e=n.fillStyle;n.fillStyle=t.color,n.fillRect(t.left,t.top,t.width,t.height),n.fillStyle=e}function hm(n,t,e,s,r,i={}){const a=Zn(t)?t:[t],o=i.strokeWidth>0&&i.strokeColor!=="";let u,h;for(n.save(),n.font=r.string,tct(n,i),u=0;u<a.length;++u)h=a[u],i.backdrop&&nct(n,i.backdrop),o&&(i.strokeColor&&(n.strokeStyle=i.strokeColor),Ye(i.strokeWidth)||(n.lineWidth=i.strokeWidth),n.strokeText(h,e,s,i.maxWidth)),n.fillText(h,e,s,i.maxWidth),ect(n,e,s,h,i),s+=Number(r.lineHeight);n.restore()}function A0(n,t){const{x:e,y:s,w:r,h:i,radius:a}=t;n.arc(e+a.topLeft,s+a.topLeft,a.topLeft,1.5*ds,ds,!0),n.lineTo(e,s+i-a.bottomLeft),n.arc(e+a.bottomLeft,s+i-a.bottomLeft,a.bottomLeft,ds,ti,!0),n.lineTo(e+r-a.bottomRight,s+i),n.arc(e+r-a.bottomRight,s+i-a.bottomRight,a.bottomRight,ti,0,!0),n.lineTo(e+r,s+a.topRight),n.arc(e+r-a.topRight,s+a.topRight,a.topRight,0,-ti,!0),n.lineTo(e+a.topLeft,s)}const sct=/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,rct=/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;function ict(n,t){const e=(""+n).match(sct);if(!e||e[1]==="normal")return t*1.2;switch(n=+e[2],e[3]){case"px":return n;case"%":n/=100;break}return t*n}const act=n=>+n||0;function X3(n,t){const e={},s=Te(t),r=s?Object.keys(t):t,i=Te(n)?s?a=>xe(n[a],n[t[a]]):a=>n[a]:()=>n;for(const a of r)e[a]=act(i(a));return e}function oct(n){return X3(n,{top:"y",right:"x",bottom:"y",left:"x"})}function Xh(n){return X3(n,["topLeft","topRight","bottomLeft","bottomRight"])}function ni(n){const t=oct(n);return t.width=t.left+t.right,t.height=t.top+t.bottom,t}function js(n,t){n=n||{},t=t||bn.font;let e=xe(n.size,t.size);typeof e=="string"&&(e=parseInt(e,10));let s=xe(n.style,t.style);s&&!(""+s).match(rct)&&(console.warn('Invalid font style specified: "'+s+'"'),s=void 0);const r={family:xe(n.family,t.family),lineHeight:ict(xe(n.lineHeight,t.lineHeight),e),size:e,style:s,weight:xe(n.weight,t.weight),string:""};return r.string=Qut(r),r}function lp(n,t,e,s){let r,i,a;for(r=0,i=n.length;r<i;++r)if(a=n[r],a!==void 0&&a!==void 0)return a}function lct(n,t,e){const{min:s,max:r}=n,i=xut(t,(r-s)/2),a=(o,u)=>e&&o===0?0:o+u;return{min:a(s,-Math.abs(i)),max:a(r,i)}}function Ol(n,t){return Object.assign(Object.create(n),t)}function Uw(n,t=[""],e,s,r=()=>n[0]){const i=e||n;typeof s>"u"&&(s=Q3("_fallback",n));const a={[Symbol.toStringTag]:"Object",_cacheable:!0,_scopes:n,_rootScopes:i,_fallback:s,_getTarget:r,override:o=>Uw([o,...n],t,i,s)};return new Proxy(a,{deleteProperty(o,u){return delete o[u],delete o._keys,delete n[0][u],!0},get(o,u){return K3(o,u,()=>gct(u,t,n,o))},getOwnPropertyDescriptor(o,u){return Reflect.getOwnPropertyDescriptor(o._scopes[0],u)},getPrototypeOf(){return Reflect.getPrototypeOf(n[0])},has(o,u){return Dk(o).includes(u)},ownKeys(o){return Dk(o)},set(o,u,h){const d=o._storage||(o._storage=r());return o[u]=d[u]=h,delete o._keys,!0}})}function qu(n,t,e,s){const r={_cacheable:!1,_proxy:n,_context:t,_subProxy:e,_stack:new Set,_descriptors:q3(n,s),setContext:i=>qu(n,i,e,s),override:i=>qu(n.override(i),t,e,s)};return new Proxy(r,{deleteProperty(i,a){return delete i[a],delete n[a],!0},get(i,a,o){return K3(i,a,()=>cct(i,a,o))},getOwnPropertyDescriptor(i,a){return i._descriptors.allKeys?Reflect.has(n,a)?{enumerable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(n,a)},getPrototypeOf(){return Reflect.getPrototypeOf(n)},has(i,a){return Reflect.has(n,a)},ownKeys(){return Reflect.ownKeys(n)},set(i,a,o){return n[a]=o,delete i[a],!0}})}function q3(n,t={scriptable:!0,indexable:!0}){const{_scriptable:e=t.scriptable,_indexable:s=t.indexable,_allKeys:r=t.allKeys}=n;return{allKeys:r,scriptable:e,indexable:s,isScriptable:so(e)?e:()=>e,isIndexable:so(s)?s:()=>s}}const uct=(n,t)=>n?n+Lw(t):t,Ww=(n,t)=>Te(t)&&n!=="adapters"&&(Object.getPrototypeOf(t)===null||t.constructor===Object);function K3(n,t,e){if(Object.prototype.hasOwnProperty.call(n,t)||t==="constructor")return n[t];const s=e();return n[t]=s,s}function cct(n,t,e){const{_proxy:s,_context:r,_subProxy:i,_descriptors:a}=n;let o=s[t];return so(o)&&a.isScriptable(t)&&(o=hct(t,o,n,e)),Zn(o)&&o.length&&(o=dct(t,o,n,a.isIndexable)),Ww(t,o)&&(o=qu(o,r,i&&i[t],a)),o}function hct(n,t,e,s){const{_proxy:r,_context:i,_subProxy:a,_stack:o}=e;if(o.has(n))throw new Error("Recursion detected: "+Array.from(o).join("->")+"->"+n);o.add(n);let u=t(i,a||s);return o.delete(n),Ww(n,u)&&(u=Gw(r._scopes,r,n,u)),u}function dct(n,t,e,s){const{_proxy:r,_context:i,_subProxy:a,_descriptors:o}=e;if(typeof i.index<"u"&&s(n))return t[i.index%t.length];if(Te(t[0])){const u=t,h=r._scopes.filter(d=>d!==u);t=[];for(const d of u){const f=Gw(h,r,n,d);t.push(qu(f,i,a&&a[n],o))}}return t}function Y3(n,t,e){return so(n)?n(t,e):n}const fct=(n,t)=>n===!0?t:typeof n=="string"?lm(t,n):void 0;function pct(n,t,e,s,r){for(const i of t){const a=fct(e,i);if(a){n.add(a);const o=Y3(a._fallback,e,r);if(typeof o<"u"&&o!==e&&o!==s)return o}else if(a===!1&&typeof s<"u"&&e!==s)return null}return!1}function Gw(n,t,e,s){const r=t._rootScopes,i=Y3(t._fallback,e,s),a=[...n,...r],o=new Set;o.add(s);let u=Ak(o,a,e,i||e,s);return u===null||typeof i<"u"&&i!==e&&(u=Ak(o,a,i,u,s),u===null)?!1:Uw(Array.from(o),[""],r,i,()=>mct(t,e,s))}function Ak(n,t,e,s,r){for(;e;)e=pct(n,t,e,s,r);return e}function mct(n,t,e){const s=n._getTarget();t in s||(s[t]={});const r=s[t];return Zn(r)&&Te(e)?e:r||{}}function gct(n,t,e,s){let r;for(const i of t)if(r=Q3(uct(i,n),e),typeof r<"u")return Ww(n,r)?Gw(e,s,n,r):r}function Q3(n,t){for(const e of t){if(!e)continue;const s=e[n];if(typeof s<"u")return s}}function Dk(n){let t=n._keys;return t||(t=n._keys=yct(n._scopes)),t}function yct(n){const t=new Set;for(const e of n)for(const s of Object.keys(e).filter(r=>!r.startsWith("_")))t.add(s);return Array.from(t)}const xct=Number.EPSILON||1e-14,Ku=(n,t)=>t<n.length&&!n[t].skip&&n[t],Z3=n=>n==="x"?"y":"x";function bct(n,t,e,s){const r=n.skip?t:n,i=t,a=e.skip?t:e,o=E0(i,r),u=E0(a,i);let h=o/(o+u),d=u/(o+u);h=isNaN(h)?0:h,d=isNaN(d)?0:d;const f=s*h,m=s*d;return{previous:{x:i.x-f*(a.x-r.x),y:i.y-f*(a.y-r.y)},next:{x:i.x+m*(a.x-r.x),y:i.y+m*(a.y-r.y)}}}function vct(n,t,e){const s=n.length;let r,i,a,o,u,h=Ku(n,0);for(let d=0;d<s-1;++d)if(u=h,h=Ku(n,d+1),!(!u||!h)){if(Gh(t[d],0,xct)){e[d]=e[d+1]=0;continue}r=e[d]/t[d],i=e[d+1]/t[d],o=Math.pow(r,2)+Math.pow(i,2),!(o<=9)&&(a=3/Math.sqrt(o),e[d]=r*a*t[d],e[d+1]=i*a*t[d])}}function wct(n,t,e="x"){const s=Z3(e),r=n.length;let i,a,o,u=Ku(n,0);for(let h=0;h<r;++h){if(a=o,o=u,u=Ku(n,h+1),!o)continue;const d=o[e],f=o[s];a&&(i=(d-a[e])/3,o[`cp1${e}`]=d-i,o[`cp1${s}`]=f-i*t[h]),u&&(i=(u[e]-d)/3,o[`cp2${e}`]=d+i,o[`cp2${s}`]=f+i*t[h])}}function Sct(n,t="x"){const e=Z3(t),s=n.length,r=Array(s).fill(0),i=Array(s);let a,o,u,h=Ku(n,0);for(a=0;a<s;++a)if(o=u,u=h,h=Ku(n,a+1),!!u){if(h){const d=h[t]-u[t];r[a]=d!==0?(h[e]-u[e])/d:0}i[a]=o?h?Xu(r[a-1])!==Xu(r[a])?0:(r[a-1]+r[a])/2:r[a-1]:r[a]}vct(n,r,i),wct(n,i,t)}function up(n,t,e){return Math.max(Math.min(n,e),t)}function Cct(n,t){let e,s,r,i,a,o=gd(n[0],t);for(e=0,s=n.length;e<s;++e)a=i,i=o,o=e<s-1&&gd(n[e+1],t),i&&(r=n[e],a&&(r.cp1x=up(r.cp1x,t.left,t.right),r.cp1y=up(r.cp1y,t.top,t.bottom)),o&&(r.cp2x=up(r.cp2x,t.left,t.right),r.cp2y=up(r.cp2y,t.top,t.bottom)))}function $ct(n,t,e,s,r){let i,a,o,u;if(t.spanGaps&&(n=n.filter(h=>!h.skip)),t.cubicInterpolationMode==="monotone")Sct(n,r);else{let h=s?n[n.length-1]:n[0];for(i=0,a=n.length;i<a;++i)o=n[i],u=bct(h,o,n[Math.min(i+1,a-(s?0:1))%a],t.tension),o.cp1x=u.previous.x,o.cp1y=u.previous.y,o.cp2x=u.next.x,o.cp2y=u.next.y,h=o}t.capBezierPoints&&Cct(n,e)}function Hw(){return typeof window<"u"&&typeof document<"u"}function jw(n){let t=n.parentNode;return t&&t.toString()==="[object ShadowRoot]"&&(t=t.host),t}function dm(n,t,e){let s;return typeof n=="string"?(s=parseInt(n,10),n.indexOf("%")!==-1&&(s=s/100*t.parentNode[e])):s=n,s}const Vm=n=>n.ownerDocument.defaultView.getComputedStyle(n,null);function Tct(n,t){return Vm(n).getPropertyValue(t)}const kct=["top","right","bottom","left"];function hl(n,t,e){const s={};e=e?"-"+e:"";for(let r=0;r<4;r++){const i=kct[r];s[i]=parseFloat(n[t+"-"+i+e])||0}return s.width=s.left+s.right,s.height=s.top+s.bottom,s}const _ct=(n,t,e)=>(n>0||t>0)&&(!e||!e.shadowRoot);function Nct(n,t){const e=n.touches,s=e&&e.length?e[0]:n,{offsetX:r,offsetY:i}=s;let a=!1,o,u;if(_ct(r,i,n.target))o=r,u=i;else{const h=t.getBoundingClientRect();o=s.clientX-h.left,u=s.clientY-h.top,a=!0}return{x:o,y:u,box:a}}function Yo(n,t){if("native"in n)return n;const{canvas:e,currentDevicePixelRatio:s}=t,r=Vm(e),i=r.boxSizing==="border-box",a=hl(r,"padding"),o=hl(r,"border","width"),{x:u,y:h,box:d}=Nct(n,e),f=a.left+(d&&o.left),m=a.top+(d&&o.top);let{width:y,height:x}=t;return i&&(y-=a.width+o.width,x-=a.height+o.height),{x:Math.round((u-f)/y*e.width/s),y:Math.round((h-m)/x*e.height/s)}}function Ect(n,t,e){let s,r;if(t===void 0||e===void 0){const i=n&&jw(n);if(!i)t=n.clientWidth,e=n.clientHeight;else{const a=i.getBoundingClientRect(),o=Vm(i),u=hl(o,"border","width"),h=hl(o,"padding");t=a.width-h.width-u.width,e=a.height-h.height-u.height,s=dm(o.maxWidth,i,"clientWidth"),r=dm(o.maxHeight,i,"clientHeight")}}return{width:t,height:e,maxWidth:s||cm,maxHeight:r||cm}}const cp=n=>Math.round(n*10)/10;function Rct(n,t,e,s){const r=Vm(n),i=hl(r,"margin"),a=dm(r.maxWidth,n,"clientWidth")||cm,o=dm(r.maxHeight,n,"clientHeight")||cm,u=Ect(n,t,e);let{width:h,height:d}=u;if(r.boxSizing==="content-box"){const m=hl(r,"border","width"),y=hl(r,"padding");h-=y.width+m.width,d-=y.height+m.height}return h=Math.max(0,h-i.width),d=Math.max(0,s?h/s:d-i.height),h=cp(Math.min(h,a,u.maxWidth)),d=cp(Math.min(d,o,u.maxHeight)),h&&!d&&(d=cp(h/2)),(t!==void 0||e!==void 0)&&s&&u.height&&d>u.height&&(d=u.height,h=cp(Math.floor(d*s))),{width:h,height:d}}function Ok(n,t,e){const s=t||1,r=Math.floor(n.height*s),i=Math.floor(n.width*s);n.height=Math.floor(n.height),n.width=Math.floor(n.width);const a=n.canvas;return a.style&&(e||!a.style.height&&!a.style.width)&&(a.style.height=`${n.height}px`,a.style.width=`${n.width}px`),n.currentDevicePixelRatio!==s||a.height!==r||a.width!==i?(n.currentDevicePixelRatio=s,a.height=r,a.width=i,n.ctx.setTransform(s,0,0,s,0,0),!0):!1}const Ict=(function(){let n=!1;try{const t={get passive(){return n=!0,!1}};Hw()&&(window.addEventListener("test",null,t),window.removeEventListener("test",null,t))}catch{}return n})();function Pk(n,t){const e=Tct(n,t),s=e&&e.match(/^(\d+)(\.\d+)?px$/);return s?+s[1]:void 0}function Qo(n,t,e,s){return{x:n.x+e*(t.x-n.x),y:n.y+e*(t.y-n.y)}}function Act(n,t,e,s){return{x:n.x+e*(t.x-n.x),y:s==="middle"?e<.5?n.y:t.y:s==="after"?e<1?n.y:t.y:e>0?t.y:n.y}}function Dct(n,t,e,s){const r={x:n.cp2x,y:n.cp2y},i={x:t.cp1x,y:t.cp1y},a=Qo(n,r,e),o=Qo(r,i,e),u=Qo(i,t,e),h=Qo(a,o,e),d=Qo(o,u,e);return Qo(h,d,e)}const Oct=function(n,t){return{x(e){return n+n+t-e},setWidth(e){t=e},textAlign(e){return e==="center"?e:e==="right"?"left":"right"},xPlus(e,s){return e-s},leftForLtr(e,s){return e-s}}},Pct=function(){return{x(n){return n},setWidth(n){},textAlign(n){return n},xPlus(n,t){return n+t},leftForLtr(n,t){return n}}};function Mu(n,t,e){return n?Oct(t,e):Pct()}function J3(n,t){let e,s;(t==="ltr"||t==="rtl")&&(e=n.canvas.style,s=[e.getPropertyValue("direction"),e.getPropertyPriority("direction")],e.setProperty("direction",t,"important"),n.prevTextDirection=s)}function tA(n,t){t!==void 0&&(delete n.prevTextDirection,n.canvas.style.setProperty("direction",t[0],t[1]))}function eA(n){return n==="angle"?{between:z3,compare:Aut,normalize:Va}:{between:Fh,compare:(t,e)=>t-e,normalize:t=>t}}function Fk({start:n,end:t,count:e,loop:s,style:r}){return{start:n%e,end:t%e,loop:s&&(t-n+1)%e===0,style:r}}function Fct(n,t,e){const{property:s,start:r,end:i}=e,{between:a,normalize:o}=eA(s),u=t.length;let{start:h,end:d,loop:f}=n,m,y;if(f){for(h+=u,d+=u,m=0,y=u;m<y&&a(o(t[h%u][s]),r,i);++m)h--,d--;h%=u,d%=u}return d<h&&(d+=u),{start:h,end:d,loop:f,style:n.style}}function Lct(n,t,e){if(!e)return[n];const{property:s,start:r,end:i}=e,a=t.length,{compare:o,between:u,normalize:h}=eA(s),{start:d,end:f,loop:m,style:y}=Fct(n,t,e),x=[];let w=!1,S=null,C,k,E;const R=()=>u(r,E,C)&&o(r,E)!==0,A=()=>o(i,C)===0||u(i,E,C),L=()=>w||R(),V=()=>!w||A();for(let B=d,z=d;B<=f;++B)k=t[B%a],!k.skip&&(C=h(k[s]),C!==E&&(w=u(C,r,i),S===null&&L()&&(S=o(C,r)===0?B:z),S!==null&&V()&&(x.push(Fk({start:S,end:B,loop:m,count:a,style:y})),S=null),z=B,E=C));return S!==null&&x.push(Fk({start:S,end:f,loop:m,count:a,style:y})),x}function Mct(n,t){const e=[],s=n.segments;for(let r=0;r<s.length;r++){const i=Lct(s[r],n.points,t);i.length&&e.push(...i)}return e}function zct(n,t,e,s){let r=0,i=t-1;if(e&&!s)for(;r<t&&!n[r].skip;)r++;for(;r<t&&n[r].skip;)r++;for(r%=t,e&&(i+=r);i>r&&n[i%t].skip;)i--;return i%=t,{start:r,end:i}}function Bct(n,t,e,s){const r=n.length,i=[];let a=t,o=n[t],u;for(u=t+1;u<=e;++u){const h=n[u%r];h.skip||h.stop?o.skip||(s=!1,i.push({start:t%r,end:(u-1)%r,loop:s}),t=a=h.stop?u:null):(a=u,o.skip&&(t=u)),o=h}return a!==null&&i.push({start:t%r,end:a%r,loop:s}),i}function Vct(n,t){const e=n.points,s=n.options.spanGaps,r=e.length;if(!r)return[];const i=!!n._loop,{start:a,end:o}=zct(e,r,i,s);if(s===!0)return Lk(n,[{start:a,end:o,loop:i}],e,t);const u=o<a?o+r:o,h=!!n._fullLoop&&a===0&&o===r-1;return Lk(n,Bct(e,a,u,h),e,t)}function Lk(n,t,e,s){return!s||!s.setContext||!e?t:Uct(n,t,e,s)}function Uct(n,t,e,s){const r=n._chart.getContext(),i=Mk(n.options),{_datasetIndex:a,options:{spanGaps:o}}=n,u=e.length,h=[];let d=i,f=t[0].start,m=f;function y(x,w,S,C){const k=o?-1:1;if(x!==w){for(x+=u;e[x%u].skip;)x-=k;for(;e[w%u].skip;)w+=k;x%u!==w%u&&(h.push({start:x%u,end:w%u,loop:S,style:C}),d=C,f=w%u)}}for(const x of t){f=o?f:x.start;let w=e[f%u],S;for(m=f+1;m<=x.end;m++){const C=e[m%u];S=Mk(s.setContext(Ol(r,{type:"segment",p0:w,p1:C,p0DataIndex:(m-1)%u,p1DataIndex:m%u,datasetIndex:a}))),Wct(S,d)&&y(f,m-1,x.loop,d),w=C,d=S}f<m-1&&y(f,m-1,x.loop,d)}return h}function Mk(n){return{backgroundColor:n.backgroundColor,borderCapStyle:n.borderCapStyle,borderDash:n.borderDash,borderDashOffset:n.borderDashOffset,borderJoinStyle:n.borderJoinStyle,borderWidth:n.borderWidth,borderColor:n.borderColor}}function Wct(n,t){if(!t)return!1;const e=[],s=function(r,i){return zw(i)?(e.includes(i)||e.push(i),e.indexOf(i)):i};return JSON.stringify(n,s)!==JSON.stringify(t,s)}function hp(n,t,e){return n.options.clip?n[e]:t[e]}function Gct(n,t){const{xScale:e,yScale:s}=n;return e&&s?{left:hp(e,t,"left"),right:hp(e,t,"right"),top:hp(s,t,"top"),bottom:hp(s,t,"bottom")}:t}function Hct(n,t){const e=t._clip;if(e.disabled)return!1;const s=Gct(t,n.chartArea);return{left:e.left===!1?0:s.left-(e.left===!0?0:e.left),right:e.right===!1?n.width:s.right+(e.right===!0?0:e.right),top:e.top===!1?0:s.top-(e.top===!0?0:e.top),bottom:e.bottom===!1?n.height:s.bottom+(e.bottom===!0?0:e.bottom)}}/*!
 * Chart.js v4.5.0
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */class jct{constructor(){this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}_notify(t,e,s,r){const i=e.listeners[r],a=e.duration;i.forEach(o=>o({chart:t,initial:e.initial,numSteps:a,currentStep:Math.min(s-e.start,a)}))}_refresh(){this._request||(this._running=!0,this._request=V3.call(window,()=>{this._update(),this._request=null,this._running&&this._refresh()}))}_update(t=Date.now()){let e=0;this._charts.forEach((s,r)=>{if(!s.running||!s.items.length)return;const i=s.items;let a=i.length-1,o=!1,u;for(;a>=0;--a)u=i[a],u._active?(u._total>s.duration&&(s.duration=u._total),u.tick(t),o=!0):(i[a]=i[i.length-1],i.pop());o&&(r.draw(),this._notify(r,s,t,"progress")),i.length||(s.running=!1,this._notify(r,s,t,"complete"),s.initial=!1),e+=i.length}),this._lastDate=t,e===0&&(this._running=!1)}_getAnims(t){const e=this._charts;let s=e.get(t);return s||(s={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},e.set(t,s)),s}listen(t,e,s){this._getAnims(t).listeners[e].push(s)}add(t,e){!e||!e.length||this._getAnims(t).items.push(...e)}has(t){return this._getAnims(t).items.length>0}start(t){const e=this._charts.get(t);e&&(e.running=!0,e.start=Date.now(),e.duration=e.items.reduce((s,r)=>Math.max(s,r._duration),0),this._refresh())}running(t){if(!this._running)return!1;const e=this._charts.get(t);return!(!e||!e.running||!e.items.length)}stop(t){const e=this._charts.get(t);if(!e||!e.items.length)return;const s=e.items;let r=s.length-1;for(;r>=0;--r)s[r].cancel();e.items=[],this._notify(t,e,Date.now(),"complete")}remove(t){return this._charts.delete(t)}}var ji=new jct;const zk="transparent",Xct={boolean(n,t,e){return e>.5?t:n},color(n,t,e){const s=Nk(n||zk),r=s.valid&&Nk(t||zk);return r&&r.valid?r.mix(s,e).hexString():t},number(n,t,e){return n+(t-n)*e}};class qct{constructor(t,e,s,r){const i=e[s];r=lp([t.to,r,i,t.from]);const a=lp([t.from,i,r]);this._active=!0,this._fn=t.fn||Xct[t.type||typeof a],this._easing=Hh[t.easing]||Hh.linear,this._start=Math.floor(Date.now()+(t.delay||0)),this._duration=this._total=Math.floor(t.duration),this._loop=!!t.loop,this._target=e,this._prop=s,this._from=a,this._to=r,this._promises=void 0}active(){return this._active}update(t,e,s){if(this._active){this._notify(!1);const r=this._target[this._prop],i=s-this._start,a=this._duration-i;this._start=s,this._duration=Math.floor(Math.max(a,t.duration)),this._total+=i,this._loop=!!t.loop,this._to=lp([t.to,e,r,t.from]),this._from=lp([t.from,r,e])}}cancel(){this._active&&(this.tick(Date.now()),this._active=!1,this._notify(!1))}tick(t){const e=t-this._start,s=this._duration,r=this._prop,i=this._from,a=this._loop,o=this._to;let u;if(this._active=i!==o&&(a||e<s),!this._active){this._target[r]=o,this._notify(!0);return}if(e<0){this._target[r]=i;return}u=e/s%2,u=a&&u>1?2-u:u,u=this._easing(Math.min(1,Math.max(0,u))),this._target[r]=this._fn(i,o,u)}wait(){const t=this._promises||(this._promises=[]);return new Promise((e,s)=>{t.push({res:e,rej:s})})}_notify(t){const e=t?"res":"rej",s=this._promises||[];for(let r=0;r<s.length;r++)s[r][e]()}}class nA{constructor(t,e){this._chart=t,this._properties=new Map,this.configure(e)}configure(t){if(!Te(t))return;const e=Object.keys(bn.animation),s=this._properties;Object.getOwnPropertyNames(t).forEach(r=>{const i=t[r];if(!Te(i))return;const a={};for(const o of e)a[o]=i[o];(Zn(i.properties)&&i.properties||[r]).forEach(o=>{(o===r||!s.has(o))&&s.set(o,a)})})}_animateOptions(t,e){const s=e.options,r=Yct(t,s);if(!r)return[];const i=this._createAnimations(r,s);return s.$shared&&Kct(t.options.$animations,s).then(()=>{t.options=s},()=>{}),i}_createAnimations(t,e){const s=this._properties,r=[],i=t.$animations||(t.$animations={}),a=Object.keys(e),o=Date.now();let u;for(u=a.length-1;u>=0;--u){const h=a[u];if(h.charAt(0)==="$")continue;if(h==="options"){r.push(...this._animateOptions(t,e));continue}const d=e[h];let f=i[h];const m=s.get(h);if(f)if(m&&f.active()){f.update(m,d,o);continue}else f.cancel();if(!m||!m.duration){t[h]=d;continue}i[h]=f=new qct(m,t,h,d),r.push(f)}return r}update(t,e){if(this._properties.size===0){Object.assign(t,e);return}const s=this._createAnimations(t,e);if(s.length)return ji.add(this._chart,s),!0}}function Kct(n,t){const e=[],s=Object.keys(t);for(let r=0;r<s.length;r++){const i=n[s[r]];i&&i.active()&&e.push(i.wait())}return Promise.all(e)}function Yct(n,t){if(!t)return;let e=n.options;if(!e){n.options=t;return}return e.$shared&&(n.options=e=Object.assign({},e,{$shared:!1,$animations:{}})),e}function Bk(n,t){const e=n&&n.options||{},s=e.reverse,r=e.min===void 0?t:0,i=e.max===void 0?t:0;return{start:s?i:r,end:s?r:i}}function Qct(n,t,e){if(e===!1)return!1;const s=Bk(n,e),r=Bk(t,e);return{top:r.end,right:s.end,bottom:r.start,left:s.start}}function Zct(n){let t,e,s,r;return Te(n)?(t=n.top,e=n.right,s=n.bottom,r=n.left):t=e=s=r=n,{top:t,right:e,bottom:s,left:r,disabled:n===!1}}function sA(n,t){const e=[],s=n._getSortedDatasetMetas(t);let r,i;for(r=0,i=s.length;r<i;++r)e.push(s[r].index);return e}function Vk(n,t,e,s={}){const r=n.keys,i=s.mode==="single";let a,o,u,h;if(t===null)return;let d=!1;for(a=0,o=r.length;a<o;++a){if(u=+r[a],u===e){if(d=!0,s.all)continue;break}h=n.values[u],Lr(h)&&(i||t===0||Xu(t)===Xu(h))&&(t+=h)}return!d&&!s.all?0:t}function Jct(n,t){const{iScale:e,vScale:s}=t,r=e.axis==="x"?"x":"y",i=s.axis==="x"?"x":"y",a=Object.keys(n),o=new Array(a.length);let u,h,d;for(u=0,h=a.length;u<h;++u)d=a[u],o[u]={[r]:d,[i]:n[d]};return o}function Ex(n,t){const e=n&&n.options.stacked;return e||e===void 0&&t.stack!==void 0}function tht(n,t,e){return`${n.id}.${t.id}.${e.stack||e.type}`}function eht(n){const{min:t,max:e,minDefined:s,maxDefined:r}=n.getUserBounds();return{min:s?t:Number.NEGATIVE_INFINITY,max:r?e:Number.POSITIVE_INFINITY}}function nht(n,t,e){const s=n[t]||(n[t]={});return s[e]||(s[e]={})}function Uk(n,t,e,s){for(const r of t.getMatchingVisibleMetas(s).reverse()){const i=n[r.index];if(e&&i>0||!e&&i<0)return r.index}return null}function Wk(n,t){const{chart:e,_cachedMeta:s}=n,r=e._stacks||(e._stacks={}),{iScale:i,vScale:a,index:o}=s,u=i.axis,h=a.axis,d=tht(i,a,s),f=t.length;let m;for(let y=0;y<f;++y){const x=t[y],{[u]:w,[h]:S}=x,C=x._stacks||(x._stacks={});m=C[h]=nht(r,d,w),m[o]=S,m._top=Uk(m,a,!0,s.type),m._bottom=Uk(m,a,!1,s.type);const k=m._visualValues||(m._visualValues={});k[o]=S}}function Rx(n,t){const e=n.scales;return Object.keys(e).filter(s=>e[s].axis===t).shift()}function sht(n,t){return Ol(n,{active:!1,dataset:void 0,datasetIndex:t,index:t,mode:"default",type:"dataset"})}function rht(n,t,e){return Ol(n,{active:!1,dataIndex:t,parsed:void 0,raw:void 0,element:e,index:t,mode:"default",type:"data"})}function vh(n,t){const e=n.controller.index,s=n.vScale&&n.vScale.axis;if(s){t=t||n._parsed;for(const r of t){const i=r._stacks;if(!i||i[s]===void 0||i[s][e]===void 0)return;delete i[s][e],i[s]._visualValues!==void 0&&i[s]._visualValues[e]!==void 0&&delete i[s]._visualValues[e]}}}const Ix=n=>n==="reset"||n==="none",Gk=(n,t)=>t?n:Object.assign({},n),iht=(n,t,e)=>n&&!t.hidden&&t._stacked&&{keys:sA(e,!0),values:null};class rA{static defaults={};static datasetElementType=null;static dataElementType=null;constructor(t,e){this.chart=t,this._ctx=t.ctx,this.index=e,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.supportsDecimation=!1,this.$context=void 0,this._syncList=[],this.datasetElementType=new.target.datasetElementType,this.dataElementType=new.target.dataElementType,this.initialize()}initialize(){const t=this._cachedMeta;this.configure(),this.linkScales(),t._stacked=Ex(t.vScale,t),this.addElements(),this.options.fill&&!this.chart.isPluginEnabled("filler")&&console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options")}updateIndex(t){this.index!==t&&vh(this._cachedMeta),this.index=t}linkScales(){const t=this.chart,e=this._cachedMeta,s=this.getDataset(),r=(f,m,y,x)=>f==="x"?m:f==="r"?x:y,i=e.xAxisID=xe(s.xAxisID,Rx(t,"x")),a=e.yAxisID=xe(s.yAxisID,Rx(t,"y")),o=e.rAxisID=xe(s.rAxisID,Rx(t,"r")),u=e.indexAxis,h=e.iAxisID=r(u,i,a,o),d=e.vAxisID=r(u,a,i,o);e.xScale=this.getScaleForId(i),e.yScale=this.getScaleForId(a),e.rScale=this.getScaleForId(o),e.iScale=this.getScaleForId(h),e.vScale=this.getScaleForId(d)}getDataset(){return this.chart.data.datasets[this.index]}getMeta(){return this.chart.getDatasetMeta(this.index)}getScaleForId(t){return this.chart.scales[t]}_getOtherScale(t){const e=this._cachedMeta;return t===e.iScale?e.vScale:e.iScale}reset(){this._update("reset")}_destroy(){const t=this._cachedMeta;this._data&&Tk(this._data,this),t._stacked&&vh(t)}_dataCheck(){const t=this.getDataset(),e=t.data||(t.data=[]),s=this._data;if(Te(e)){const r=this._cachedMeta;this._data=Jct(e,r)}else if(s!==e){if(s){Tk(s,this);const r=this._cachedMeta;vh(r),r._parsed=[]}e&&Object.isExtensible(e)&&Fut(e,this),this._syncList=[],this._data=e}}addElements(){const t=this._cachedMeta;this._dataCheck(),this.datasetElementType&&(t.dataset=new this.datasetElementType)}buildOrUpdateElements(t){const e=this._cachedMeta,s=this.getDataset();let r=!1;this._dataCheck();const i=e._stacked;e._stacked=Ex(e.vScale,e),e.stack!==s.stack&&(r=!0,vh(e),e.stack=s.stack),this._resyncElements(t),(r||i!==e._stacked)&&(Wk(this,e._parsed),e._stacked=Ex(e.vScale,e))}configure(){const t=this.chart.config,e=t.datasetScopeKeys(this._type),s=t.getOptionScopes(this.getDataset(),e,!0);this.options=t.createResolver(s,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}parse(t,e){const{_cachedMeta:s,_data:r}=this,{iScale:i,_stacked:a}=s,o=i.axis;let u=t===0&&e===r.length?!0:s._sorted,h=t>0&&s._parsed[t-1],d,f,m;if(this._parsing===!1)s._parsed=r,s._sorted=!0,m=r;else{Zn(r[t])?m=this.parseArrayData(s,r,t,e):Te(r[t])?m=this.parseObjectData(s,r,t,e):m=this.parsePrimitiveData(s,r,t,e);const y=()=>f[o]===null||h&&f[o]<h[o];for(d=0;d<e;++d)s._parsed[d+t]=f=m[d],u&&(y()&&(u=!1),h=f);s._sorted=u}a&&Wk(this,m)}parsePrimitiveData(t,e,s,r){const{iScale:i,vScale:a}=t,o=i.axis,u=a.axis,h=i.getLabels(),d=i===a,f=new Array(r);let m,y,x;for(m=0,y=r;m<y;++m)x=m+s,f[m]={[o]:d||i.parse(h[x],x),[u]:a.parse(e[x],x)};return f}parseArrayData(t,e,s,r){const{xScale:i,yScale:a}=t,o=new Array(r);let u,h,d,f;for(u=0,h=r;u<h;++u)d=u+s,f=e[d],o[u]={x:i.parse(f[0],d),y:a.parse(f[1],d)};return o}parseObjectData(t,e,s,r){const{xScale:i,yScale:a}=t,{xAxisKey:o="x",yAxisKey:u="y"}=this._parsing,h=new Array(r);let d,f,m,y;for(d=0,f=r;d<f;++d)m=d+s,y=e[m],h[d]={x:i.parse(lm(y,o),m),y:a.parse(lm(y,u),m)};return h}getParsed(t){return this._cachedMeta._parsed[t]}getDataElement(t){return this._cachedMeta.data[t]}applyStack(t,e,s){const r=this.chart,i=this._cachedMeta,a=e[t.axis],o={keys:sA(r,!0),values:e._stacks[t.axis]._visualValues};return Vk(o,a,i.index,{mode:s})}updateRangeFromParsed(t,e,s,r){const i=s[e.axis];let a=i===null?NaN:i;const o=r&&s._stacks[e.axis];r&&o&&(r.values=o,a=Vk(r,i,this._cachedMeta.index)),t.min=Math.min(t.min,a),t.max=Math.max(t.max,a)}getMinMax(t,e){const s=this._cachedMeta,r=s._parsed,i=s._sorted&&t===s.iScale,a=r.length,o=this._getOtherScale(t),u=iht(e,s,this.chart),h={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},{min:d,max:f}=eht(o);let m,y;function x(){y=r[m];const w=y[o.axis];return!Lr(y[t.axis])||d>w||f<w}for(m=0;m<a&&!(!x()&&(this.updateRangeFromParsed(h,t,y,u),i));++m);if(i){for(m=a-1;m>=0;--m)if(!x()){this.updateRangeFromParsed(h,t,y,u);break}}return h}getAllParsedValues(t){const e=this._cachedMeta._parsed,s=[];let r,i,a;for(r=0,i=e.length;r<i;++r)a=e[r][t.axis],Lr(a)&&s.push(a);return s}getMaxOverflow(){return!1}getLabelAndValue(t){const e=this._cachedMeta,s=e.iScale,r=e.vScale,i=this.getParsed(t);return{label:s?""+s.getLabelForValue(i[s.axis]):"",value:r?""+r.getLabelForValue(i[r.axis]):""}}_update(t){const e=this._cachedMeta;this.update(t||"default"),e._clip=Zct(xe(this.options.clip,Qct(e.xScale,e.yScale,this.getMaxOverflow())))}update(t){}draw(){const t=this._ctx,e=this.chart,s=this._cachedMeta,r=s.data||[],i=e.chartArea,a=[],o=this._drawStart||0,u=this._drawCount||r.length-o,h=this.options.drawActiveElementsOnTop;let d;for(s.dataset&&s.dataset.draw(t,i,o,u),d=o;d<o+u;++d){const f=r[d];f.hidden||(f.active&&h?a.push(f):f.draw(t,i))}for(d=0;d<a.length;++d)a[d].draw(t,i)}getStyle(t,e){const s=e?"active":"default";return t===void 0&&this._cachedMeta.dataset?this.resolveDatasetElementOptions(s):this.resolveDataElementOptions(t||0,s)}getContext(t,e,s){const r=this.getDataset();let i;if(t>=0&&t<this._cachedMeta.data.length){const a=this._cachedMeta.data[t];i=a.$context||(a.$context=rht(this.getContext(),t,a)),i.parsed=this.getParsed(t),i.raw=r.data[t],i.index=i.dataIndex=t}else i=this.$context||(this.$context=sht(this.chart.getContext(),this.index)),i.dataset=r,i.index=i.datasetIndex=this.index;return i.active=!!e,i.mode=s,i}resolveDatasetElementOptions(t){return this._resolveElementOptions(this.datasetElementType.id,t)}resolveDataElementOptions(t,e){return this._resolveElementOptions(this.dataElementType.id,e,t)}_resolveElementOptions(t,e="default",s){const r=e==="active",i=this._cachedDataOpts,a=t+"-"+e,o=i[a],u=this.enableOptionSharing&&um(s);if(o)return Gk(o,u);const h=this.chart.config,d=h.datasetElementScopeKeys(this._type,t),f=r?[`${t}Hover`,"hover",t,""]:[t,""],m=h.getOptionScopes(this.getDataset(),d),y=Object.keys(bn.elements[t]),x=()=>this.getContext(s,r,e),w=h.resolveNamedOptions(m,y,x,f);return w.$shared&&(w.$shared=u,i[a]=Object.freeze(Gk(w,u))),w}_resolveAnimations(t,e,s){const r=this.chart,i=this._cachedDataOpts,a=`animation-${e}`,o=i[a];if(o)return o;let u;if(r.options.animation!==!1){const d=this.chart.config,f=d.datasetAnimationScopeKeys(this._type,e),m=d.getOptionScopes(this.getDataset(),f);u=d.createResolver(m,this.getContext(t,s,e))}const h=new nA(r,u&&u.animations);return u&&u._cacheable&&(i[a]=Object.freeze(h)),h}getSharedOptions(t){if(t.$shared)return this._sharedOptions||(this._sharedOptions=Object.assign({},t))}includeOptions(t,e){return!e||Ix(t)||this.chart._animationsDisabled}_getSharedOptions(t,e){const s=this.resolveDataElementOptions(t,e),r=this._sharedOptions,i=this.getSharedOptions(s),a=this.includeOptions(e,i)||i!==r;return this.updateSharedOptions(i,e,s),{sharedOptions:i,includeOptions:a}}updateElement(t,e,s,r){Ix(r)?Object.assign(t,s):this._resolveAnimations(e,r).update(t,s)}updateSharedOptions(t,e,s){t&&!Ix(e)&&this._resolveAnimations(void 0,e).update(t,s)}_setStyle(t,e,s,r){t.active=r;const i=this.getStyle(e,r);this._resolveAnimations(e,s,r).update(t,{options:!r&&this.getSharedOptions(i)||i})}removeHoverStyle(t,e,s){this._setStyle(t,s,"active",!1)}setHoverStyle(t,e,s){this._setStyle(t,s,"active",!0)}_removeDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,"active",!1)}_setDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,"active",!0)}_resyncElements(t){const e=this._data,s=this._cachedMeta.data;for(const[o,u,h]of this._syncList)this[o](u,h);this._syncList=[];const r=s.length,i=e.length,a=Math.min(i,r);a&&this.parse(0,a),i>r?this._insertElements(r,i-r,t):i<r&&this._removeElements(i,r-i)}_insertElements(t,e,s=!0){const r=this._cachedMeta,i=r.data,a=t+e;let o;const u=h=>{for(h.length+=e,o=h.length-1;o>=a;o--)h[o]=h[o-e]};for(u(i),o=t;o<a;++o)i[o]=new this.dataElementType;this._parsing&&u(r._parsed),this.parse(t,e),s&&this.updateElements(i,t,e,"reset")}updateElements(t,e,s,r){}_removeElements(t,e){const s=this._cachedMeta;if(this._parsing){const r=s._parsed.splice(t,e);s._stacked&&vh(s,r)}s.data.splice(t,e)}_sync(t){if(this._parsing)this._syncList.push(t);else{const[e,s,r]=t;this[e](s,r)}this.chart._dataChanges.push([this.index,...t])}_onDataPush(){const t=arguments.length;this._sync(["_insertElements",this.getDataset().data.length-t,t])}_onDataPop(){this._sync(["_removeElements",this._cachedMeta.data.length-1,1])}_onDataShift(){this._sync(["_removeElements",0,1])}_onDataSplice(t,e){e&&this._sync(["_removeElements",t,e]);const s=arguments.length-2;s&&this._sync(["_insertElements",t,s])}_onDataUnshift(){this._sync(["_insertElements",0,arguments.length])}}class aht extends rA{static id="line";static defaults={datasetElementType:"line",dataElementType:"point",showLine:!0,spanGaps:!1};static overrides={scales:{_index_:{type:"category"},_value_:{type:"linear"}}};initialize(){this.enableOptionSharing=!0,this.supportsDecimation=!0,super.initialize()}update(t){const e=this._cachedMeta,{dataset:s,data:r=[],_dataset:i}=e,a=this.chart._animationsDisabled;let{start:o,count:u}=But(e,r,a);this._drawStart=o,this._drawCount=u,Vut(e)&&(o=0,u=r.length),s._chart=this.chart,s._datasetIndex=this.index,s._decimated=!!i._decimated,s.points=r;const h=this.resolveDatasetElementOptions(t);this.options.showLine||(h.borderWidth=0),h.segment=this.options.segment,this.updateElement(s,void 0,{animated:!a,options:h},t),this.updateElements(r,o,u,t)}updateElements(t,e,s,r){const i=r==="reset",{iScale:a,vScale:o,_stacked:u,_dataset:h}=this._cachedMeta,{sharedOptions:d,includeOptions:f}=this._getSharedOptions(e,r),m=a.axis,y=o.axis,{spanGaps:x,segment:w}=this.options,S=md(x)?x:Number.POSITIVE_INFINITY,C=this.chart._animationsDisabled||i||r==="none",k=e+s,E=t.length;let R=e>0&&this.getParsed(e-1);for(let A=0;A<E;++A){const L=t[A],V=C?L:{};if(A<e||A>=k){V.skip=!0;continue}const B=this.getParsed(A),z=Ye(B[y]),U=V[m]=a.getPixelForValue(B[m],A),D=V[y]=i||z?o.getBasePixel():o.getPixelForValue(u?this.applyStack(o,B,u):B[y],A);V.skip=isNaN(U)||isNaN(D)||z,V.stop=A>0&&Math.abs(B[m]-R[m])>S,w&&(V.parsed=B,V.raw=h.data[A]),f&&(V.options=d||this.resolveDataElementOptions(A,L.active?"active":r)),C||this.updateElement(L,A,V,r),R=B}}getMaxOverflow(){const t=this._cachedMeta,e=t.dataset,s=e.options&&e.options.borderWidth||0,r=t.data||[];if(!r.length)return s;const i=r[0].size(this.resolveDataElementOptions(0)),a=r[r.length-1].size(this.resolveDataElementOptions(r.length-1));return Math.max(s,i,a)/2}draw(){const t=this._cachedMeta;t.dataset.updateControlPoints(this.chart.chartArea,t.iScale.axis),super.draw()}}function Xo(){throw new Error("This method is not implemented: Check that a complete date adapter is provided.")}class Xw{static override(t){Object.assign(Xw.prototype,t)}options;constructor(t){this.options=t||{}}init(){}formats(){return Xo()}parse(){return Xo()}format(){return Xo()}add(){return Xo()}diff(){return Xo()}startOf(){return Xo()}endOf(){return Xo()}}var oht={_date:Xw};function lht(n,t,e,s){const{controller:r,data:i,_sorted:a}=n,o=r._cachedMeta.iScale,u=n.dataset&&n.dataset.options?n.dataset.options.spanGaps:null;if(o&&t===o.axis&&t!=="r"&&a&&i.length){const h=o._reversePixels?Out:ol;if(s){if(r._sharedOptions){const d=i[0],f=typeof d.getRange=="function"&&d.getRange(t);if(f){const m=h(i,t,e-f),y=h(i,t,e+f);return{lo:m.lo,hi:y.hi}}}}else{const d=h(i,t,e);if(u){const{vScale:f}=r._cachedMeta,{_parsed:m}=n,y=m.slice(0,d.lo+1).reverse().findIndex(w=>!Ye(w[f.axis]));d.lo-=Math.max(0,y);const x=m.slice(d.hi).findIndex(w=>!Ye(w[f.axis]));d.hi+=Math.max(0,x)}return d}}return{lo:0,hi:i.length-1}}function Um(n,t,e,s,r){const i=n.getSortedVisibleDatasetMetas(),a=e[t];for(let o=0,u=i.length;o<u;++o){const{index:h,data:d}=i[o],{lo:f,hi:m}=lht(i[o],t,a,r);for(let y=f;y<=m;++y){const x=d[y];x.skip||s(x,h,y)}}}function uht(n){const t=n.indexOf("x")!==-1,e=n.indexOf("y")!==-1;return function(s,r){const i=t?Math.abs(s.x-r.x):0,a=e?Math.abs(s.y-r.y):0;return Math.sqrt(Math.pow(i,2)+Math.pow(a,2))}}function Ax(n,t,e,s,r){const i=[];return!r&&!n.isPointInArea(t)||Um(n,e,t,function(o,u,h){!r&&!gd(o,n.chartArea,0)||o.inRange(t.x,t.y,s)&&i.push({element:o,datasetIndex:u,index:h})},!0),i}function cht(n,t,e,s){let r=[];function i(a,o,u){const{startAngle:h,endAngle:d}=a.getProps(["startAngle","endAngle"],s),{angle:f}=Iut(a,{x:t.x,y:t.y});z3(f,h,d)&&r.push({element:a,datasetIndex:o,index:u})}return Um(n,e,t,i),r}function hht(n,t,e,s,r,i){let a=[];const o=uht(e);let u=Number.POSITIVE_INFINITY;function h(d,f,m){const y=d.inRange(t.x,t.y,r);if(s&&!y)return;const x=d.getCenterPoint(r);if(!(!!i||n.isPointInArea(x))&&!y)return;const S=o(t,x);S<u?(a=[{element:d,datasetIndex:f,index:m}],u=S):S===u&&a.push({element:d,datasetIndex:f,index:m})}return Um(n,e,t,h),a}function Dx(n,t,e,s,r,i){return!i&&!n.isPointInArea(t)?[]:e==="r"&&!s?cht(n,t,e,r):hht(n,t,e,s,r,i)}function Hk(n,t,e,s,r){const i=[],a=e==="x"?"inXRange":"inYRange";let o=!1;return Um(n,e,t,(u,h,d)=>{u[a]&&u[a](t[e],r)&&(i.push({element:u,datasetIndex:h,index:d}),o=o||u.inRange(t.x,t.y,r))}),s&&!o?[]:i}var dht={modes:{index(n,t,e,s){const r=Yo(t,n),i=e.axis||"x",a=e.includeInvisible||!1,o=e.intersect?Ax(n,r,i,s,a):Dx(n,r,i,!1,s,a),u=[];return o.length?(n.getSortedVisibleDatasetMetas().forEach(h=>{const d=o[0].index,f=h.data[d];f&&!f.skip&&u.push({element:f,datasetIndex:h.index,index:d})}),u):[]},dataset(n,t,e,s){const r=Yo(t,n),i=e.axis||"xy",a=e.includeInvisible||!1;let o=e.intersect?Ax(n,r,i,s,a):Dx(n,r,i,!1,s,a);if(o.length>0){const u=o[0].datasetIndex,h=n.getDatasetMeta(u).data;o=[];for(let d=0;d<h.length;++d)o.push({element:h[d],datasetIndex:u,index:d})}return o},point(n,t,e,s){const r=Yo(t,n),i=e.axis||"xy",a=e.includeInvisible||!1;return Ax(n,r,i,s,a)},nearest(n,t,e,s){const r=Yo(t,n),i=e.axis||"xy",a=e.includeInvisible||!1;return Dx(n,r,i,e.intersect,s,a)},x(n,t,e,s){const r=Yo(t,n);return Hk(n,r,"x",e.intersect,s)},y(n,t,e,s){const r=Yo(t,n);return Hk(n,r,"y",e.intersect,s)}}};const iA=["left","top","right","bottom"];function wh(n,t){return n.filter(e=>e.pos===t)}function jk(n,t){return n.filter(e=>iA.indexOf(e.pos)===-1&&e.box.axis===t)}function Sh(n,t){return n.sort((e,s)=>{const r=t?s:e,i=t?e:s;return r.weight===i.weight?r.index-i.index:r.weight-i.weight})}function fht(n){const t=[];let e,s,r,i,a,o;for(e=0,s=(n||[]).length;e<s;++e)r=n[e],{position:i,options:{stack:a,stackWeight:o=1}}=r,t.push({index:e,box:r,pos:i,horizontal:r.isHorizontal(),weight:r.weight,stack:a&&i+a,stackWeight:o});return t}function pht(n){const t={};for(const e of n){const{stack:s,pos:r,stackWeight:i}=e;if(!s||!iA.includes(r))continue;const a=t[s]||(t[s]={count:0,placed:0,weight:0,size:0});a.count++,a.weight+=i}return t}function mht(n,t){const e=pht(n),{vBoxMaxWidth:s,hBoxMaxHeight:r}=t;let i,a,o;for(i=0,a=n.length;i<a;++i){o=n[i];const{fullSize:u}=o.box,h=e[o.stack],d=h&&o.stackWeight/h.weight;o.horizontal?(o.width=d?d*s:u&&t.availableWidth,o.height=r):(o.width=s,o.height=d?d*r:u&&t.availableHeight)}return e}function ght(n){const t=fht(n),e=Sh(t.filter(h=>h.box.fullSize),!0),s=Sh(wh(t,"left"),!0),r=Sh(wh(t,"right")),i=Sh(wh(t,"top"),!0),a=Sh(wh(t,"bottom")),o=jk(t,"x"),u=jk(t,"y");return{fullSize:e,leftAndTop:s.concat(i),rightAndBottom:r.concat(u).concat(a).concat(o),chartArea:wh(t,"chartArea"),vertical:s.concat(r).concat(u),horizontal:i.concat(a).concat(o)}}function Xk(n,t,e,s){return Math.max(n[e],t[e])+Math.max(n[s],t[s])}function aA(n,t){n.top=Math.max(n.top,t.top),n.left=Math.max(n.left,t.left),n.bottom=Math.max(n.bottom,t.bottom),n.right=Math.max(n.right,t.right)}function yht(n,t,e,s){const{pos:r,box:i}=e,a=n.maxPadding;if(!Te(r)){e.size&&(n[r]-=e.size);const f=s[e.stack]||{size:0,count:1};f.size=Math.max(f.size,e.horizontal?i.height:i.width),e.size=f.size/f.count,n[r]+=e.size}i.getPadding&&aA(a,i.getPadding());const o=Math.max(0,t.outerWidth-Xk(a,n,"left","right")),u=Math.max(0,t.outerHeight-Xk(a,n,"top","bottom")),h=o!==n.w,d=u!==n.h;return n.w=o,n.h=u,e.horizontal?{same:h,other:d}:{same:d,other:h}}function xht(n){const t=n.maxPadding;function e(s){const r=Math.max(t[s]-n[s],0);return n[s]+=r,r}n.y+=e("top"),n.x+=e("left"),e("right"),e("bottom")}function bht(n,t){const e=t.maxPadding;function s(r){const i={left:0,top:0,right:0,bottom:0};return r.forEach(a=>{i[a]=Math.max(t[a],e[a])}),i}return s(n?["left","right"]:["top","bottom"])}function Lh(n,t,e,s){const r=[];let i,a,o,u,h,d;for(i=0,a=n.length,h=0;i<a;++i){o=n[i],u=o.box,u.update(o.width||t.w,o.height||t.h,bht(o.horizontal,t));const{same:f,other:m}=yht(t,e,o,s);h|=f&&r.length,d=d||m,u.fullSize||r.push(o)}return h&&Lh(r,t,e,s)||d}function dp(n,t,e,s,r){n.top=e,n.left=t,n.right=t+s,n.bottom=e+r,n.width=s,n.height=r}function qk(n,t,e,s){const r=e.padding;let{x:i,y:a}=t;for(const o of n){const u=o.box,h=s[o.stack]||{placed:0,weight:1},d=o.stackWeight/h.weight||1;if(o.horizontal){const f=t.w*d,m=h.size||u.height;um(h.start)&&(a=h.start),u.fullSize?dp(u,r.left,a,e.outerWidth-r.right-r.left,m):dp(u,t.left+h.placed,a,f,m),h.start=a,h.placed+=f,a=u.bottom}else{const f=t.h*d,m=h.size||u.width;um(h.start)&&(i=h.start),u.fullSize?dp(u,i,r.top,m,e.outerHeight-r.bottom-r.top):dp(u,i,t.top+h.placed,m,f),h.start=i,h.placed+=f,i=u.right}}t.x=i,t.y=a}var Xa={addBox(n,t){n.boxes||(n.boxes=[]),t.fullSize=t.fullSize||!1,t.position=t.position||"top",t.weight=t.weight||0,t._layers=t._layers||function(){return[{z:0,draw(e){t.draw(e)}}]},n.boxes.push(t)},removeBox(n,t){const e=n.boxes?n.boxes.indexOf(t):-1;e!==-1&&n.boxes.splice(e,1)},configure(n,t,e){t.fullSize=e.fullSize,t.position=e.position,t.weight=e.weight},update(n,t,e,s){if(!n)return;const r=ni(n.options.layout.padding),i=Math.max(t-r.width,0),a=Math.max(e-r.height,0),o=ght(n.boxes),u=o.vertical,h=o.horizontal;Oe(n.boxes,w=>{typeof w.beforeLayout=="function"&&w.beforeLayout()});const d=u.reduce((w,S)=>S.box.options&&S.box.options.display===!1?w:w+1,0)||1,f=Object.freeze({outerWidth:t,outerHeight:e,padding:r,availableWidth:i,availableHeight:a,vBoxMaxWidth:i/2/d,hBoxMaxHeight:a/2}),m=Object.assign({},r);aA(m,ni(s));const y=Object.assign({maxPadding:m,w:i,h:a,x:r.left,y:r.top},r),x=mht(u.concat(h),f);Lh(o.fullSize,y,f,x),Lh(u,y,f,x),Lh(h,y,f,x)&&Lh(u,y,f,x),xht(y),qk(o.leftAndTop,y,f,x),y.x+=y.w,y.y+=y.h,qk(o.rightAndBottom,y,f,x),n.chartArea={left:y.left,top:y.top,right:y.left+y.w,bottom:y.top+y.h,height:y.h,width:y.w},Oe(o.chartArea,w=>{const S=w.box;Object.assign(S,n.chartArea),S.update(y.w,y.h,{left:0,top:0,right:0,bottom:0})})}};class oA{acquireContext(t,e){}releaseContext(t){return!1}addEventListener(t,e,s){}removeEventListener(t,e,s){}getDevicePixelRatio(){return 1}getMaximumSize(t,e,s,r){return e=Math.max(0,e||t.width),s=s||t.height,{width:e,height:Math.max(0,r?Math.floor(e/r):s)}}isAttached(t){return!0}updateConfig(t){}}class vht extends oA{acquireContext(t){return t&&t.getContext&&t.getContext("2d")||null}updateConfig(t){t.options.animation=!1}}const Pp="$chartjs",wht={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"},Kk=n=>n===null||n==="";function Sht(n,t){const e=n.style,s=n.getAttribute("height"),r=n.getAttribute("width");if(n[Pp]={initial:{height:s,width:r,style:{display:e.display,height:e.height,width:e.width}}},e.display=e.display||"block",e.boxSizing=e.boxSizing||"border-box",Kk(r)){const i=Pk(n,"width");i!==void 0&&(n.width=i)}if(Kk(s))if(n.style.height==="")n.height=n.width/(t||2);else{const i=Pk(n,"height");i!==void 0&&(n.height=i)}return n}const lA=Ict?{passive:!0}:!1;function Cht(n,t,e){n&&n.addEventListener(t,e,lA)}function $ht(n,t,e){n&&n.canvas&&n.canvas.removeEventListener(t,e,lA)}function Tht(n,t){const e=wht[n.type]||n.type,{x:s,y:r}=Yo(n,t);return{type:e,chart:t,native:n,x:s!==void 0?s:null,y:r!==void 0?r:null}}function fm(n,t){for(const e of n)if(e===t||e.contains(t))return!0}function kht(n,t,e){const s=n.canvas,r=new MutationObserver(i=>{let a=!1;for(const o of i)a=a||fm(o.addedNodes,s),a=a&&!fm(o.removedNodes,s);a&&e()});return r.observe(document,{childList:!0,subtree:!0}),r}function _ht(n,t,e){const s=n.canvas,r=new MutationObserver(i=>{let a=!1;for(const o of i)a=a||fm(o.removedNodes,s),a=a&&!fm(o.addedNodes,s);a&&e()});return r.observe(document,{childList:!0,subtree:!0}),r}const yd=new Map;let Yk=0;function uA(){const n=window.devicePixelRatio;n!==Yk&&(Yk=n,yd.forEach((t,e)=>{e.currentDevicePixelRatio!==n&&t()}))}function Nht(n,t){yd.size||window.addEventListener("resize",uA),yd.set(n,t)}function Eht(n){yd.delete(n),yd.size||window.removeEventListener("resize",uA)}function Rht(n,t,e){const s=n.canvas,r=s&&jw(s);if(!r)return;const i=U3((o,u)=>{const h=r.clientWidth;e(o,u),h<r.clientWidth&&e()},window),a=new ResizeObserver(o=>{const u=o[0],h=u.contentRect.width,d=u.contentRect.height;h===0&&d===0||i(h,d)});return a.observe(r),Nht(n,i),a}function Ox(n,t,e){e&&e.disconnect(),t==="resize"&&Eht(n)}function Iht(n,t,e){const s=n.canvas,r=U3(i=>{n.ctx!==null&&e(Tht(i,n))},n);return Cht(s,t,r),r}class Aht extends oA{acquireContext(t,e){const s=t&&t.getContext&&t.getContext("2d");return s&&s.canvas===t?(Sht(t,e),s):null}releaseContext(t){const e=t.canvas;if(!e[Pp])return!1;const s=e[Pp].initial;["height","width"].forEach(i=>{const a=s[i];Ye(a)?e.removeAttribute(i):e.setAttribute(i,a)});const r=s.style||{};return Object.keys(r).forEach(i=>{e.style[i]=r[i]}),e.width=e.width,delete e[Pp],!0}addEventListener(t,e,s){this.removeEventListener(t,e);const r=t.$proxies||(t.$proxies={}),a={attach:kht,detach:_ht,resize:Rht}[e]||Iht;r[e]=a(t,e,s)}removeEventListener(t,e){const s=t.$proxies||(t.$proxies={}),r=s[e];if(!r)return;({attach:Ox,detach:Ox,resize:Ox}[e]||$ht)(t,e,r),s[e]=void 0}getDevicePixelRatio(){return window.devicePixelRatio}getMaximumSize(t,e,s,r){return Rct(t,e,s,r)}isAttached(t){const e=t&&jw(t);return!!(e&&e.isConnected)}}function Dht(n){return!Hw()||typeof OffscreenCanvas<"u"&&n instanceof OffscreenCanvas?vht:Aht}class dc{static defaults={};static defaultRoutes=void 0;x;y;active=!1;options;$animations;tooltipPosition(t){const{x:e,y:s}=this.getProps(["x","y"],t);return{x:e,y:s}}hasValue(){return md(this.x)&&md(this.y)}getProps(t,e){const s=this.$animations;if(!e||!s)return this;const r={};return t.forEach(i=>{r[i]=s[i]&&s[i].active()?s[i]._to:this[i]}),r}}function Oht(n,t){const e=n.options.ticks,s=Pht(n),r=Math.min(e.maxTicksLimit||s,s),i=e.major.enabled?Lht(t):[],a=i.length,o=i[0],u=i[a-1],h=[];if(a>r)return Mht(t,h,i,a/r),h;const d=Fht(i,t,r);if(a>0){let f,m;const y=a>1?Math.round((u-o)/(a-1)):null;for(fp(t,h,d,Ye(y)?0:o-y,o),f=0,m=a-1;f<m;f++)fp(t,h,d,i[f],i[f+1]);return fp(t,h,d,u,Ye(y)?t.length:u+y),h}return fp(t,h,d),h}function Pht(n){const t=n.options.offset,e=n._tickSize(),s=n._length/e+(t?0:1),r=n._maxLength/e;return Math.floor(Math.min(s,r))}function Fht(n,t,e){const s=zht(n),r=t.length/e;if(!s)return Math.max(r,1);const i=kut(s);for(let a=0,o=i.length-1;a<o;a++){const u=i[a];if(u>r)return u}return Math.max(r,1)}function Lht(n){const t=[];let e,s;for(e=0,s=n.length;e<s;e++)n[e].major&&t.push(e);return t}function Mht(n,t,e,s){let r=0,i=e[0],a;for(s=Math.ceil(s),a=0;a<n.length;a++)a===i&&(t.push(n[a]),r++,i=e[r*s])}function fp(n,t,e,s,r){const i=xe(s,0),a=Math.min(xe(r,n.length),n.length);let o=0,u,h,d;for(e=Math.ceil(e),r&&(u=r-s,e=u/Math.floor(u/e)),d=i;d<0;)o++,d=Math.round(i+o*e);for(h=Math.max(i,0);h<a;h++)h===d&&(t.push(n[h]),o++,d=Math.round(i+o*e))}function zht(n){const t=n.length;let e,s;if(t<2)return!1;for(s=n[0],e=1;e<t;++e)if(n[e]-n[e-1]!==s)return!1;return s}const Bht=n=>n==="left"?"right":n==="right"?"left":n,Qk=(n,t,e)=>t==="top"||t==="left"?n[t]+e:n[t]-e,Zk=(n,t)=>Math.min(t||n,n);function Jk(n,t){const e=[],s=n.length/t,r=n.length;let i=0;for(;i<r;i+=s)e.push(n[Math.floor(i)]);return e}function Vht(n,t,e){const s=n.ticks.length,r=Math.min(t,s-1),i=n._startPixel,a=n._endPixel,o=1e-6;let u=n.getPixelForTick(r),h;if(!(e&&(s===1?h=Math.max(u-i,a-u):t===0?h=(n.getPixelForTick(1)-u)/2:h=(u-n.getPixelForTick(r-1))/2,u+=r<t?h:-h,u<i-o||u>a+o)))return u}function Uht(n,t){Oe(n,e=>{const s=e.gc,r=s.length/2;let i;if(r>t){for(i=0;i<r;++i)delete e.data[s[i]];s.splice(0,r)}})}function Ch(n){return n.drawTicks?n.tickLength:0}function t_(n,t){if(!n.display)return 0;const e=js(n.font,t),s=ni(n.padding);return(Zn(n.text)?n.text.length:1)*e.lineHeight+s.height}function Wht(n,t){return Ol(n,{scale:t,type:"scale"})}function Ght(n,t,e){return Ol(n,{tick:e,index:t,type:"tick"})}function Hht(n,t,e){let s=W3(n);return(e&&t!=="right"||!e&&t==="right")&&(s=Bht(s)),s}function jht(n,t,e,s){const{top:r,left:i,bottom:a,right:o,chart:u}=n,{chartArea:h,scales:d}=u;let f=0,m,y,x;const w=a-r,S=o-i;if(n.isHorizontal()){if(y=lr(s,i,o),Te(e)){const C=Object.keys(e)[0],k=e[C];x=d[C].getPixelForValue(k)+w-t}else e==="center"?x=(h.bottom+h.top)/2+w-t:x=Qk(n,e,t);m=o-i}else{if(Te(e)){const C=Object.keys(e)[0],k=e[C];y=d[C].getPixelForValue(k)-S+t}else e==="center"?y=(h.left+h.right)/2-S+t:y=Qk(n,e,t);x=lr(s,a,r),f=e==="left"?-ti:ti}return{titleX:y,titleY:x,maxWidth:m,rotation:f}}class fc extends dc{constructor(t){super(),this.id=t.id,this.type=t.type,this.options=void 0,this.ctx=t.ctx,this.chart=t.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}init(t){this.options=t.setContext(this.getContext()),this.axis=t.axis,this._userMin=this.parse(t.min),this._userMax=this.parse(t.max),this._suggestedMin=this.parse(t.suggestedMin),this._suggestedMax=this.parse(t.suggestedMax)}parse(t,e){return t}getUserBounds(){let{_userMin:t,_userMax:e,_suggestedMin:s,_suggestedMax:r}=this;return t=di(t,Number.POSITIVE_INFINITY),e=di(e,Number.NEGATIVE_INFINITY),s=di(s,Number.POSITIVE_INFINITY),r=di(r,Number.NEGATIVE_INFINITY),{min:di(t,s),max:di(e,r),minDefined:Lr(t),maxDefined:Lr(e)}}getMinMax(t){let{min:e,max:s,minDefined:r,maxDefined:i}=this.getUserBounds(),a;if(r&&i)return{min:e,max:s};const o=this.getMatchingVisibleMetas();for(let u=0,h=o.length;u<h;++u)a=o[u].controller.getMinMax(this,t),r||(e=Math.min(e,a.min)),i||(s=Math.max(s,a.max));return e=i&&e>s?s:e,s=r&&e>s?e:s,{min:di(e,di(s,e)),max:di(s,di(e,s))}}getPadding(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}getTicks(){return this.ticks}getLabels(){const t=this.chart.data;return this.options.labels||(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels||[]}getLabelItems(t=this.chart.chartArea){return this._labelItems||(this._labelItems=this._computeLabelItems(t))}beforeLayout(){this._cache={},this._dataLimitsCached=!1}beforeUpdate(){en(this.options.beforeUpdate,[this])}update(t,e,s){const{beginAtZero:r,grace:i,ticks:a}=this.options,o=a.sampleSize;this.beforeUpdate(),this.maxWidth=t,this.maxHeight=e,this._margins=s=Object.assign({left:0,right:0,top:0,bottom:0},s),this.ticks=null,this._labelSizes=null,this._gridLineItems=null,this._labelItems=null,this.beforeSetDimensions(),this.setDimensions(),this.afterSetDimensions(),this._maxLength=this.isHorizontal()?this.width+s.left+s.right:this.height+s.top+s.bottom,this._dataLimitsCached||(this.beforeDataLimits(),this.determineDataLimits(),this.afterDataLimits(),this._range=lct(this,i,r),this._dataLimitsCached=!0),this.beforeBuildTicks(),this.ticks=this.buildTicks()||[],this.afterBuildTicks();const u=o<this.ticks.length;this._convertTicksToLabels(u?Jk(this.ticks,o):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),a.display&&(a.autoSkip||a.source==="auto")&&(this.ticks=Oht(this,this.ticks),this._labelSizes=null,this.afterAutoSkip()),u&&this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}configure(){let t=this.options.reverse,e,s;this.isHorizontal()?(e=this.left,s=this.right):(e=this.top,s=this.bottom,t=!t),this._startPixel=e,this._endPixel=s,this._reversePixels=t,this._length=s-e,this._alignToPixels=this.options.alignToPixels}afterUpdate(){en(this.options.afterUpdate,[this])}beforeSetDimensions(){en(this.options.beforeSetDimensions,[this])}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}afterSetDimensions(){en(this.options.afterSetDimensions,[this])}_callHooks(t){this.chart.notifyPlugins(t,this.getContext()),en(this.options[t],[this])}beforeDataLimits(){this._callHooks("beforeDataLimits")}determineDataLimits(){}afterDataLimits(){this._callHooks("afterDataLimits")}beforeBuildTicks(){this._callHooks("beforeBuildTicks")}buildTicks(){return[]}afterBuildTicks(){this._callHooks("afterBuildTicks")}beforeTickToLabelConversion(){en(this.options.beforeTickToLabelConversion,[this])}generateTickLabels(t){const e=this.options.ticks;let s,r,i;for(s=0,r=t.length;s<r;s++)i=t[s],i.label=en(e.callback,[i.value,s,t],this)}afterTickToLabelConversion(){en(this.options.afterTickToLabelConversion,[this])}beforeCalculateLabelRotation(){en(this.options.beforeCalculateLabelRotation,[this])}calculateLabelRotation(){const t=this.options,e=t.ticks,s=Zk(this.ticks.length,t.ticks.maxTicksLimit),r=e.minRotation||0,i=e.maxRotation;let a=r,o,u,h;if(!this._isVisible()||!e.display||r>=i||s<=1||!this.isHorizontal()){this.labelRotation=r;return}const d=this._getLabelSizes(),f=d.widest.width,m=d.highest.height,y=Ar(this.chart.width-f,0,this.maxWidth);o=t.offset?this.maxWidth/s:y/(s-1),f+6>o&&(o=y/(s-(t.offset?.5:1)),u=this.maxHeight-Ch(t.grid)-e.padding-t_(t.title,this.chart.options.font),h=Math.sqrt(f*f+m*m),a=Rut(Math.min(Math.asin(Ar((d.highest.height+6)/o,-1,1)),Math.asin(Ar(u/h,-1,1))-Math.asin(Ar(m/h,-1,1)))),a=Math.max(r,Math.min(i,a))),this.labelRotation=a}afterCalculateLabelRotation(){en(this.options.afterCalculateLabelRotation,[this])}afterAutoSkip(){}beforeFit(){en(this.options.beforeFit,[this])}fit(){const t={width:0,height:0},{chart:e,options:{ticks:s,title:r,grid:i}}=this,a=this._isVisible(),o=this.isHorizontal();if(a){const u=t_(r,e.options.font);if(o?(t.width=this.maxWidth,t.height=Ch(i)+u):(t.height=this.maxHeight,t.width=Ch(i)+u),s.display&&this.ticks.length){const{first:h,last:d,widest:f,highest:m}=this._getLabelSizes(),y=s.padding*2,x=al(this.labelRotation),w=Math.cos(x),S=Math.sin(x);if(o){const C=s.mirror?0:S*f.width+w*m.height;t.height=Math.min(this.maxHeight,t.height+C+y)}else{const C=s.mirror?0:w*f.width+S*m.height;t.width=Math.min(this.maxWidth,t.width+C+y)}this._calculatePadding(h,d,S,w)}}this._handleMargins(),o?(this.width=this._length=e.width-this._margins.left-this._margins.right,this.height=t.height):(this.width=t.width,this.height=this._length=e.height-this._margins.top-this._margins.bottom)}_calculatePadding(t,e,s,r){const{ticks:{align:i,padding:a},position:o}=this.options,u=this.labelRotation!==0,h=o!=="top"&&this.axis==="x";if(this.isHorizontal()){const d=this.getPixelForTick(0)-this.left,f=this.right-this.getPixelForTick(this.ticks.length-1);let m=0,y=0;u?h?(m=r*t.width,y=s*e.height):(m=s*t.height,y=r*e.width):i==="start"?y=e.width:i==="end"?m=t.width:i!=="inner"&&(m=t.width/2,y=e.width/2),this.paddingLeft=Math.max((m-d+a)*this.width/(this.width-d),0),this.paddingRight=Math.max((y-f+a)*this.width/(this.width-f),0)}else{let d=e.height/2,f=t.height/2;i==="start"?(d=0,f=t.height):i==="end"&&(d=e.height,f=0),this.paddingTop=d+a,this.paddingBottom=f+a}}_handleMargins(){this._margins&&(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),this._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}afterFit(){en(this.options.afterFit,[this])}isHorizontal(){const{axis:t,position:e}=this.options;return e==="top"||e==="bottom"||t==="x"}isFullSize(){return this.options.fullSize}_convertTicksToLabels(t){this.beforeTickToLabelConversion(),this.generateTickLabels(t);let e,s;for(e=0,s=t.length;e<s;e++)Ye(t[e].label)&&(t.splice(e,1),s--,e--);this.afterTickToLabelConversion()}_getLabelSizes(){let t=this._labelSizes;if(!t){const e=this.options.ticks.sampleSize;let s=this.ticks;e<s.length&&(s=Jk(s,e)),this._labelSizes=t=this._computeLabelSizes(s,s.length,this.options.ticks.maxTicksLimit)}return t}_computeLabelSizes(t,e,s){const{ctx:r,_longestTextCache:i}=this,a=[],o=[],u=Math.floor(e/Zk(e,s));let h=0,d=0,f,m,y,x,w,S,C,k,E,R,A;for(f=0;f<e;f+=u){if(x=t[f].label,w=this._resolveTickFontOptions(f),r.font=S=w.string,C=i[S]=i[S]||{data:{},gc:[]},k=w.lineHeight,E=R=0,!Ye(x)&&!Zn(x))E=Rk(r,C.data,C.gc,E,x),R=k;else if(Zn(x))for(m=0,y=x.length;m<y;++m)A=x[m],!Ye(A)&&!Zn(A)&&(E=Rk(r,C.data,C.gc,E,A),R+=k);a.push(E),o.push(R),h=Math.max(E,h),d=Math.max(R,d)}Uht(i,e);const L=a.indexOf(h),V=o.indexOf(d),B=z=>({width:a[z]||0,height:o[z]||0});return{first:B(0),last:B(e-1),widest:B(L),highest:B(V),widths:a,heights:o}}getLabelForValue(t){return t}getPixelForValue(t,e){return NaN}getValueForPixel(t){}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getPixelForDecimal(t){this._reversePixels&&(t=1-t);const e=this._startPixel+t*this._length;return Dut(this._alignToPixels?jo(this.chart,e,0):e)}getDecimalForPixel(t){const e=(t-this._startPixel)/this._length;return this._reversePixels?1-e:e}getBasePixel(){return this.getPixelForValue(this.getBaseValue())}getBaseValue(){const{min:t,max:e}=this;return t<0&&e<0?e:t>0&&e>0?t:0}getContext(t){const e=this.ticks||[];if(t>=0&&t<e.length){const s=e[t];return s.$context||(s.$context=Ght(this.getContext(),t,s))}return this.$context||(this.$context=Wht(this.chart.getContext(),this))}_tickSize(){const t=this.options.ticks,e=al(this.labelRotation),s=Math.abs(Math.cos(e)),r=Math.abs(Math.sin(e)),i=this._getLabelSizes(),a=t.autoSkipPadding||0,o=i?i.widest.width+a:0,u=i?i.highest.height+a:0;return this.isHorizontal()?u*s>o*r?o/s:u/r:u*r<o*s?u/s:o/r}_isVisible(){const t=this.options.display;return t!=="auto"?!!t:this.getMatchingVisibleMetas().length>0}_computeGridLineItems(t){const e=this.axis,s=this.chart,r=this.options,{grid:i,position:a,border:o}=r,u=i.offset,h=this.isHorizontal(),f=this.ticks.length+(u?1:0),m=Ch(i),y=[],x=o.setContext(this.getContext()),w=x.display?x.width:0,S=w/2,C=function(K){return jo(s,K,w)};let k,E,R,A,L,V,B,z,U,D,Y,nt;if(a==="top")k=C(this.bottom),V=this.bottom-m,z=k-S,D=C(t.top)+S,nt=t.bottom;else if(a==="bottom")k=C(this.top),D=t.top,nt=C(t.bottom)-S,V=k+S,z=this.top+m;else if(a==="left")k=C(this.right),L=this.right-m,B=k-S,U=C(t.left)+S,Y=t.right;else if(a==="right")k=C(this.left),U=t.left,Y=C(t.right)-S,L=k+S,B=this.left+m;else if(e==="x"){if(a==="center")k=C((t.top+t.bottom)/2+.5);else if(Te(a)){const K=Object.keys(a)[0],ct=a[K];k=C(this.chart.scales[K].getPixelForValue(ct))}D=t.top,nt=t.bottom,V=k+S,z=V+m}else if(e==="y"){if(a==="center")k=C((t.left+t.right)/2);else if(Te(a)){const K=Object.keys(a)[0],ct=a[K];k=C(this.chart.scales[K].getPixelForValue(ct))}L=k-S,B=L-m,U=t.left,Y=t.right}const dt=xe(r.ticks.maxTicksLimit,f),at=Math.max(1,Math.ceil(f/dt));for(E=0;E<f;E+=at){const K=this.getContext(E),ct=i.setContext(K),yt=o.setContext(K),$t=ct.lineWidth,H=ct.color,ut=yt.dash||[],xt=yt.dashOffset,bt=ct.tickWidth,_t=ct.tickColor,Kt=ct.tickBorderDash||[],Mt=ct.tickBorderDashOffset;R=Vht(this,E,u),R!==void 0&&(A=jo(s,R,$t),h?L=B=U=Y=A:V=z=D=nt=A,y.push({tx1:L,ty1:V,tx2:B,ty2:z,x1:U,y1:D,x2:Y,y2:nt,width:$t,color:H,borderDash:ut,borderDashOffset:xt,tickWidth:bt,tickColor:_t,tickBorderDash:Kt,tickBorderDashOffset:Mt}))}return this._ticksLength=f,this._borderValue=k,y}_computeLabelItems(t){const e=this.axis,s=this.options,{position:r,ticks:i}=s,a=this.isHorizontal(),o=this.ticks,{align:u,crossAlign:h,padding:d,mirror:f}=i,m=Ch(s.grid),y=m+d,x=f?-d:y,w=-al(this.labelRotation),S=[];let C,k,E,R,A,L,V,B,z,U,D,Y,nt="middle";if(r==="top")L=this.bottom-x,V=this._getXAxisLabelAlignment();else if(r==="bottom")L=this.top+x,V=this._getXAxisLabelAlignment();else if(r==="left"){const at=this._getYAxisLabelAlignment(m);V=at.textAlign,A=at.x}else if(r==="right"){const at=this._getYAxisLabelAlignment(m);V=at.textAlign,A=at.x}else if(e==="x"){if(r==="center")L=(t.top+t.bottom)/2+y;else if(Te(r)){const at=Object.keys(r)[0],K=r[at];L=this.chart.scales[at].getPixelForValue(K)+y}V=this._getXAxisLabelAlignment()}else if(e==="y"){if(r==="center")A=(t.left+t.right)/2-y;else if(Te(r)){const at=Object.keys(r)[0],K=r[at];A=this.chart.scales[at].getPixelForValue(K)}V=this._getYAxisLabelAlignment(m).textAlign}e==="y"&&(u==="start"?nt="top":u==="end"&&(nt="bottom"));const dt=this._getLabelSizes();for(C=0,k=o.length;C<k;++C){E=o[C],R=E.label;const at=i.setContext(this.getContext(C));B=this.getPixelForTick(C)+i.labelOffset,z=this._resolveTickFontOptions(C),U=z.lineHeight,D=Zn(R)?R.length:1;const K=D/2,ct=at.color,yt=at.textStrokeColor,$t=at.textStrokeWidth;let H=V;a?(A=B,V==="inner"&&(C===k-1?H=this.options.reverse?"left":"right":C===0?H=this.options.reverse?"right":"left":H="center"),r==="top"?h==="near"||w!==0?Y=-D*U+U/2:h==="center"?Y=-dt.highest.height/2-K*U+U:Y=-dt.highest.height+U/2:h==="near"||w!==0?Y=U/2:h==="center"?Y=dt.highest.height/2-K*U:Y=dt.highest.height-D*U,f&&(Y*=-1),w!==0&&!at.showLabelBackdrop&&(A+=U/2*Math.sin(w))):(L=B,Y=(1-D)*U/2);let ut;if(at.showLabelBackdrop){const xt=ni(at.backdropPadding),bt=dt.heights[C],_t=dt.widths[C];let Kt=Y-xt.top,Mt=0-xt.left;switch(nt){case"middle":Kt-=bt/2;break;case"bottom":Kt-=bt;break}switch(V){case"center":Mt-=_t/2;break;case"right":Mt-=_t;break;case"inner":C===k-1?Mt-=_t:C>0&&(Mt-=_t/2);break}ut={left:Mt,top:Kt,width:_t+xt.width,height:bt+xt.height,color:at.backdropColor}}S.push({label:R,font:z,textOffset:Y,options:{rotation:w,color:ct,strokeColor:yt,strokeWidth:$t,textAlign:H,textBaseline:nt,translation:[A,L],backdrop:ut}})}return S}_getXAxisLabelAlignment(){const{position:t,ticks:e}=this.options;if(-al(this.labelRotation))return t==="top"?"left":"right";let r="center";return e.align==="start"?r="left":e.align==="end"?r="right":e.align==="inner"&&(r="inner"),r}_getYAxisLabelAlignment(t){const{position:e,ticks:{crossAlign:s,mirror:r,padding:i}}=this.options,a=this._getLabelSizes(),o=t+i,u=a.widest.width;let h,d;return e==="left"?r?(d=this.right+i,s==="near"?h="left":s==="center"?(h="center",d+=u/2):(h="right",d+=u)):(d=this.right-o,s==="near"?h="right":s==="center"?(h="center",d-=u/2):(h="left",d=this.left)):e==="right"?r?(d=this.left+i,s==="near"?h="right":s==="center"?(h="center",d-=u/2):(h="left",d-=u)):(d=this.left+o,s==="near"?h="left":s==="center"?(h="center",d+=u/2):(h="right",d=this.right)):h="right",{textAlign:h,x:d}}_computeLabelArea(){if(this.options.ticks.mirror)return;const t=this.chart,e=this.options.position;if(e==="left"||e==="right")return{top:0,left:this.left,bottom:t.height,right:this.right};if(e==="top"||e==="bottom")return{top:this.top,left:0,bottom:this.bottom,right:t.width}}drawBackground(){const{ctx:t,options:{backgroundColor:e},left:s,top:r,width:i,height:a}=this;e&&(t.save(),t.fillStyle=e,t.fillRect(s,r,i,a),t.restore())}getLineWidthForValue(t){const e=this.options.grid;if(!this._isVisible()||!e.display)return 0;const r=this.ticks.findIndex(i=>i.value===t);return r>=0?e.setContext(this.getContext(r)).lineWidth:0}drawGrid(t){const e=this.options.grid,s=this.ctx,r=this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(t));let i,a;const o=(u,h,d)=>{!d.width||!d.color||(s.save(),s.lineWidth=d.width,s.strokeStyle=d.color,s.setLineDash(d.borderDash||[]),s.lineDashOffset=d.borderDashOffset,s.beginPath(),s.moveTo(u.x,u.y),s.lineTo(h.x,h.y),s.stroke(),s.restore())};if(e.display)for(i=0,a=r.length;i<a;++i){const u=r[i];e.drawOnChartArea&&o({x:u.x1,y:u.y1},{x:u.x2,y:u.y2},u),e.drawTicks&&o({x:u.tx1,y:u.ty1},{x:u.tx2,y:u.ty2},{color:u.tickColor,width:u.tickWidth,borderDash:u.tickBorderDash,borderDashOffset:u.tickBorderDashOffset})}}drawBorder(){const{chart:t,ctx:e,options:{border:s,grid:r}}=this,i=s.setContext(this.getContext()),a=s.display?i.width:0;if(!a)return;const o=r.setContext(this.getContext(0)).lineWidth,u=this._borderValue;let h,d,f,m;this.isHorizontal()?(h=jo(t,this.left,a)-a/2,d=jo(t,this.right,o)+o/2,f=m=u):(f=jo(t,this.top,a)-a/2,m=jo(t,this.bottom,o)+o/2,h=d=u),e.save(),e.lineWidth=i.width,e.strokeStyle=i.color,e.beginPath(),e.moveTo(h,f),e.lineTo(d,m),e.stroke(),e.restore()}drawLabels(t){if(!this.options.ticks.display)return;const s=this.ctx,r=this._computeLabelArea();r&&Bw(s,r);const i=this.getLabelItems(t);for(const a of i){const o=a.options,u=a.font,h=a.label,d=a.textOffset;hm(s,h,0,d,u,o)}r&&Vw(s)}drawTitle(){const{ctx:t,options:{position:e,title:s,reverse:r}}=this;if(!s.display)return;const i=js(s.font),a=ni(s.padding),o=s.align;let u=i.lineHeight/2;e==="bottom"||e==="center"||Te(e)?(u+=a.bottom,Zn(s.text)&&(u+=i.lineHeight*(s.text.length-1))):u+=a.top;const{titleX:h,titleY:d,maxWidth:f,rotation:m}=jht(this,u,e,o);hm(t,s.text,0,0,i,{color:s.color,maxWidth:f,rotation:m,textAlign:Hht(o,e,r),textBaseline:"middle",translation:[h,d]})}draw(t){this._isVisible()&&(this.drawBackground(),this.drawGrid(t),this.drawBorder(),this.drawTitle(),this.drawLabels(t))}_layers(){const t=this.options,e=t.ticks&&t.ticks.z||0,s=xe(t.grid&&t.grid.z,-1),r=xe(t.border&&t.border.z,0);return!this._isVisible()||this.draw!==fc.prototype.draw?[{z:e,draw:i=>{this.draw(i)}}]:[{z:s,draw:i=>{this.drawBackground(),this.drawGrid(i),this.drawTitle()}},{z:r,draw:()=>{this.drawBorder()}},{z:e,draw:i=>{this.drawLabels(i)}}]}getMatchingVisibleMetas(t){const e=this.chart.getSortedVisibleDatasetMetas(),s=this.axis+"AxisID",r=[];let i,a;for(i=0,a=e.length;i<a;++i){const o=e[i];o[s]===this.id&&(!t||o.type===t)&&r.push(o)}return r}_resolveTickFontOptions(t){const e=this.options.ticks.setContext(this.getContext(t));return js(e.font)}_maxDigits(){const t=this._resolveTickFontOptions(0).lineHeight;return(this.isHorizontal()?this.width:this.height)/t}}class pp{constructor(t,e,s){this.type=t,this.scope=e,this.override=s,this.items=Object.create(null)}isForType(t){return Object.prototype.isPrototypeOf.call(this.type.prototype,t.prototype)}register(t){const e=Object.getPrototypeOf(t);let s;Kht(e)&&(s=this.register(e));const r=this.items,i=t.id,a=this.scope+"."+i;if(!i)throw new Error("class does not have id: "+t);return i in r||(r[i]=t,Xht(t,a,s),this.override&&bn.override(t.id,t.overrides)),a}get(t){return this.items[t]}unregister(t){const e=this.items,s=t.id,r=this.scope;s in e&&delete e[s],r&&s in bn[r]&&(delete bn[r][s],this.override&&delete Cl[s])}}function Xht(n,t,e){const s=pd(Object.create(null),[e?bn.get(e):{},bn.get(t),n.defaults]);bn.set(t,s),n.defaultRoutes&&qht(t,n.defaultRoutes),n.descriptors&&bn.describe(t,n.descriptors)}function qht(n,t){Object.keys(t).forEach(e=>{const s=e.split("."),r=s.pop(),i=[n].concat(s).join("."),a=t[e].split("."),o=a.pop(),u=a.join(".");bn.route(i,r,u,o)})}function Kht(n){return"id"in n&&"defaults"in n}class Yht{constructor(){this.controllers=new pp(rA,"datasets",!0),this.elements=new pp(dc,"elements"),this.plugins=new pp(Object,"plugins"),this.scales=new pp(fc,"scales"),this._typedRegistries=[this.controllers,this.scales,this.elements]}add(...t){this._each("register",t)}remove(...t){this._each("unregister",t)}addControllers(...t){this._each("register",t,this.controllers)}addElements(...t){this._each("register",t,this.elements)}addPlugins(...t){this._each("register",t,this.plugins)}addScales(...t){this._each("register",t,this.scales)}getController(t){return this._get(t,this.controllers,"controller")}getElement(t){return this._get(t,this.elements,"element")}getPlugin(t){return this._get(t,this.plugins,"plugin")}getScale(t){return this._get(t,this.scales,"scale")}removeControllers(...t){this._each("unregister",t,this.controllers)}removeElements(...t){this._each("unregister",t,this.elements)}removePlugins(...t){this._each("unregister",t,this.plugins)}removeScales(...t){this._each("unregister",t,this.scales)}_each(t,e,s){[...e].forEach(r=>{const i=s||this._getRegistryForType(r);s||i.isForType(r)||i===this.plugins&&r.id?this._exec(t,i,r):Oe(r,a=>{const o=s||this._getRegistryForType(a);this._exec(t,o,a)})})}_exec(t,e,s){const r=Lw(t);en(s["before"+r],[],s),e[t](s),en(s["after"+r],[],s)}_getRegistryForType(t){for(let e=0;e<this._typedRegistries.length;e++){const s=this._typedRegistries[e];if(s.isForType(t))return s}return this.plugins}_get(t,e,s){const r=e.get(t);if(r===void 0)throw new Error('"'+t+'" is not a registered '+s+".");return r}}var mi=new Yht;class Qht{constructor(){this._init=[]}notify(t,e,s,r){e==="beforeInit"&&(this._init=this._createDescriptors(t,!0),this._notify(this._init,t,"install"));const i=r?this._descriptors(t).filter(r):this._descriptors(t),a=this._notify(i,t,e,s);return e==="afterDestroy"&&(this._notify(i,t,"stop"),this._notify(this._init,t,"uninstall")),a}_notify(t,e,s,r){r=r||{};for(const i of t){const a=i.plugin,o=a[s],u=[e,r,i.options];if(en(o,u,a)===!1&&r.cancelable)return!1}return!0}invalidate(){Ye(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}_descriptors(t){if(this._cache)return this._cache;const e=this._cache=this._createDescriptors(t);return this._notifyStateChanges(t),e}_createDescriptors(t,e){const s=t&&t.config,r=xe(s.options&&s.options.plugins,{}),i=Zht(s);return r===!1&&!e?[]:tdt(t,i,r,e)}_notifyStateChanges(t){const e=this._oldCache||[],s=this._cache,r=(i,a)=>i.filter(o=>!a.some(u=>o.plugin.id===u.plugin.id));this._notify(r(e,s),t,"stop"),this._notify(r(s,e),t,"start")}}function Zht(n){const t={},e=[],s=Object.keys(mi.plugins.items);for(let i=0;i<s.length;i++)e.push(mi.getPlugin(s[i]));const r=n.plugins||[];for(let i=0;i<r.length;i++){const a=r[i];e.indexOf(a)===-1&&(e.push(a),t[a.id]=!0)}return{plugins:e,localIds:t}}function Jht(n,t){return!t&&n===!1?null:n===!0?{}:n}function tdt(n,{plugins:t,localIds:e},s,r){const i=[],a=n.getContext();for(const o of t){const u=o.id,h=Jht(s[u],r);h!==null&&i.push({plugin:o,options:edt(n.config,{plugin:o,local:e[u]},h,a)})}return i}function edt(n,{plugin:t,local:e},s,r){const i=n.pluginScopeKeys(t),a=n.getOptionScopes(s,i);return e&&t.defaults&&a.push(t.defaults),n.createResolver(a,r,[""],{scriptable:!1,indexable:!1,allKeys:!0})}function D0(n,t){const e=bn.datasets[n]||{};return((t.datasets||{})[n]||{}).indexAxis||t.indexAxis||e.indexAxis||"x"}function ndt(n,t){let e=n;return n==="_index_"?e=t:n==="_value_"&&(e=t==="x"?"y":"x"),e}function sdt(n,t){return n===t?"_index_":"_value_"}function e_(n){if(n==="x"||n==="y"||n==="r")return n}function rdt(n){if(n==="top"||n==="bottom")return"x";if(n==="left"||n==="right")return"y"}function O0(n,...t){if(e_(n))return n;for(const e of t){const s=e.axis||rdt(e.position)||n.length>1&&e_(n[0].toLowerCase());if(s)return s}throw new Error(`Cannot determine type of '${n}' axis. Please provide 'axis' or 'position' option.`)}function n_(n,t,e){if(e[t+"AxisID"]===n)return{axis:t}}function idt(n,t){if(t.data&&t.data.datasets){const e=t.data.datasets.filter(s=>s.xAxisID===n||s.yAxisID===n);if(e.length)return n_(n,"x",e[0])||n_(n,"y",e[0])}return{}}function adt(n,t){const e=Cl[n.type]||{scales:{}},s=t.scales||{},r=D0(n.type,t),i=Object.create(null);return Object.keys(s).forEach(a=>{const o=s[a];if(!Te(o))return console.error(`Invalid scale configuration for scale: ${a}`);if(o._proxy)return console.warn(`Ignoring resolver passed as options for scale: ${a}`);const u=O0(a,o,idt(a,n),bn.scales[o.type]),h=sdt(u,r),d=e.scales||{};i[a]=Wh(Object.create(null),[{axis:u},o,d[u],d[h]])}),n.data.datasets.forEach(a=>{const o=a.type||n.type,u=a.indexAxis||D0(o,t),d=(Cl[o]||{}).scales||{};Object.keys(d).forEach(f=>{const m=ndt(f,u),y=a[m+"AxisID"]||m;i[y]=i[y]||Object.create(null),Wh(i[y],[{axis:m},s[y],d[f]])})}),Object.keys(i).forEach(a=>{const o=i[a];Wh(o,[bn.scales[o.type],bn.scale])}),i}function cA(n){const t=n.options||(n.options={});t.plugins=xe(t.plugins,{}),t.scales=adt(n,t)}function hA(n){return n=n||{},n.datasets=n.datasets||[],n.labels=n.labels||[],n}function odt(n){return n=n||{},n.data=hA(n.data),cA(n),n}const s_=new Map,dA=new Set;function mp(n,t){let e=s_.get(n);return e||(e=t(),s_.set(n,e),dA.add(e)),e}const $h=(n,t,e)=>{const s=lm(t,e);s!==void 0&&n.add(s)};class ldt{constructor(t){this._config=odt(t),this._scopeCache=new Map,this._resolverCache=new Map}get platform(){return this._config.platform}get type(){return this._config.type}set type(t){this._config.type=t}get data(){return this._config.data}set data(t){this._config.data=hA(t)}get options(){return this._config.options}set options(t){this._config.options=t}get plugins(){return this._config.plugins}update(){const t=this._config;this.clearCache(),cA(t)}clearCache(){this._scopeCache.clear(),this._resolverCache.clear()}datasetScopeKeys(t){return mp(t,()=>[[`datasets.${t}`,""]])}datasetAnimationScopeKeys(t,e){return mp(`${t}.transition.${e}`,()=>[[`datasets.${t}.transitions.${e}`,`transitions.${e}`],[`datasets.${t}`,""]])}datasetElementScopeKeys(t,e){return mp(`${t}-${e}`,()=>[[`datasets.${t}.elements.${e}`,`datasets.${t}`,`elements.${e}`,""]])}pluginScopeKeys(t){const e=t.id,s=this.type;return mp(`${s}-plugin-${e}`,()=>[[`plugins.${e}`,...t.additionalOptionScopes||[]]])}_cachedScopes(t,e){const s=this._scopeCache;let r=s.get(t);return(!r||e)&&(r=new Map,s.set(t,r)),r}getOptionScopes(t,e,s){const{options:r,type:i}=this,a=this._cachedScopes(t,s),o=a.get(e);if(o)return o;const u=new Set;e.forEach(d=>{t&&(u.add(t),d.forEach(f=>$h(u,t,f))),d.forEach(f=>$h(u,r,f)),d.forEach(f=>$h(u,Cl[i]||{},f)),d.forEach(f=>$h(u,bn,f)),d.forEach(f=>$h(u,R0,f))});const h=Array.from(u);return h.length===0&&h.push(Object.create(null)),dA.has(e)&&a.set(e,h),h}chartOptionScopes(){const{options:t,type:e}=this;return[t,Cl[e]||{},bn.datasets[e]||{},{type:e},bn,R0]}resolveNamedOptions(t,e,s,r=[""]){const i={$shared:!0},{resolver:a,subPrefixes:o}=r_(this._resolverCache,t,r);let u=a;if(cdt(a,e)){i.$shared=!1,s=so(s)?s():s;const h=this.createResolver(t,s,o);u=qu(a,s,h)}for(const h of e)i[h]=u[h];return i}createResolver(t,e,s=[""],r){const{resolver:i}=r_(this._resolverCache,t,s);return Te(e)?qu(i,e,void 0,r):i}}function r_(n,t,e){let s=n.get(t);s||(s=new Map,n.set(t,s));const r=e.join();let i=s.get(r);return i||(i={resolver:Uw(t,e),subPrefixes:e.filter(o=>!o.toLowerCase().includes("hover"))},s.set(r,i)),i}const udt=n=>Te(n)&&Object.getOwnPropertyNames(n).some(t=>so(n[t]));function cdt(n,t){const{isScriptable:e,isIndexable:s}=q3(n);for(const r of t){const i=e(r),a=s(r),o=(a||i)&&n[r];if(i&&(so(o)||udt(o))||a&&Zn(o))return!0}return!1}var hdt="4.5.0";const ddt=["top","bottom","left","right","chartArea"];function i_(n,t){return n==="top"||n==="bottom"||ddt.indexOf(n)===-1&&t==="x"}function a_(n,t){return function(e,s){return e[n]===s[n]?e[t]-s[t]:e[n]-s[n]}}function o_(n){const t=n.chart,e=t.options.animation;t.notifyPlugins("afterRender"),en(e&&e.onComplete,[n],t)}function fdt(n){const t=n.chart,e=t.options.animation;en(e&&e.onProgress,[n],t)}function fA(n){return Hw()&&typeof n=="string"?n=document.getElementById(n):n&&n.length&&(n=n[0]),n&&n.canvas&&(n=n.canvas),n}const Fp={},l_=n=>{const t=fA(n);return Object.values(Fp).filter(e=>e.canvas===t).pop()};function pdt(n,t,e){const s=Object.keys(n);for(const r of s){const i=+r;if(i>=t){const a=n[r];delete n[r],(e>0||i>t)&&(n[i+e]=a)}}}function mdt(n,t,e,s){return!e||n.type==="mouseout"?null:s?t:n}let Ad=class{static defaults=bn;static instances=Fp;static overrides=Cl;static registry=mi;static version=hdt;static getChart=l_;static register(...t){mi.add(...t),u_()}static unregister(...t){mi.remove(...t),u_()}constructor(t,e){const s=this.config=new ldt(e),r=fA(t),i=l_(r);if(i)throw new Error("Canvas is already in use. Chart with ID '"+i.id+"' must be destroyed before the canvas with ID '"+i.canvas.id+"' can be reused.");const a=s.createResolver(s.chartOptionScopes(),this.getContext());this.platform=new(s.platform||Dht(r)),this.platform.updateConfig(s);const o=this.platform.acquireContext(r,a.aspectRatio),u=o&&o.canvas,h=u&&u.height,d=u&&u.width;if(this.id=yut(),this.ctx=o,this.canvas=u,this.width=d,this.height=h,this._options=a,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new Qht,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=Mut(f=>this.update(f),a.resizeDelay||0),this._dataChanges=[],Fp[this.id]=this,!o||!u){console.error("Failed to create chart: can't acquire context from the given item");return}ji.listen(this,"complete",o_),ji.listen(this,"progress",fdt),this._initialize(),this.attached&&this.update()}get aspectRatio(){const{options:{aspectRatio:t,maintainAspectRatio:e},width:s,height:r,_aspectRatio:i}=this;return Ye(t)?e&&i?i:r?s/r:null:t}get data(){return this.config.data}set data(t){this.config.data=t}get options(){return this._options}set options(t){this.config.options=t}get registry(){return mi}_initialize(){return this.notifyPlugins("beforeInit"),this.options.responsive?this.resize():Ok(this,this.options.devicePixelRatio),this.bindEvents(),this.notifyPlugins("afterInit"),this}clear(){return Ik(this.canvas,this.ctx),this}stop(){return ji.stop(this),this}resize(t,e){ji.running(this)?this._resizeBeforeDraw={width:t,height:e}:this._resize(t,e)}_resize(t,e){const s=this.options,r=this.canvas,i=s.maintainAspectRatio&&this.aspectRatio,a=this.platform.getMaximumSize(r,t,e,i),o=s.devicePixelRatio||this.platform.getDevicePixelRatio(),u=this.width?"resize":"attach";this.width=a.width,this.height=a.height,this._aspectRatio=this.aspectRatio,Ok(this,o,!0)&&(this.notifyPlugins("resize",{size:a}),en(s.onResize,[this,a],this),this.attached&&this._doResize(u)&&this.render())}ensureScalesHaveIDs(){const e=this.options.scales||{};Oe(e,(s,r)=>{s.id=r})}buildOrUpdateScales(){const t=this.options,e=t.scales,s=this.scales,r=Object.keys(s).reduce((a,o)=>(a[o]=!1,a),{});let i=[];e&&(i=i.concat(Object.keys(e).map(a=>{const o=e[a],u=O0(a,o),h=u==="r",d=u==="x";return{options:o,dposition:h?"chartArea":d?"bottom":"left",dtype:h?"radialLinear":d?"category":"linear"}}))),Oe(i,a=>{const o=a.options,u=o.id,h=O0(u,o),d=xe(o.type,a.dtype);(o.position===void 0||i_(o.position,h)!==i_(a.dposition))&&(o.position=a.dposition),r[u]=!0;let f=null;if(u in s&&s[u].type===d)f=s[u];else{const m=mi.getScale(d);f=new m({id:u,type:d,ctx:this.ctx,chart:this}),s[f.id]=f}f.init(o,t)}),Oe(r,(a,o)=>{a||delete s[o]}),Oe(s,a=>{Xa.configure(this,a,a.options),Xa.addBox(this,a)})}_updateMetasets(){const t=this._metasets,e=this.data.datasets.length,s=t.length;if(t.sort((r,i)=>r.index-i.index),s>e){for(let r=e;r<s;++r)this._destroyDatasetMeta(r);t.splice(e,s-e)}this._sortedMetasets=t.slice(0).sort(a_("order","index"))}_removeUnreferencedMetasets(){const{_metasets:t,data:{datasets:e}}=this;t.length>e.length&&delete this._stacks,t.forEach((s,r)=>{e.filter(i=>i===s._dataset).length===0&&this._destroyDatasetMeta(r)})}buildOrUpdateControllers(){const t=[],e=this.data.datasets;let s,r;for(this._removeUnreferencedMetasets(),s=0,r=e.length;s<r;s++){const i=e[s];let a=this.getDatasetMeta(s);const o=i.type||this.config.type;if(a.type&&a.type!==o&&(this._destroyDatasetMeta(s),a=this.getDatasetMeta(s)),a.type=o,a.indexAxis=i.indexAxis||D0(o,this.options),a.order=i.order||0,a.index=s,a.label=""+i.label,a.visible=this.isDatasetVisible(s),a.controller)a.controller.updateIndex(s),a.controller.linkScales();else{const u=mi.getController(o),{datasetElementType:h,dataElementType:d}=bn.datasets[o];Object.assign(u,{dataElementType:mi.getElement(d),datasetElementType:h&&mi.getElement(h)}),a.controller=new u(this,s),t.push(a.controller)}}return this._updateMetasets(),t}_resetElements(){Oe(this.data.datasets,(t,e)=>{this.getDatasetMeta(e).controller.reset()},this)}reset(){this._resetElements(),this.notifyPlugins("reset")}update(t){const e=this.config;e.update();const s=this._options=e.createResolver(e.chartOptionScopes(),this.getContext()),r=this._animationsDisabled=!s.animation;if(this._updateScales(),this._checkEventBindings(),this._updateHiddenIndices(),this._plugins.invalidate(),this.notifyPlugins("beforeUpdate",{mode:t,cancelable:!0})===!1)return;const i=this.buildOrUpdateControllers();this.notifyPlugins("beforeElementsUpdate");let a=0;for(let h=0,d=this.data.datasets.length;h<d;h++){const{controller:f}=this.getDatasetMeta(h),m=!r&&i.indexOf(f)===-1;f.buildOrUpdateElements(m),a=Math.max(+f.getMaxOverflow(),a)}a=this._minPadding=s.layout.autoPadding?a:0,this._updateLayout(a),r||Oe(i,h=>{h.reset()}),this._updateDatasets(t),this.notifyPlugins("afterUpdate",{mode:t}),this._layers.sort(a_("z","_idx"));const{_active:o,_lastEvent:u}=this;u?this._eventHandler(u,!0):o.length&&this._updateHoverStyles(o,o,!0),this.render()}_updateScales(){Oe(this.scales,t=>{Xa.removeBox(this,t)}),this.ensureScalesHaveIDs(),this.buildOrUpdateScales()}_checkEventBindings(){const t=this.options,e=new Set(Object.keys(this._listeners)),s=new Set(t.events);(!wk(e,s)||!!this._responsiveListeners!==t.responsive)&&(this.unbindEvents(),this.bindEvents())}_updateHiddenIndices(){const{_hiddenIndices:t}=this,e=this._getUniformDataChanges()||[];for(const{method:s,start:r,count:i}of e){const a=s==="_removeElements"?-i:i;pdt(t,r,a)}}_getUniformDataChanges(){const t=this._dataChanges;if(!t||!t.length)return;this._dataChanges=[];const e=this.data.datasets.length,s=i=>new Set(t.filter(a=>a[0]===i).map((a,o)=>o+","+a.splice(1).join(","))),r=s(0);for(let i=1;i<e;i++)if(!wk(r,s(i)))return;return Array.from(r).map(i=>i.split(",")).map(i=>({method:i[1],start:+i[2],count:+i[3]}))}_updateLayout(t){if(this.notifyPlugins("beforeLayout",{cancelable:!0})===!1)return;Xa.update(this,this.width,this.height,t);const e=this.chartArea,s=e.width<=0||e.height<=0;this._layers=[],Oe(this.boxes,r=>{s&&r.position==="chartArea"||(r.configure&&r.configure(),this._layers.push(...r._layers()))},this),this._layers.forEach((r,i)=>{r._idx=i}),this.notifyPlugins("afterLayout")}_updateDatasets(t){if(this.notifyPlugins("beforeDatasetsUpdate",{mode:t,cancelable:!0})!==!1){for(let e=0,s=this.data.datasets.length;e<s;++e)this.getDatasetMeta(e).controller.configure();for(let e=0,s=this.data.datasets.length;e<s;++e)this._updateDataset(e,so(t)?t({datasetIndex:e}):t);this.notifyPlugins("afterDatasetsUpdate",{mode:t})}}_updateDataset(t,e){const s=this.getDatasetMeta(t),r={meta:s,index:t,mode:e,cancelable:!0};this.notifyPlugins("beforeDatasetUpdate",r)!==!1&&(s.controller._update(e),r.cancelable=!1,this.notifyPlugins("afterDatasetUpdate",r))}render(){this.notifyPlugins("beforeRender",{cancelable:!0})!==!1&&(ji.has(this)?this.attached&&!ji.running(this)&&ji.start(this):(this.draw(),o_({chart:this})))}draw(){let t;if(this._resizeBeforeDraw){const{width:s,height:r}=this._resizeBeforeDraw;this._resizeBeforeDraw=null,this._resize(s,r)}if(this.clear(),this.width<=0||this.height<=0||this.notifyPlugins("beforeDraw",{cancelable:!0})===!1)return;const e=this._layers;for(t=0;t<e.length&&e[t].z<=0;++t)e[t].draw(this.chartArea);for(this._drawDatasets();t<e.length;++t)e[t].draw(this.chartArea);this.notifyPlugins("afterDraw")}_getSortedDatasetMetas(t){const e=this._sortedMetasets,s=[];let r,i;for(r=0,i=e.length;r<i;++r){const a=e[r];(!t||a.visible)&&s.push(a)}return s}getSortedVisibleDatasetMetas(){return this._getSortedDatasetMetas(!0)}_drawDatasets(){if(this.notifyPlugins("beforeDatasetsDraw",{cancelable:!0})===!1)return;const t=this.getSortedVisibleDatasetMetas();for(let e=t.length-1;e>=0;--e)this._drawDataset(t[e]);this.notifyPlugins("afterDatasetsDraw")}_drawDataset(t){const e=this.ctx,s={meta:t,index:t.index,cancelable:!0},r=Hct(this,t);this.notifyPlugins("beforeDatasetDraw",s)!==!1&&(r&&Bw(e,r),t.controller.draw(),r&&Vw(e),s.cancelable=!1,this.notifyPlugins("afterDatasetDraw",s))}isPointInArea(t){return gd(t,this.chartArea,this._minPadding)}getElementsAtEventForMode(t,e,s,r){const i=dht.modes[e];return typeof i=="function"?i(this,t,s,r):[]}getDatasetMeta(t){const e=this.data.datasets[t],s=this._metasets;let r=s.filter(i=>i&&i._dataset===e).pop();return r||(r={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:e&&e.order||0,index:t,_dataset:e,_parsed:[],_sorted:!1},s.push(r)),r}getContext(){return this.$context||(this.$context=Ol(null,{chart:this,type:"chart"}))}getVisibleDatasetCount(){return this.getSortedVisibleDatasetMetas().length}isDatasetVisible(t){const e=this.data.datasets[t];if(!e)return!1;const s=this.getDatasetMeta(t);return typeof s.hidden=="boolean"?!s.hidden:!e.hidden}setDatasetVisibility(t,e){const s=this.getDatasetMeta(t);s.hidden=!e}toggleDataVisibility(t){this._hiddenIndices[t]=!this._hiddenIndices[t]}getDataVisibility(t){return!this._hiddenIndices[t]}_updateVisibility(t,e,s){const r=s?"show":"hide",i=this.getDatasetMeta(t),a=i.controller._resolveAnimations(void 0,r);um(e)?(i.data[e].hidden=!s,this.update()):(this.setDatasetVisibility(t,s),a.update(i,{visible:s}),this.update(o=>o.datasetIndex===t?r:void 0))}hide(t,e){this._updateVisibility(t,e,!1)}show(t,e){this._updateVisibility(t,e,!0)}_destroyDatasetMeta(t){const e=this._metasets[t];e&&e.controller&&e.controller._destroy(),delete this._metasets[t]}_stop(){let t,e;for(this.stop(),ji.remove(this),t=0,e=this.data.datasets.length;t<e;++t)this._destroyDatasetMeta(t)}destroy(){this.notifyPlugins("beforeDestroy");const{canvas:t,ctx:e}=this;this._stop(),this.config.clearCache(),t&&(this.unbindEvents(),Ik(t,e),this.platform.releaseContext(e),this.canvas=null,this.ctx=null),delete Fp[this.id],this.notifyPlugins("afterDestroy")}toBase64Image(...t){return this.canvas.toDataURL(...t)}bindEvents(){this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}bindUserEvents(){const t=this._listeners,e=this.platform,s=(i,a)=>{e.addEventListener(this,i,a),t[i]=a},r=(i,a,o)=>{i.offsetX=a,i.offsetY=o,this._eventHandler(i)};Oe(this.options.events,i=>s(i,r))}bindResponsiveEvents(){this._responsiveListeners||(this._responsiveListeners={});const t=this._responsiveListeners,e=this.platform,s=(u,h)=>{e.addEventListener(this,u,h),t[u]=h},r=(u,h)=>{t[u]&&(e.removeEventListener(this,u,h),delete t[u])},i=(u,h)=>{this.canvas&&this.resize(u,h)};let a;const o=()=>{r("attach",o),this.attached=!0,this.resize(),s("resize",i),s("detach",a)};a=()=>{this.attached=!1,r("resize",i),this._stop(),this._resize(0,0),s("attach",o)},e.isAttached(this.canvas)?o():a()}unbindEvents(){Oe(this._listeners,(t,e)=>{this.platform.removeEventListener(this,e,t)}),this._listeners={},Oe(this._responsiveListeners,(t,e)=>{this.platform.removeEventListener(this,e,t)}),this._responsiveListeners=void 0}updateHoverStyle(t,e,s){const r=s?"set":"remove";let i,a,o,u;for(e==="dataset"&&(i=this.getDatasetMeta(t[0].datasetIndex),i.controller["_"+r+"DatasetHoverStyle"]()),o=0,u=t.length;o<u;++o){a=t[o];const h=a&&this.getDatasetMeta(a.datasetIndex).controller;h&&h[r+"HoverStyle"](a.element,a.datasetIndex,a.index)}}getActiveElements(){return this._active||[]}setActiveElements(t){const e=this._active||[],s=t.map(({datasetIndex:i,index:a})=>{const o=this.getDatasetMeta(i);if(!o)throw new Error("No dataset found at index "+i);return{datasetIndex:i,element:o.data[a],index:a}});!am(s,e)&&(this._active=s,this._lastEvent=null,this._updateHoverStyles(s,e))}notifyPlugins(t,e,s){return this._plugins.notify(this,t,e,s)}isPluginEnabled(t){return this._plugins._cache.filter(e=>e.plugin.id===t).length===1}_updateHoverStyles(t,e,s){const r=this.options.hover,i=(u,h)=>u.filter(d=>!h.some(f=>d.datasetIndex===f.datasetIndex&&d.index===f.index)),a=i(e,t),o=s?t:i(t,e);a.length&&this.updateHoverStyle(a,r.mode,!1),o.length&&r.mode&&this.updateHoverStyle(o,r.mode,!0)}_eventHandler(t,e){const s={event:t,replay:e,cancelable:!0,inChartArea:this.isPointInArea(t)},r=a=>(a.options.events||this.options.events).includes(t.native.type);if(this.notifyPlugins("beforeEvent",s,r)===!1)return;const i=this._handleEvent(t,e,s.inChartArea);return s.cancelable=!1,this.notifyPlugins("afterEvent",s,r),(i||s.changed)&&this.render(),this}_handleEvent(t,e,s){const{_active:r=[],options:i}=this,a=e,o=this._getActiveElements(t,r,s,a),u=Cut(t),h=mdt(t,this._lastEvent,s,u);s&&(this._lastEvent=null,en(i.onHover,[t,o,this],this),u&&en(i.onClick,[t,o,this],this));const d=!am(o,r);return(d||e)&&(this._active=o,this._updateHoverStyles(o,r,e)),this._lastEvent=h,d}_getActiveElements(t,e,s,r){if(t.type==="mouseout")return[];if(!s)return e;const i=this.options.hover;return this.getElementsAtEventForMode(t,i.mode,i,r)}};function u_(){return Oe(Ad.instances,n=>n._plugins.invalidate())}function pA(n,t,e=t){n.lineCap=xe(e.borderCapStyle,t.borderCapStyle),n.setLineDash(xe(e.borderDash,t.borderDash)),n.lineDashOffset=xe(e.borderDashOffset,t.borderDashOffset),n.lineJoin=xe(e.borderJoinStyle,t.borderJoinStyle),n.lineWidth=xe(e.borderWidth,t.borderWidth),n.strokeStyle=xe(e.borderColor,t.borderColor)}function gdt(n,t,e){n.lineTo(e.x,e.y)}function ydt(n){return n.stepped?Zut:n.tension||n.cubicInterpolationMode==="monotone"?Jut:gdt}function mA(n,t,e={}){const s=n.length,{start:r=0,end:i=s-1}=e,{start:a,end:o}=t,u=Math.max(r,a),h=Math.min(i,o),d=r<a&&i<a||r>o&&i>o;return{count:s,start:u,loop:t.loop,ilen:h<u&&!d?s+h-u:h-u}}function xdt(n,t,e,s){const{points:r,options:i}=t,{count:a,start:o,loop:u,ilen:h}=mA(r,e,s),d=ydt(i);let{move:f=!0,reverse:m}=s||{},y,x,w;for(y=0;y<=h;++y)x=r[(o+(m?h-y:y))%a],!x.skip&&(f?(n.moveTo(x.x,x.y),f=!1):d(n,w,x,m,i.stepped),w=x);return u&&(x=r[(o+(m?h:0))%a],d(n,w,x,m,i.stepped)),!!u}function bdt(n,t,e,s){const r=t.points,{count:i,start:a,ilen:o}=mA(r,e,s),{move:u=!0,reverse:h}=s||{};let d=0,f=0,m,y,x,w,S,C;const k=R=>(a+(h?o-R:R))%i,E=()=>{w!==S&&(n.lineTo(d,S),n.lineTo(d,w),n.lineTo(d,C))};for(u&&(y=r[k(0)],n.moveTo(y.x,y.y)),m=0;m<=o;++m){if(y=r[k(m)],y.skip)continue;const R=y.x,A=y.y,L=R|0;L===x?(A<w?w=A:A>S&&(S=A),d=(f*d+R)/++f):(E(),n.lineTo(R,A),x=L,f=0,w=S=A),C=A}E()}function P0(n){const t=n.options,e=t.borderDash&&t.borderDash.length;return!n._decimated&&!n._loop&&!t.tension&&t.cubicInterpolationMode!=="monotone"&&!t.stepped&&!e?bdt:xdt}function vdt(n){return n.stepped?Act:n.tension||n.cubicInterpolationMode==="monotone"?Dct:Qo}function wdt(n,t,e,s){let r=t._path;r||(r=t._path=new Path2D,t.path(r,e,s)&&r.closePath()),pA(n,t.options),n.stroke(r)}function Sdt(n,t,e,s){const{segments:r,options:i}=t,a=P0(t);for(const o of r)pA(n,i,o.style),n.beginPath(),a(n,t,o,{start:e,end:e+s-1})&&n.closePath(),n.stroke()}const Cdt=typeof Path2D=="function";function $dt(n,t,e,s){Cdt&&!t.options.segment?wdt(n,t,e,s):Sdt(n,t,e,s)}class Tdt extends dc{static id="line";static defaults={borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderWidth:3,capBezierPoints:!0,cubicInterpolationMode:"default",fill:!1,spanGaps:!1,stepped:!1,tension:0};static defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};static descriptors={_scriptable:!0,_indexable:t=>t!=="borderDash"&&t!=="fill"};constructor(t){super(),this.animated=!0,this.options=void 0,this._chart=void 0,this._loop=void 0,this._fullLoop=void 0,this._path=void 0,this._points=void 0,this._segments=void 0,this._decimated=!1,this._pointsUpdated=!1,this._datasetIndex=void 0,t&&Object.assign(this,t)}updateControlPoints(t,e){const s=this.options;if((s.tension||s.cubicInterpolationMode==="monotone")&&!s.stepped&&!this._pointsUpdated){const r=s.spanGaps?this._loop:this._fullLoop;$ct(this._points,s,t,r,e),this._pointsUpdated=!0}}set points(t){this._points=t,delete this._segments,delete this._path,this._pointsUpdated=!1}get points(){return this._points}get segments(){return this._segments||(this._segments=Vct(this,this.options.segment))}first(){const t=this.segments,e=this.points;return t.length&&e[t[0].start]}last(){const t=this.segments,e=this.points,s=t.length;return s&&e[t[s-1].end]}interpolate(t,e){const s=this.options,r=t[e],i=this.points,a=Mct(this,{property:e,start:r,end:r});if(!a.length)return;const o=[],u=vdt(s);let h,d;for(h=0,d=a.length;h<d;++h){const{start:f,end:m}=a[h],y=i[f],x=i[m];if(y===x){o.push(y);continue}const w=Math.abs((r-y[e])/(x[e]-y[e])),S=u(y,x,w,s.stepped);S[e]=t[e],o.push(S)}return o.length===1?o[0]:o}pathSegment(t,e,s){return P0(this)(t,this,e,s)}path(t,e,s){const r=this.segments,i=P0(this);let a=this._loop;e=e||0,s=s||this.points.length-e;for(const o of r)a&=i(t,this,o,{start:e,end:e+s-1});return!!a}draw(t,e,s,r){const i=this.options||{};(this.points||[]).length&&i.borderWidth&&(t.save(),$dt(t,this,s,r),t.restore()),this.animated&&(this._pointsUpdated=!1,this._path=void 0)}}function c_(n,t,e,s){const r=n.options,{[e]:i}=n.getProps([e],s);return Math.abs(t-i)<r.radius+r.hitRadius}class kdt extends dc{static id="point";parsed;skip;stop;static defaults={borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:"circle",radius:3,rotation:0};static defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};constructor(t){super(),this.options=void 0,this.parsed=void 0,this.skip=void 0,this.stop=void 0,t&&Object.assign(this,t)}inRange(t,e,s){const r=this.options,{x:i,y:a}=this.getProps(["x","y"],s);return Math.pow(t-i,2)+Math.pow(e-a,2)<Math.pow(r.hitRadius+r.radius,2)}inXRange(t,e){return c_(this,t,"x",e)}inYRange(t,e){return c_(this,t,"y",e)}getCenterPoint(t){const{x:e,y:s}=this.getProps(["x","y"],t);return{x:e,y:s}}size(t){t=t||this.options||{};let e=t.radius||0;e=Math.max(e,e&&t.hoverRadius||0);const s=e&&t.borderWidth||0;return(e+s)*2}draw(t,e){const s=this.options;this.skip||s.radius<.1||!gd(this,e,this.size(s)/2)||(t.strokeStyle=s.borderColor,t.lineWidth=s.borderWidth,t.fillStyle=s.backgroundColor,I0(t,s,this.x,this.y))}getRange(){const t=this.options||{};return t.radius+t.hitRadius}}const h_=(n,t)=>{let{boxHeight:e=t,boxWidth:s=t}=n;return n.usePointStyle&&(e=Math.min(e,t),s=n.pointStyleWidth||Math.min(s,t)),{boxWidth:s,boxHeight:e,itemHeight:Math.max(t,e)}},_dt=(n,t)=>n!==null&&t!==null&&n.datasetIndex===t.datasetIndex&&n.index===t.index;class d_ extends dc{constructor(t){super(),this._added=!1,this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1,this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this.legendItems=void 0,this.columnSizes=void 0,this.lineWidths=void 0,this.maxHeight=void 0,this.maxWidth=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.height=void 0,this.width=void 0,this._margins=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(t,e,s){this.maxWidth=t,this.maxHeight=e,this._margins=s,this.setDimensions(),this.buildLabels(),this.fit()}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=this._margins.left,this.right=this.width):(this.height=this.maxHeight,this.top=this._margins.top,this.bottom=this.height)}buildLabels(){const t=this.options.labels||{};let e=en(t.generateLabels,[this.chart],this)||[];t.filter&&(e=e.filter(s=>t.filter(s,this.chart.data))),t.sort&&(e=e.sort((s,r)=>t.sort(s,r,this.chart.data))),this.options.reverse&&e.reverse(),this.legendItems=e}fit(){const{options:t,ctx:e}=this;if(!t.display){this.width=this.height=0;return}const s=t.labels,r=js(s.font),i=r.size,a=this._computeTitleHeight(),{boxWidth:o,itemHeight:u}=h_(s,i);let h,d;e.font=r.string,this.isHorizontal()?(h=this.maxWidth,d=this._fitRows(a,i,o,u)+10):(d=this.maxHeight,h=this._fitCols(a,r,o,u)+10),this.width=Math.min(h,t.maxWidth||this.maxWidth),this.height=Math.min(d,t.maxHeight||this.maxHeight)}_fitRows(t,e,s,r){const{ctx:i,maxWidth:a,options:{labels:{padding:o}}}=this,u=this.legendHitBoxes=[],h=this.lineWidths=[0],d=r+o;let f=t;i.textAlign="left",i.textBaseline="middle";let m=-1,y=-d;return this.legendItems.forEach((x,w)=>{const S=s+e/2+i.measureText(x.text).width;(w===0||h[h.length-1]+S+2*o>a)&&(f+=d,h[h.length-(w>0?0:1)]=0,y+=d,m++),u[w]={left:0,top:y,row:m,width:S,height:r},h[h.length-1]+=S+o}),f}_fitCols(t,e,s,r){const{ctx:i,maxHeight:a,options:{labels:{padding:o}}}=this,u=this.legendHitBoxes=[],h=this.columnSizes=[],d=a-t;let f=o,m=0,y=0,x=0,w=0;return this.legendItems.forEach((S,C)=>{const{itemWidth:k,itemHeight:E}=Ndt(s,e,i,S,r);C>0&&y+E+2*o>d&&(f+=m+o,h.push({width:m,height:y}),x+=m+o,w++,m=y=0),u[C]={left:x,top:y,col:w,width:k,height:E},m=Math.max(m,k),y+=E+o}),f+=m,h.push({width:m,height:y}),f}adjustHitBoxes(){if(!this.options.display)return;const t=this._computeTitleHeight(),{legendHitBoxes:e,options:{align:s,labels:{padding:r},rtl:i}}=this,a=Mu(i,this.left,this.width);if(this.isHorizontal()){let o=0,u=lr(s,this.left+r,this.right-this.lineWidths[o]);for(const h of e)o!==h.row&&(o=h.row,u=lr(s,this.left+r,this.right-this.lineWidths[o])),h.top+=this.top+t+r,h.left=a.leftForLtr(a.x(u),h.width),u+=h.width+r}else{let o=0,u=lr(s,this.top+t+r,this.bottom-this.columnSizes[o].height);for(const h of e)h.col!==o&&(o=h.col,u=lr(s,this.top+t+r,this.bottom-this.columnSizes[o].height)),h.top=u,h.left+=this.left+r,h.left=a.leftForLtr(a.x(h.left),h.width),u+=h.height+r}}isHorizontal(){return this.options.position==="top"||this.options.position==="bottom"}draw(){if(this.options.display){const t=this.ctx;Bw(t,this),this._draw(),Vw(t)}}_draw(){const{options:t,columnSizes:e,lineWidths:s,ctx:r}=this,{align:i,labels:a}=t,o=bn.color,u=Mu(t.rtl,this.left,this.width),h=js(a.font),{padding:d}=a,f=h.size,m=f/2;let y;this.drawTitle(),r.textAlign=u.textAlign("left"),r.textBaseline="middle",r.lineWidth=.5,r.font=h.string;const{boxWidth:x,boxHeight:w,itemHeight:S}=h_(a,f),C=function(L,V,B){if(isNaN(x)||x<=0||isNaN(w)||w<0)return;r.save();const z=xe(B.lineWidth,1);if(r.fillStyle=xe(B.fillStyle,o),r.lineCap=xe(B.lineCap,"butt"),r.lineDashOffset=xe(B.lineDashOffset,0),r.lineJoin=xe(B.lineJoin,"miter"),r.lineWidth=z,r.strokeStyle=xe(B.strokeStyle,o),r.setLineDash(xe(B.lineDash,[])),a.usePointStyle){const U={radius:w*Math.SQRT2/2,pointStyle:B.pointStyle,rotation:B.rotation,borderWidth:z},D=u.xPlus(L,x/2),Y=V+m;j3(r,U,D,Y,a.pointStyleWidth&&x)}else{const U=V+Math.max((f-w)/2,0),D=u.leftForLtr(L,x),Y=Xh(B.borderRadius);r.beginPath(),Object.values(Y).some(nt=>nt!==0)?A0(r,{x:D,y:U,w:x,h:w,radius:Y}):r.rect(D,U,x,w),r.fill(),z!==0&&r.stroke()}r.restore()},k=function(L,V,B){hm(r,B.text,L,V+S/2,h,{strikethrough:B.hidden,textAlign:u.textAlign(B.textAlign)})},E=this.isHorizontal(),R=this._computeTitleHeight();E?y={x:lr(i,this.left+d,this.right-s[0]),y:this.top+d+R,line:0}:y={x:this.left+d,y:lr(i,this.top+R+d,this.bottom-e[0].height),line:0},J3(this.ctx,t.textDirection);const A=S+d;this.legendItems.forEach((L,V)=>{r.strokeStyle=L.fontColor,r.fillStyle=L.fontColor;const B=r.measureText(L.text).width,z=u.textAlign(L.textAlign||(L.textAlign=a.textAlign)),U=x+m+B;let D=y.x,Y=y.y;u.setWidth(this.width),E?V>0&&D+U+d>this.right&&(Y=y.y+=A,y.line++,D=y.x=lr(i,this.left+d,this.right-s[y.line])):V>0&&Y+A>this.bottom&&(D=y.x=D+e[y.line].width+d,y.line++,Y=y.y=lr(i,this.top+R+d,this.bottom-e[y.line].height));const nt=u.x(D);if(C(nt,Y,L),D=zut(z,D+x+m,E?D+U:this.right,t.rtl),k(u.x(D),Y,L),E)y.x+=U+d;else if(typeof L.text!="string"){const dt=h.lineHeight;y.y+=gA(L,dt)+d}else y.y+=A}),tA(this.ctx,t.textDirection)}drawTitle(){const t=this.options,e=t.title,s=js(e.font),r=ni(e.padding);if(!e.display)return;const i=Mu(t.rtl,this.left,this.width),a=this.ctx,o=e.position,u=s.size/2,h=r.top+u;let d,f=this.left,m=this.width;if(this.isHorizontal())m=Math.max(...this.lineWidths),d=this.top+h,f=lr(t.align,f,this.right-m);else{const x=this.columnSizes.reduce((w,S)=>Math.max(w,S.height),0);d=h+lr(t.align,this.top,this.bottom-x-t.labels.padding-this._computeTitleHeight())}const y=lr(o,f,f+m);a.textAlign=i.textAlign(W3(o)),a.textBaseline="middle",a.strokeStyle=e.color,a.fillStyle=e.color,a.font=s.string,hm(a,e.text,y,d,s)}_computeTitleHeight(){const t=this.options.title,e=js(t.font),s=ni(t.padding);return t.display?e.lineHeight+s.height:0}_getLegendItemAt(t,e){let s,r,i;if(Fh(t,this.left,this.right)&&Fh(e,this.top,this.bottom)){for(i=this.legendHitBoxes,s=0;s<i.length;++s)if(r=i[s],Fh(t,r.left,r.left+r.width)&&Fh(e,r.top,r.top+r.height))return this.legendItems[s]}return null}handleEvent(t){const e=this.options;if(!Idt(t.type,e))return;const s=this._getLegendItemAt(t.x,t.y);if(t.type==="mousemove"||t.type==="mouseout"){const r=this._hoveredItem,i=_dt(r,s);r&&!i&&en(e.onLeave,[t,r,this],this),this._hoveredItem=s,s&&!i&&en(e.onHover,[t,s,this],this)}else s&&en(e.onClick,[t,s,this],this)}}function Ndt(n,t,e,s,r){const i=Edt(s,n,t,e),a=Rdt(r,s,t.lineHeight);return{itemWidth:i,itemHeight:a}}function Edt(n,t,e,s){let r=n.text;return r&&typeof r!="string"&&(r=r.reduce((i,a)=>i.length>a.length?i:a)),t+e.size/2+s.measureText(r).width}function Rdt(n,t,e){let s=n;return typeof t.text!="string"&&(s=gA(t,e)),s}function gA(n,t){const e=n.text?n.text.length:0;return t*e}function Idt(n,t){return!!((n==="mousemove"||n==="mouseout")&&(t.onHover||t.onLeave)||t.onClick&&(n==="click"||n==="mouseup"))}var Adt={id:"legend",_element:d_,start(n,t,e){const s=n.legend=new d_({ctx:n.ctx,options:e,chart:n});Xa.configure(n,s,e),Xa.addBox(n,s)},stop(n){Xa.removeBox(n,n.legend),delete n.legend},beforeUpdate(n,t,e){const s=n.legend;Xa.configure(n,s,e),s.options=e},afterUpdate(n){const t=n.legend;t.buildLabels(),t.adjustHitBoxes()},afterEvent(n,t){t.replay||n.legend.handleEvent(t.event)},defaults:{display:!0,position:"top",align:"center",fullSize:!0,reverse:!1,weight:1e3,onClick(n,t,e){const s=t.datasetIndex,r=e.chart;r.isDatasetVisible(s)?(r.hide(s),t.hidden=!0):(r.show(s),t.hidden=!1)},onHover:null,onLeave:null,labels:{color:n=>n.chart.options.color,boxWidth:40,padding:10,generateLabels(n){const t=n.data.datasets,{labels:{usePointStyle:e,pointStyle:s,textAlign:r,color:i,useBorderRadius:a,borderRadius:o}}=n.legend.options;return n._getSortedDatasetMetas().map(u=>{const h=u.controller.getStyle(e?0:void 0),d=ni(h.borderWidth);return{text:t[u.index].label,fillStyle:h.backgroundColor,fontColor:i,hidden:!u.visible,lineCap:h.borderCapStyle,lineDash:h.borderDash,lineDashOffset:h.borderDashOffset,lineJoin:h.borderJoinStyle,lineWidth:(d.width+d.height)/4,strokeStyle:h.borderColor,pointStyle:s||h.pointStyle,rotation:h.rotation,textAlign:r||h.textAlign,borderRadius:a&&(o||h.borderRadius),datasetIndex:u.index}},this)}},title:{color:n=>n.chart.options.color,display:!1,position:"center",text:""}},descriptors:{_scriptable:n=>!n.startsWith("on"),labels:{_scriptable:n=>!["generateLabels","filter","sort"].includes(n)}}};const Mh={average(n){if(!n.length)return!1;let t,e,s=new Set,r=0,i=0;for(t=0,e=n.length;t<e;++t){const o=n[t].element;if(o&&o.hasValue()){const u=o.tooltipPosition();s.add(u.x),r+=u.y,++i}}return i===0||s.size===0?!1:{x:[...s].reduce((o,u)=>o+u)/s.size,y:r/i}},nearest(n,t){if(!n.length)return!1;let e=t.x,s=t.y,r=Number.POSITIVE_INFINITY,i,a,o;for(i=0,a=n.length;i<a;++i){const u=n[i].element;if(u&&u.hasValue()){const h=u.getCenterPoint(),d=E0(t,h);d<r&&(r=d,o=u)}}if(o){const u=o.tooltipPosition();e=u.x,s=u.y}return{x:e,y:s}}};function fi(n,t){return t&&(Zn(t)?Array.prototype.push.apply(n,t):n.push(t)),n}function Xi(n){return(typeof n=="string"||n instanceof String)&&n.indexOf(`
`)>-1?n.split(`
`):n}function Ddt(n,t){const{element:e,datasetIndex:s,index:r}=t,i=n.getDatasetMeta(s).controller,{label:a,value:o}=i.getLabelAndValue(r);return{chart:n,label:a,parsed:i.getParsed(r),raw:n.data.datasets[s].data[r],formattedValue:o,dataset:i.getDataset(),dataIndex:r,datasetIndex:s,element:e}}function f_(n,t){const e=n.chart.ctx,{body:s,footer:r,title:i}=n,{boxWidth:a,boxHeight:o}=t,u=js(t.bodyFont),h=js(t.titleFont),d=js(t.footerFont),f=i.length,m=r.length,y=s.length,x=ni(t.padding);let w=x.height,S=0,C=s.reduce((R,A)=>R+A.before.length+A.lines.length+A.after.length,0);if(C+=n.beforeBody.length+n.afterBody.length,f&&(w+=f*h.lineHeight+(f-1)*t.titleSpacing+t.titleMarginBottom),C){const R=t.displayColors?Math.max(o,u.lineHeight):u.lineHeight;w+=y*R+(C-y)*u.lineHeight+(C-1)*t.bodySpacing}m&&(w+=t.footerMarginTop+m*d.lineHeight+(m-1)*t.footerSpacing);let k=0;const E=function(R){S=Math.max(S,e.measureText(R).width+k)};return e.save(),e.font=h.string,Oe(n.title,E),e.font=u.string,Oe(n.beforeBody.concat(n.afterBody),E),k=t.displayColors?a+2+t.boxPadding:0,Oe(s,R=>{Oe(R.before,E),Oe(R.lines,E),Oe(R.after,E)}),k=0,e.font=d.string,Oe(n.footer,E),e.restore(),S+=x.width,{width:S,height:w}}function Odt(n,t){const{y:e,height:s}=t;return e<s/2?"top":e>n.height-s/2?"bottom":"center"}function Pdt(n,t,e,s){const{x:r,width:i}=s,a=e.caretSize+e.caretPadding;if(n==="left"&&r+i+a>t.width||n==="right"&&r-i-a<0)return!0}function Fdt(n,t,e,s){const{x:r,width:i}=e,{width:a,chartArea:{left:o,right:u}}=n;let h="center";return s==="center"?h=r<=(o+u)/2?"left":"right":r<=i/2?h="left":r>=a-i/2&&(h="right"),Pdt(h,n,t,e)&&(h="center"),h}function p_(n,t,e){const s=e.yAlign||t.yAlign||Odt(n,e);return{xAlign:e.xAlign||t.xAlign||Fdt(n,t,e,s),yAlign:s}}function Ldt(n,t){let{x:e,width:s}=n;return t==="right"?e-=s:t==="center"&&(e-=s/2),e}function Mdt(n,t,e){let{y:s,height:r}=n;return t==="top"?s+=e:t==="bottom"?s-=r+e:s-=r/2,s}function m_(n,t,e,s){const{caretSize:r,caretPadding:i,cornerRadius:a}=n,{xAlign:o,yAlign:u}=e,h=r+i,{topLeft:d,topRight:f,bottomLeft:m,bottomRight:y}=Xh(a);let x=Ldt(t,o);const w=Mdt(t,u,h);return u==="center"?o==="left"?x+=h:o==="right"&&(x-=h):o==="left"?x-=Math.max(d,m)+r:o==="right"&&(x+=Math.max(f,y)+r),{x:Ar(x,0,s.width-t.width),y:Ar(w,0,s.height-t.height)}}function gp(n,t,e){const s=ni(e.padding);return t==="center"?n.x+n.width/2:t==="right"?n.x+n.width-s.right:n.x+s.left}function g_(n){return fi([],Xi(n))}function zdt(n,t,e){return Ol(n,{tooltip:t,tooltipItems:e,type:"tooltip"})}function y_(n,t){const e=t&&t.dataset&&t.dataset.tooltip&&t.dataset.tooltip.callbacks;return e?n.override(e):n}const yA={beforeTitle:Hi,title(n){if(n.length>0){const t=n[0],e=t.chart.data.labels,s=e?e.length:0;if(this&&this.options&&this.options.mode==="dataset")return t.dataset.label||"";if(t.label)return t.label;if(s>0&&t.dataIndex<s)return e[t.dataIndex]}return""},afterTitle:Hi,beforeBody:Hi,beforeLabel:Hi,label(n){if(this&&this.options&&this.options.mode==="dataset")return n.label+": "+n.formattedValue||n.formattedValue;let t=n.dataset.label||"";t&&(t+=": ");const e=n.formattedValue;return Ye(e)||(t+=e),t},labelColor(n){const e=n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex);return{borderColor:e.borderColor,backgroundColor:e.backgroundColor,borderWidth:e.borderWidth,borderDash:e.borderDash,borderDashOffset:e.borderDashOffset,borderRadius:0}},labelTextColor(){return this.options.bodyColor},labelPointStyle(n){const e=n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex);return{pointStyle:e.pointStyle,rotation:e.rotation}},afterLabel:Hi,afterBody:Hi,beforeFooter:Hi,footer:Hi,afterFooter:Hi};function Vs(n,t,e,s){const r=n[t].call(e,s);return typeof r>"u"?yA[t].call(e,s):r}class x_ extends dc{static positioners=Mh;constructor(t){super(),this.opacity=0,this._active=[],this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.chart=t.chart,this.options=t.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}initialize(t){this.options=t,this._cachedAnimations=void 0,this.$context=void 0}_resolveAnimations(){const t=this._cachedAnimations;if(t)return t;const e=this.chart,s=this.options.setContext(this.getContext()),r=s.enabled&&e.options.animation&&s.animations,i=new nA(this.chart,r);return r._cacheable&&(this._cachedAnimations=Object.freeze(i)),i}getContext(){return this.$context||(this.$context=zdt(this.chart.getContext(),this,this._tooltipItems))}getTitle(t,e){const{callbacks:s}=e,r=Vs(s,"beforeTitle",this,t),i=Vs(s,"title",this,t),a=Vs(s,"afterTitle",this,t);let o=[];return o=fi(o,Xi(r)),o=fi(o,Xi(i)),o=fi(o,Xi(a)),o}getBeforeBody(t,e){return g_(Vs(e.callbacks,"beforeBody",this,t))}getBody(t,e){const{callbacks:s}=e,r=[];return Oe(t,i=>{const a={before:[],lines:[],after:[]},o=y_(s,i);fi(a.before,Xi(Vs(o,"beforeLabel",this,i))),fi(a.lines,Vs(o,"label",this,i)),fi(a.after,Xi(Vs(o,"afterLabel",this,i))),r.push(a)}),r}getAfterBody(t,e){return g_(Vs(e.callbacks,"afterBody",this,t))}getFooter(t,e){const{callbacks:s}=e,r=Vs(s,"beforeFooter",this,t),i=Vs(s,"footer",this,t),a=Vs(s,"afterFooter",this,t);let o=[];return o=fi(o,Xi(r)),o=fi(o,Xi(i)),o=fi(o,Xi(a)),o}_createItems(t){const e=this._active,s=this.chart.data,r=[],i=[],a=[];let o=[],u,h;for(u=0,h=e.length;u<h;++u)o.push(Ddt(this.chart,e[u]));return t.filter&&(o=o.filter((d,f,m)=>t.filter(d,f,m,s))),t.itemSort&&(o=o.sort((d,f)=>t.itemSort(d,f,s))),Oe(o,d=>{const f=y_(t.callbacks,d);r.push(Vs(f,"labelColor",this,d)),i.push(Vs(f,"labelPointStyle",this,d)),a.push(Vs(f,"labelTextColor",this,d))}),this.labelColors=r,this.labelPointStyles=i,this.labelTextColors=a,this.dataPoints=o,o}update(t,e){const s=this.options.setContext(this.getContext()),r=this._active;let i,a=[];if(!r.length)this.opacity!==0&&(i={opacity:0});else{const o=Mh[s.position].call(this,r,this._eventPosition);a=this._createItems(s),this.title=this.getTitle(a,s),this.beforeBody=this.getBeforeBody(a,s),this.body=this.getBody(a,s),this.afterBody=this.getAfterBody(a,s),this.footer=this.getFooter(a,s);const u=this._size=f_(this,s),h=Object.assign({},o,u),d=p_(this.chart,s,h),f=m_(s,h,d,this.chart);this.xAlign=d.xAlign,this.yAlign=d.yAlign,i={opacity:1,x:f.x,y:f.y,width:u.width,height:u.height,caretX:o.x,caretY:o.y}}this._tooltipItems=a,this.$context=void 0,i&&this._resolveAnimations().update(this,i),t&&s.external&&s.external.call(this,{chart:this.chart,tooltip:this,replay:e})}drawCaret(t,e,s,r){const i=this.getCaretPosition(t,s,r);e.lineTo(i.x1,i.y1),e.lineTo(i.x2,i.y2),e.lineTo(i.x3,i.y3)}getCaretPosition(t,e,s){const{xAlign:r,yAlign:i}=this,{caretSize:a,cornerRadius:o}=s,{topLeft:u,topRight:h,bottomLeft:d,bottomRight:f}=Xh(o),{x:m,y}=t,{width:x,height:w}=e;let S,C,k,E,R,A;return i==="center"?(R=y+w/2,r==="left"?(S=m,C=S-a,E=R+a,A=R-a):(S=m+x,C=S+a,E=R-a,A=R+a),k=S):(r==="left"?C=m+Math.max(u,d)+a:r==="right"?C=m+x-Math.max(h,f)-a:C=this.caretX,i==="top"?(E=y,R=E-a,S=C-a,k=C+a):(E=y+w,R=E+a,S=C+a,k=C-a),A=E),{x1:S,x2:C,x3:k,y1:E,y2:R,y3:A}}drawTitle(t,e,s){const r=this.title,i=r.length;let a,o,u;if(i){const h=Mu(s.rtl,this.x,this.width);for(t.x=gp(this,s.titleAlign,s),e.textAlign=h.textAlign(s.titleAlign),e.textBaseline="middle",a=js(s.titleFont),o=s.titleSpacing,e.fillStyle=s.titleColor,e.font=a.string,u=0;u<i;++u)e.fillText(r[u],h.x(t.x),t.y+a.lineHeight/2),t.y+=a.lineHeight+o,u+1===i&&(t.y+=s.titleMarginBottom-o)}}_drawColorBox(t,e,s,r,i){const a=this.labelColors[s],o=this.labelPointStyles[s],{boxHeight:u,boxWidth:h}=i,d=js(i.bodyFont),f=gp(this,"left",i),m=r.x(f),y=u<d.lineHeight?(d.lineHeight-u)/2:0,x=e.y+y;if(i.usePointStyle){const w={radius:Math.min(h,u)/2,pointStyle:o.pointStyle,rotation:o.rotation,borderWidth:1},S=r.leftForLtr(m,h)+h/2,C=x+u/2;t.strokeStyle=i.multiKeyBackground,t.fillStyle=i.multiKeyBackground,I0(t,w,S,C),t.strokeStyle=a.borderColor,t.fillStyle=a.backgroundColor,I0(t,w,S,C)}else{t.lineWidth=Te(a.borderWidth)?Math.max(...Object.values(a.borderWidth)):a.borderWidth||1,t.strokeStyle=a.borderColor,t.setLineDash(a.borderDash||[]),t.lineDashOffset=a.borderDashOffset||0;const w=r.leftForLtr(m,h),S=r.leftForLtr(r.xPlus(m,1),h-2),C=Xh(a.borderRadius);Object.values(C).some(k=>k!==0)?(t.beginPath(),t.fillStyle=i.multiKeyBackground,A0(t,{x:w,y:x,w:h,h:u,radius:C}),t.fill(),t.stroke(),t.fillStyle=a.backgroundColor,t.beginPath(),A0(t,{x:S,y:x+1,w:h-2,h:u-2,radius:C}),t.fill()):(t.fillStyle=i.multiKeyBackground,t.fillRect(w,x,h,u),t.strokeRect(w,x,h,u),t.fillStyle=a.backgroundColor,t.fillRect(S,x+1,h-2,u-2))}t.fillStyle=this.labelTextColors[s]}drawBody(t,e,s){const{body:r}=this,{bodySpacing:i,bodyAlign:a,displayColors:o,boxHeight:u,boxWidth:h,boxPadding:d}=s,f=js(s.bodyFont);let m=f.lineHeight,y=0;const x=Mu(s.rtl,this.x,this.width),w=function(B){e.fillText(B,x.x(t.x+y),t.y+m/2),t.y+=m+i},S=x.textAlign(a);let C,k,E,R,A,L,V;for(e.textAlign=a,e.textBaseline="middle",e.font=f.string,t.x=gp(this,S,s),e.fillStyle=s.bodyColor,Oe(this.beforeBody,w),y=o&&S!=="right"?a==="center"?h/2+d:h+2+d:0,R=0,L=r.length;R<L;++R){for(C=r[R],k=this.labelTextColors[R],e.fillStyle=k,Oe(C.before,w),E=C.lines,o&&E.length&&(this._drawColorBox(e,t,R,x,s),m=Math.max(f.lineHeight,u)),A=0,V=E.length;A<V;++A)w(E[A]),m=f.lineHeight;Oe(C.after,w)}y=0,m=f.lineHeight,Oe(this.afterBody,w),t.y-=i}drawFooter(t,e,s){const r=this.footer,i=r.length;let a,o;if(i){const u=Mu(s.rtl,this.x,this.width);for(t.x=gp(this,s.footerAlign,s),t.y+=s.footerMarginTop,e.textAlign=u.textAlign(s.footerAlign),e.textBaseline="middle",a=js(s.footerFont),e.fillStyle=s.footerColor,e.font=a.string,o=0;o<i;++o)e.fillText(r[o],u.x(t.x),t.y+a.lineHeight/2),t.y+=a.lineHeight+s.footerSpacing}}drawBackground(t,e,s,r){const{xAlign:i,yAlign:a}=this,{x:o,y:u}=t,{width:h,height:d}=s,{topLeft:f,topRight:m,bottomLeft:y,bottomRight:x}=Xh(r.cornerRadius);e.fillStyle=r.backgroundColor,e.strokeStyle=r.borderColor,e.lineWidth=r.borderWidth,e.beginPath(),e.moveTo(o+f,u),a==="top"&&this.drawCaret(t,e,s,r),e.lineTo(o+h-m,u),e.quadraticCurveTo(o+h,u,o+h,u+m),a==="center"&&i==="right"&&this.drawCaret(t,e,s,r),e.lineTo(o+h,u+d-x),e.quadraticCurveTo(o+h,u+d,o+h-x,u+d),a==="bottom"&&this.drawCaret(t,e,s,r),e.lineTo(o+y,u+d),e.quadraticCurveTo(o,u+d,o,u+d-y),a==="center"&&i==="left"&&this.drawCaret(t,e,s,r),e.lineTo(o,u+f),e.quadraticCurveTo(o,u,o+f,u),e.closePath(),e.fill(),r.borderWidth>0&&e.stroke()}_updateAnimationTarget(t){const e=this.chart,s=this.$animations,r=s&&s.x,i=s&&s.y;if(r||i){const a=Mh[t.position].call(this,this._active,this._eventPosition);if(!a)return;const o=this._size=f_(this,t),u=Object.assign({},a,this._size),h=p_(e,t,u),d=m_(t,u,h,e);(r._to!==d.x||i._to!==d.y)&&(this.xAlign=h.xAlign,this.yAlign=h.yAlign,this.width=o.width,this.height=o.height,this.caretX=a.x,this.caretY=a.y,this._resolveAnimations().update(this,d))}}_willRender(){return!!this.opacity}draw(t){const e=this.options.setContext(this.getContext());let s=this.opacity;if(!s)return;this._updateAnimationTarget(e);const r={width:this.width,height:this.height},i={x:this.x,y:this.y};s=Math.abs(s)<.001?0:s;const a=ni(e.padding),o=this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;e.enabled&&o&&(t.save(),t.globalAlpha=s,this.drawBackground(i,t,r,e),J3(t,e.textDirection),i.y+=a.top,this.drawTitle(i,t,e),this.drawBody(i,t,e),this.drawFooter(i,t,e),tA(t,e.textDirection),t.restore())}getActiveElements(){return this._active||[]}setActiveElements(t,e){const s=this._active,r=t.map(({datasetIndex:o,index:u})=>{const h=this.chart.getDatasetMeta(o);if(!h)throw new Error("Cannot find a dataset at index "+o);return{datasetIndex:o,element:h.data[u],index:u}}),i=!am(s,r),a=this._positionChanged(r,e);(i||a)&&(this._active=r,this._eventPosition=e,this._ignoreReplayEvents=!0,this.update(!0))}handleEvent(t,e,s=!0){if(e&&this._ignoreReplayEvents)return!1;this._ignoreReplayEvents=!1;const r=this.options,i=this._active||[],a=this._getActiveElements(t,i,e,s),o=this._positionChanged(a,t),u=e||!am(a,i)||o;return u&&(this._active=a,(r.enabled||r.external)&&(this._eventPosition={x:t.x,y:t.y},this.update(!0,e))),u}_getActiveElements(t,e,s,r){const i=this.options;if(t.type==="mouseout")return[];if(!r)return e.filter(o=>this.chart.data.datasets[o.datasetIndex]&&this.chart.getDatasetMeta(o.datasetIndex).controller.getParsed(o.index)!==void 0);const a=this.chart.getElementsAtEventForMode(t,i.mode,i,s);return i.reverse&&a.reverse(),a}_positionChanged(t,e){const{caretX:s,caretY:r,options:i}=this,a=Mh[i.position].call(this,t,e);return a!==!1&&(s!==a.x||r!==a.y)}}var Bdt={id:"tooltip",_element:x_,positioners:Mh,afterInit(n,t,e){e&&(n.tooltip=new x_({chart:n,options:e}))},beforeUpdate(n,t,e){n.tooltip&&n.tooltip.initialize(e)},reset(n,t,e){n.tooltip&&n.tooltip.initialize(e)},afterDraw(n){const t=n.tooltip;if(t&&t._willRender()){const e={tooltip:t};if(n.notifyPlugins("beforeTooltipDraw",{...e,cancelable:!0})===!1)return;t.draw(n.ctx),n.notifyPlugins("afterTooltipDraw",e)}},afterEvent(n,t){if(n.tooltip){const e=t.replay;n.tooltip.handleEvent(t.event,e,t.inChartArea)&&(t.changed=!0)}},defaults:{enabled:!0,external:null,position:"average",backgroundColor:"rgba(0,0,0,0.8)",titleColor:"#fff",titleFont:{weight:"bold"},titleSpacing:2,titleMarginBottom:6,titleAlign:"left",bodyColor:"#fff",bodySpacing:2,bodyFont:{},bodyAlign:"left",footerColor:"#fff",footerSpacing:2,footerMarginTop:6,footerFont:{weight:"bold"},footerAlign:"left",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:(n,t)=>t.bodyFont.size,boxWidth:(n,t)=>t.bodyFont.size,multiKeyBackground:"#fff",displayColors:!0,boxPadding:0,borderColor:"rgba(0,0,0,0)",borderWidth:0,animation:{duration:400,easing:"easeOutQuart"},animations:{numbers:{type:"number",properties:["x","y","width","height","caretX","caretY"]},opacity:{easing:"linear",duration:200}},callbacks:yA},defaultRoutes:{bodyFont:"font",footerFont:"font",titleFont:"font"},descriptors:{_scriptable:n=>n!=="filter"&&n!=="itemSort"&&n!=="external",_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:"animation"}},additionalOptionScopes:["interaction"]};const Vdt=(n,t,e,s)=>(typeof t=="string"?(e=n.push(t)-1,s.unshift({index:e,label:t})):isNaN(t)&&(e=null),e);function Udt(n,t,e,s){const r=n.indexOf(t);if(r===-1)return Vdt(n,t,e,s);const i=n.lastIndexOf(t);return r!==i?e:r}const Wdt=(n,t)=>n===null?null:Ar(Math.round(n),0,t);function b_(n){const t=this.getLabels();return n>=0&&n<t.length?t[n]:n}class Gdt extends fc{static id="category";static defaults={ticks:{callback:b_}};constructor(t){super(t),this._startValue=void 0,this._valueRange=0,this._addedLabels=[]}init(t){const e=this._addedLabels;if(e.length){const s=this.getLabels();for(const{index:r,label:i}of e)s[r]===i&&s.splice(r,1);this._addedLabels=[]}super.init(t)}parse(t,e){if(Ye(t))return null;const s=this.getLabels();return e=isFinite(e)&&s[e]===t?e:Udt(s,t,xe(e,t),this._addedLabels),Wdt(e,s.length-1)}determineDataLimits(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let{min:s,max:r}=this.getMinMax(!0);this.options.bounds==="ticks"&&(t||(s=0),e||(r=this.getLabels().length-1)),this.min=s,this.max=r}buildTicks(){const t=this.min,e=this.max,s=this.options.offset,r=[];let i=this.getLabels();i=t===0&&e===i.length-1?i:i.slice(t,e+1),this._valueRange=Math.max(i.length-(s?0:1),1),this._startValue=this.min-(s?.5:0);for(let a=t;a<=e;a++)r.push({value:a});return r}getLabelForValue(t){return b_.call(this,t)}configure(){super.configure(),this.isHorizontal()||(this._reversePixels=!this._reversePixels)}getPixelForValue(t){return typeof t!="number"&&(t=this.parse(t)),t===null?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getValueForPixel(t){return Math.round(this._startValue+this.getDecimalForPixel(t)*this._valueRange)}getBasePixel(){return this.bottom}}function Hdt(n,t){const e=[],{bounds:r,step:i,min:a,max:o,precision:u,count:h,maxTicks:d,maxDigits:f,includeBounds:m}=n,y=i||1,x=d-1,{min:w,max:S}=t,C=!Ye(a),k=!Ye(o),E=!Ye(h),R=(S-w)/(f+1);let A=Ck((S-w)/x/y)*y,L,V,B,z;if(A<1e-14&&!C&&!k)return[{value:w},{value:S}];z=Math.ceil(S/A)-Math.floor(w/A),z>x&&(A=Ck(z*A/x/y)*y),Ye(u)||(L=Math.pow(10,u),A=Math.ceil(A*L)/L),r==="ticks"?(V=Math.floor(w/A)*A,B=Math.ceil(S/A)*A):(V=w,B=S),C&&k&&i&&Nut((o-a)/i,A/1e3)?(z=Math.round(Math.min((o-a)/A,d)),A=(o-a)/z,V=a,B=o):E?(V=C?a:V,B=k?o:B,z=h-1,A=(B-V)/z):(z=(B-V)/A,Gh(z,Math.round(z),A/1e3)?z=Math.round(z):z=Math.ceil(z));const U=Math.max($k(A),$k(V));L=Math.pow(10,Ye(u)?U:u),V=Math.round(V*L)/L,B=Math.round(B*L)/L;let D=0;for(C&&(m&&V!==a?(e.push({value:a}),V<a&&D++,Gh(Math.round((V+D*A)*L)/L,a,v_(a,R,n))&&D++):V<a&&D++);D<z;++D){const Y=Math.round((V+D*A)*L)/L;if(k&&Y>o)break;e.push({value:Y})}return k&&m&&B!==o?e.length&&Gh(e[e.length-1].value,o,v_(o,R,n))?e[e.length-1].value=o:e.push({value:o}):(!k||B===o)&&e.push({value:B}),e}function v_(n,t,{horizontal:e,minRotation:s}){const r=al(s),i=(e?Math.sin(r):Math.cos(r))||.001,a=.75*t*(""+n).length;return Math.min(t/i,a)}class jdt extends fc{constructor(t){super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}parse(t,e){return Ye(t)||(typeof t=="number"||t instanceof Number)&&!isFinite(+t)?null:+t}handleTickRangeOptions(){const{beginAtZero:t}=this.options,{minDefined:e,maxDefined:s}=this.getUserBounds();let{min:r,max:i}=this;const a=u=>r=e?r:u,o=u=>i=s?i:u;if(t){const u=Xu(r),h=Xu(i);u<0&&h<0?o(0):u>0&&h>0&&a(0)}if(r===i){let u=i===0?1:Math.abs(i*.05);o(i+u),t||a(r-u)}this.min=r,this.max=i}getTickLimit(){const t=this.options.ticks;let{maxTicksLimit:e,stepSize:s}=t,r;return s?(r=Math.ceil(this.max/s)-Math.floor(this.min/s)+1,r>1e3&&(console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${r} ticks. Limiting to 1000.`),r=1e3)):(r=this.computeTickLimit(),e=e||11),e&&(r=Math.min(e,r)),r}computeTickLimit(){return Number.POSITIVE_INFINITY}buildTicks(){const t=this.options,e=t.ticks;let s=this.getTickLimit();s=Math.max(2,s);const r={maxTicks:s,bounds:t.bounds,min:t.min,max:t.max,precision:e.precision,step:e.stepSize,count:e.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:e.minRotation||0,includeBounds:e.includeBounds!==!1},i=this._range||this,a=Hdt(r,i);return t.bounds==="ticks"&&Eut(a,this,"value"),t.reverse?(a.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),a}configure(){const t=this.ticks;let e=this.min,s=this.max;if(super.configure(),this.options.offset&&t.length){const r=(s-e)/Math.max(t.length-1,1)/2;e-=r,s+=r}this._startValue=e,this._endValue=s,this._valueRange=s-e}getLabelForValue(t){return G3(t,this.chart.options.locale,this.options.ticks.format)}}class Xdt extends jdt{static id="linear";static defaults={ticks:{callback:H3.formatters.numeric}};determineDataLimits(){const{min:t,max:e}=this.getMinMax(!0);this.min=Lr(t)?t:0,this.max=Lr(e)?e:1,this.handleTickRangeOptions()}computeTickLimit(){const t=this.isHorizontal(),e=t?this.width:this.height,s=al(this.options.ticks.minRotation),r=(t?Math.sin(s):Math.cos(s))||.001,i=this._resolveTickFontOptions(0);return Math.ceil(e/Math.min(40,i.lineHeight/r))}getPixelForValue(t){return t===null?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getValueForPixel(t){return this._startValue+this.getDecimalForPixel(t)*this._valueRange}}const Wm={millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},Hs=Object.keys(Wm);function w_(n,t){return n-t}function S_(n,t){if(Ye(t))return null;const e=n._adapter,{parser:s,round:r,isoWeekday:i}=n._parseOpts;let a=t;return typeof s=="function"&&(a=s(a)),Lr(a)||(a=typeof s=="string"?e.parse(a,s):e.parse(a)),a===null?null:(r&&(a=r==="week"&&(md(i)||i===!0)?e.startOf(a,"isoWeek",i):e.startOf(a,r)),+a)}function C_(n,t,e,s){const r=Hs.length;for(let i=Hs.indexOf(n);i<r-1;++i){const a=Wm[Hs[i]],o=a.steps?a.steps:Number.MAX_SAFE_INTEGER;if(a.common&&Math.ceil((e-t)/(o*a.size))<=s)return Hs[i]}return Hs[r-1]}function qdt(n,t,e,s,r){for(let i=Hs.length-1;i>=Hs.indexOf(e);i--){const a=Hs[i];if(Wm[a].common&&n._adapter.diff(r,s,a)>=t-1)return a}return Hs[e?Hs.indexOf(e):0]}function Kdt(n){for(let t=Hs.indexOf(n)+1,e=Hs.length;t<e;++t)if(Wm[Hs[t]].common)return Hs[t]}function $_(n,t,e){if(!e)n[t]=!0;else if(e.length){const{lo:s,hi:r}=Mw(e,t),i=e[s]>=t?e[s]:e[r];n[i]=!0}}function Ydt(n,t,e,s){const r=n._adapter,i=+r.startOf(t[0].value,s),a=t[t.length-1].value;let o,u;for(o=i;o<=a;o=+r.add(o,1,s))u=e[o],u>=0&&(t[u].major=!0);return t}function T_(n,t,e){const s=[],r={},i=t.length;let a,o;for(a=0;a<i;++a)o=t[a],r[o]=a,s.push({value:o,major:!1});return i===0||!e?s:Ydt(n,s,r,e)}class k_ extends fc{static id="time";static defaults={bounds:"data",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{}},ticks:{source:"auto",callback:!1,major:{enabled:!1}}};constructor(t){super(t),this._cache={data:[],labels:[],all:[]},this._unit="day",this._majorUnit=void 0,this._offsets={},this._normalized=!1,this._parseOpts=void 0}init(t,e={}){const s=t.time||(t.time={}),r=this._adapter=new oht._date(t.adapters.date);r.init(e),Wh(s.displayFormats,r.formats()),this._parseOpts={parser:s.parser,round:s.round,isoWeekday:s.isoWeekday},super.init(t),this._normalized=e.normalized}parse(t,e){return t===void 0?null:S_(this,t)}beforeLayout(){super.beforeLayout(),this._cache={data:[],labels:[],all:[]}}determineDataLimits(){const t=this.options,e=this._adapter,s=t.time.unit||"day";let{min:r,max:i,minDefined:a,maxDefined:o}=this.getUserBounds();function u(h){!a&&!isNaN(h.min)&&(r=Math.min(r,h.min)),!o&&!isNaN(h.max)&&(i=Math.max(i,h.max))}(!a||!o)&&(u(this._getLabelBounds()),(t.bounds!=="ticks"||t.ticks.source!=="labels")&&u(this.getMinMax(!1))),r=Lr(r)&&!isNaN(r)?r:+e.startOf(Date.now(),s),i=Lr(i)&&!isNaN(i)?i:+e.endOf(Date.now(),s)+1,this.min=Math.min(r,i-1),this.max=Math.max(r+1,i)}_getLabelBounds(){const t=this.getLabelTimestamps();let e=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY;return t.length&&(e=t[0],s=t[t.length-1]),{min:e,max:s}}buildTicks(){const t=this.options,e=t.time,s=t.ticks,r=s.source==="labels"?this.getLabelTimestamps():this._generate();t.bounds==="ticks"&&r.length&&(this.min=this._userMin||r[0],this.max=this._userMax||r[r.length-1]);const i=this.min,a=this.max,o=Put(r,i,a);return this._unit=e.unit||(s.autoSkip?C_(e.minUnit,this.min,this.max,this._getLabelCapacity(i)):qdt(this,o.length,e.minUnit,this.min,this.max)),this._majorUnit=!s.major.enabled||this._unit==="year"?void 0:Kdt(this._unit),this.initOffsets(r),t.reverse&&o.reverse(),T_(this,o,this._majorUnit)}afterAutoSkip(){this.options.offsetAfterAutoskip&&this.initOffsets(this.ticks.map(t=>+t.value))}initOffsets(t=[]){let e=0,s=0,r,i;this.options.offset&&t.length&&(r=this.getDecimalForValue(t[0]),t.length===1?e=1-r:e=(this.getDecimalForValue(t[1])-r)/2,i=this.getDecimalForValue(t[t.length-1]),t.length===1?s=i:s=(i-this.getDecimalForValue(t[t.length-2]))/2);const a=t.length<3?.5:.25;e=Ar(e,0,a),s=Ar(s,0,a),this._offsets={start:e,end:s,factor:1/(e+1+s)}}_generate(){const t=this._adapter,e=this.min,s=this.max,r=this.options,i=r.time,a=i.unit||C_(i.minUnit,e,s,this._getLabelCapacity(e)),o=xe(r.ticks.stepSize,1),u=a==="week"?i.isoWeekday:!1,h=md(u)||u===!0,d={};let f=e,m,y;if(h&&(f=+t.startOf(f,"isoWeek",u)),f=+t.startOf(f,h?"day":a),t.diff(s,e,a)>1e5*o)throw new Error(e+" and "+s+" are too far apart with stepSize of "+o+" "+a);const x=r.ticks.source==="data"&&this.getDataTimestamps();for(m=f,y=0;m<s;m=+t.add(m,o,a),y++)$_(d,m,x);return(m===s||r.bounds==="ticks"||y===1)&&$_(d,m,x),Object.keys(d).sort(w_).map(w=>+w)}getLabelForValue(t){const e=this._adapter,s=this.options.time;return s.tooltipFormat?e.format(t,s.tooltipFormat):e.format(t,s.displayFormats.datetime)}format(t,e){const r=this.options.time.displayFormats,i=this._unit,a=e||r[i];return this._adapter.format(t,a)}_tickFormatFunction(t,e,s,r){const i=this.options,a=i.ticks.callback;if(a)return en(a,[t,e,s],this);const o=i.time.displayFormats,u=this._unit,h=this._majorUnit,d=u&&o[u],f=h&&o[h],m=s[e],y=h&&f&&m&&m.major;return this._adapter.format(t,r||(y?f:d))}generateTickLabels(t){let e,s,r;for(e=0,s=t.length;e<s;++e)r=t[e],r.label=this._tickFormatFunction(r.value,e,t)}getDecimalForValue(t){return t===null?NaN:(t-this.min)/(this.max-this.min)}getPixelForValue(t){const e=this._offsets,s=this.getDecimalForValue(t);return this.getPixelForDecimal((e.start+s)*e.factor)}getValueForPixel(t){const e=this._offsets,s=this.getDecimalForPixel(t)/e.factor-e.end;return this.min+s*(this.max-this.min)}_getLabelSize(t){const e=this.options.ticks,s=this.ctx.measureText(t).width,r=al(this.isHorizontal()?e.maxRotation:e.minRotation),i=Math.cos(r),a=Math.sin(r),o=this._resolveTickFontOptions(0).size;return{w:s*i+o*a,h:s*a+o*i}}_getLabelCapacity(t){const e=this.options.time,s=e.displayFormats,r=s[e.unit]||s.millisecond,i=this._tickFormatFunction(t,0,T_(this,[t],this._majorUnit),r),a=this._getLabelSize(i),o=Math.floor(this.isHorizontal()?this.width/a.w:this.height/a.h)-1;return o>0?o:1}getDataTimestamps(){let t=this._cache.data||[],e,s;if(t.length)return t;const r=this.getMatchingVisibleMetas();if(this._normalized&&r.length)return this._cache.data=r[0].controller.getAllParsedValues(this);for(e=0,s=r.length;e<s;++e)t=t.concat(r[e].controller.getAllParsedValues(this));return this._cache.data=this.normalize(t)}getLabelTimestamps(){const t=this._cache.labels||[];let e,s;if(t.length)return t;const r=this.getLabels();for(e=0,s=r.length;e<s;++e)t.push(S_(this,r[e]));return this._cache.labels=this._normalized?t:this.normalize(t)}normalize(t){return Lut(t.sort(w_))}}function yp(n,t,e){let s=0,r=n.length-1,i,a,o,u;e?(t>=n[s].pos&&t<=n[r].pos&&({lo:s,hi:r}=ol(n,"pos",t)),{pos:i,time:o}=n[s],{pos:a,time:u}=n[r]):(t>=n[s].time&&t<=n[r].time&&({lo:s,hi:r}=ol(n,"time",t)),{time:i,pos:o}=n[s],{time:a,pos:u}=n[r]);const h=a-i;return h?o+(u-o)*(t-i)/h:o}class gpt extends k_{static id="timeseries";static defaults=k_.defaults;constructor(t){super(t),this._table=[],this._minPos=void 0,this._tableRange=void 0}initOffsets(){const t=this._getTimestampsForTable(),e=this._table=this.buildLookupTable(t);this._minPos=yp(e,this.min),this._tableRange=yp(e,this.max)-this._minPos,super.initOffsets(t)}buildLookupTable(t){const{min:e,max:s}=this,r=[],i=[];let a,o,u,h,d;for(a=0,o=t.length;a<o;++a)h=t[a],h>=e&&h<=s&&r.push(h);if(r.length<2)return[{time:e,pos:0},{time:s,pos:1}];for(a=0,o=r.length;a<o;++a)d=r[a+1],u=r[a-1],h=r[a],Math.round((d+u)/2)!==h&&i.push({time:h,pos:a/(o-1)});return i}_generate(){const t=this.min,e=this.max;let s=super.getDataTimestamps();return(!s.includes(t)||!s.length)&&s.splice(0,0,t),(!s.includes(e)||s.length===1)&&s.push(e),s.sort((r,i)=>r-i)}_getTimestampsForTable(){let t=this._cache.all||[];if(t.length)return t;const e=this.getDataTimestamps(),s=this.getLabelTimestamps();return e.length&&s.length?t=this.normalize(e.concat(s)):t=e.length?e:s,t=this._cache.all=t,t}getDecimalForValue(t){return(yp(this._table,t)-this._minPos)/this._tableRange}getValueForPixel(t){const e=this._offsets,s=this.getDecimalForPixel(t)/e.factor-e.end;return yp(this._table,s*this._tableRange+this._minPos,!0)}}const xA="label";function __(n,t){typeof n=="function"?n(t):n&&(n.current=t)}function Qdt(n,t){const e=n.options;e&&t&&Object.assign(e,t)}function bA(n,t){n.labels=t}function vA(n,t){let e=arguments.length>2&&arguments[2]!==void 0?arguments[2]:xA;const s=[];n.datasets=t.map(r=>{const i=n.datasets.find(a=>a[e]===r[e]);return!i||!r.data||s.includes(i)?{...r}:(s.push(i),Object.assign(i,r),i)})}function Zdt(n){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:xA;const e={labels:[],datasets:[]};return bA(e,n.labels),vA(e,n.datasets,t),e}function Jdt(n,t){const{height:e=150,width:s=300,redraw:r=!1,datasetIdKey:i,type:a,data:o,options:u,plugins:h=[],fallbackContent:d,updateMode:f,...m}=n,y=Ut.useRef(null),x=Ut.useRef(null),w=()=>{y.current&&(x.current=new Ad(y.current,{type:a,data:Zdt(o,i),options:u&&{...u},plugins:h}),__(t,x.current))},S=()=>{__(t,null),x.current&&(x.current.destroy(),x.current=null)};return Ut.useEffect(()=>{!r&&x.current&&u&&Qdt(x.current,u)},[r,u]),Ut.useEffect(()=>{!r&&x.current&&bA(x.current.config.data,o.labels)},[r,o.labels]),Ut.useEffect(()=>{!r&&x.current&&o.datasets&&vA(x.current.config.data,o.datasets,i)},[r,o.datasets]),Ut.useEffect(()=>{x.current&&(r?(S(),setTimeout(w)):x.current.update(f))},[r,u,o.labels,o.datasets,f]),Ut.useEffect(()=>{x.current&&(S(),setTimeout(w))},[a]),Ut.useEffect(()=>(w(),()=>S()),[]),P_.createElement("canvas",{ref:y,role:"img",height:e,width:s,...m},d)}const tft=Ut.forwardRef(Jdt);function eft(n,t){return Ad.register(t),Ut.forwardRef((e,s)=>P_.createElement(tft,{...e,ref:s,type:n}))}const N_=eft("line",aht);Ad.register(Tdt,kdt,Xdt,Gdt,Adt,Bdt);Ad.defaults.color="#222";const nft=[["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["left_hip","left_knee"],["left_knee","left_ankle"],["right_hip","right_knee"],["right_knee","right_ankle"],["left_shoulder","right_shoulder"],["left_hip","right_hip"],["left_shoulder","left_hip"],["right_shoulder","right_hip"]],Rr={kneeL:"#e53935",kneeR:"#1e88e5",hipL:"#43a047",hipR:"#fb8c00",trunk:"#8e24aa"};function E_(n,t){return{x:(n.x+t.x)/2,y:(n.y+t.y)/2,score:Math.min(n.score??1,t.score??1)}}function Th(n,t,e){const s={x:n.x-t.x,y:n.y-t.y},r={x:e.x-t.x,y:e.y-t.y},i=s.x*r.x+s.y*r.y,a=Math.hypot(s.x,s.y)||1e-6,o=Math.hypot(r.x,r.y)||1e-6,u=Math.max(-1,Math.min(1,i/(a*o)));return Math.acos(u)*180/Math.PI}function kh(n,t,e=5){for(t!=null&&isFinite(t)&&n.push(t);n.length>e;)n.shift();return n.length?n.reduce((s,r)=>s+r,0)/n.length:null}function sft(n,t){const e=Object.fromEntries(t.map(s=>[s.name,s]));n.save(),n.lineWidth=3,n.strokeStyle="rgba(0,0,0,0.9)",n.fillStyle="rgba(0,0,0,0.9)",t.forEach(s=>{s.score!=null&&s.score>.3&&(n.beginPath(),n.arc(s.x,s.y,4,0,2*Math.PI),n.fill())}),nft.forEach(([s,r])=>{const i=e[s],a=e[r];i?.score>.3&&a?.score>.3&&(n.beginPath(),n.moveTo(i.x,i.y),n.lineTo(a.x,a.y),n.stroke())}),n.restore()}function rft(){const n=Ut.useRef(null),t=Ut.useRef(null),e=Ut.useRef(null),s=Ut.useRef(null),r=Ut.useRef(null),[i,a]=Ut.useState({kneeL:!0,kneeR:!0,hipL:!1,hipR:!1,trunk:!1}),[o,u]=Ut.useState(!0),[h,d]=Ut.useState(null),[f,m]=Ut.useState(null),[y,x]=Ut.useState({}),[w,S]=Ut.useState(null),[C,k]=Ut.useState(null),[E,R]=Ut.useState(0),[A,L]=Ut.useState(!0),[V,B]=Ut.useState(!1),[z,U]=Ut.useState(1),D=Ut.useRef(!1),[Y,nt]=Ut.useState(!0),dt=Ut.useRef(0),at=Ut.useRef(null),K=Ut.useRef([]),ct=Ut.useRef([]),yt=Ut.useRef([]),$t=Ut.useRef([]),H=Ut.useRef([]),[ut,xt]=Ut.useState(!1),bt=Ut.useRef(!1);Ut.useEffect(()=>{bt.current=ut},[ut]);const _t=Ut.useRef([]),Kt=Ut.useRef(0),Mt=Ut.useRef(0),Un=100,[ve,Zs]=Ut.useState(!0),[Vr,yr]=Ut.useState(null),[fa,je]=Ut.useState(!1),[on,co]=Ut.useState(null);Ut.useEffect(()=>((async()=>(await nO(()=>import("./index-_26OAzIF.js"),[]),await qO("webgl"),await KO(),s.current=await FQ(vi.MoveNet,{modelType:LQ.modelType.SINGLEPOSE_LIGHTNING}),console.log("✅ Detector ready")))(),()=>ho()),[]),Ut.useEffect(()=>{const St=()=>{document.hidden?(D.current=!1,cancelAnimationFrame(r.current)):(A||t.current?.src)&&s.current&&Ti(A?n.current:t.current)};return document.addEventListener("visibilitychange",St),()=>document.removeEventListener("visibilitychange",St)},[A]);const pc=async()=>{L(!0);const St=n.current,It=async Xe=>{try{return await navigator.mediaDevices.getUserMedia(Xe)}catch(ge){return console.warn("getUserMedia failed:",ge?.name||ge),null}};let Wt=await It({video:{facingMode:{ideal:"environment"},width:{ideal:960},height:{ideal:540}},audio:!1});if(Wt||(Wt=await It({video:{facingMode:{ideal:"user"},width:{ideal:960},height:{ideal:540}},audio:!1})),Wt||(Wt=await It({video:!0,audio:!1})),!Wt){alert("カメラにアクセスできませんでした。まずは『動画ファイル読込』で確認してください。");return}St.srcObject=Wt,St.onloadedmetadata=async()=>{await St.play(),B(!0),Ti(St)}},gs=async St=>{L(!1);const It=St.target.files?.[0];if(!It)return;const Wt=t.current;Wt.src=URL.createObjectURL(It),Wt.muted=!0,Wt.playsInline=!0,Wt.playbackRate=z,Wt.onloadedmetadata=async()=>{await Wt.play(),B(!0),Ti(Wt)}},ho=()=>{D.current=!1,cancelAnimationFrame(r.current),B(!1);const St=n.current;St?.srcObject&&(St.srcObject.getTracks().forEach(It=>It.stop()),St.srcObject=null)},Ti=St=>{if(!s.current)return;D.current=!0;const It=e.current,Wt=It.getContext("2d"),Xe=async()=>{if(D.current){if(St.readyState<2){r.current=requestAnimationFrame(Xe);return}(It.width!==St.videoWidth||It.height!==St.videoHeight)&&(It.width=St.videoWidth||960,It.height=St.videoHeight||540),Wt.clearRect(0,0,It.width,It.height),Wt.drawImage(St,0,0,It.width,It.height);try{const ge=performance.now(),We=Y?100:33,we=ge-dt.current>=We;at.current||(at.current=document.createElement("canvas"));const nn=at.current,Wn=Y?.35:.5;nn.width=Math.max(160,Math.floor(It.width*Wn)),nn.height=Math.max(120,Math.floor(It.height*Wn)),nn.getContext("2d").drawImage(St,0,0,nn.width,nn.height);let Dn=[];if(we&&(Dn=await s.current.estimatePoses(nn,{maxPoses:1,flipHorizontal:!1}),dt.current=ge),Dn[0]?.keypoints?.length){sft(Wt,Dn[0].keypoints);const Se=Object.fromEntries(Dn[0].keypoints.map(Je=>[Je.name,Je])),ke=Se.left_hip,Gn=Se.left_knee,Is=Se.left_ankle,ys=Se.right_hip,ss=Se.right_knee,te=Se.right_ankle,Hn=Se.left_shoulder,_e=Se.right_shoulder;if([ke,Gn,Is,ys,ss,te,Hn,_e].every(Je=>Je?.score>.3)){const Je=E_(Hn,_e),wn=E_(ke,ys),Js=Th(ke,Gn,Is),Fl=Th(ys,ss,te),tn=Th(Je,ke,Gn),xs=Th(Je,ys,ss),Gr=Th(Je,wn,{x:wn.x,y:wn.y-100}),ii=kh(K.current,Js,5),rs=kh(ct.current,Fl,5),bs=kh(yt.current,tn,5),vs=kh($t.current,xs,5),ws=kh(H.current,Gr,5),sn=ii!=null&&rs!=null?Math.abs(ii-rs):null,_i=bs!=null&&vs!=null?Math.abs(bs-vs):null;Wt.save(),Wt.fillStyle="rgba(255,255,255,0.88)",Wt.fillRect(10,10,300,112),Wt.fillStyle="#111",Wt.font="16px system-ui, sans-serif";const As=jn=>jn==null?"-":jn.toFixed(1);if(Wt.fillText(`左膝: ${As(ii)}°   右膝: ${As(rs)}°   差: ${As(sn)}°`,20,36),Wt.fillText(`左股: ${As(bs)}°    右股: ${As(vs)}°    差: ${As(_i)}°`,20,58),Wt.fillText(`体幹前傾: ${As(ws)}°`,20,82),Wt.restore(),bt.current){const jn=performance.now();if(jn-Mt.current>=Un){const Sn=(jn-Kt.current)/1e3;_t.current.push({t:+Sn.toFixed(2),kneeL:ii,kneeR:rs,hipL:bs,hipR:vs,trunk:ws,dKnee:sn,dHip:_i}),Mt.current=jn,R(Ds=>Ds+1)}}}}}catch(ge){console.warn("estimatePoses error:",ge?.message||ge)}r.current=requestAnimationFrame(Xe)}};Xe()},fo=()=>{const St=t.current;St&&(St.paused?(St.play(),B(!0)):(St.pause(),B(!1)))},ki=()=>{const St=t.current;St&&(St.currentTime=0,St.play(),B(!0))},po=St=>{U(St);const It=t.current;It&&(It.playbackRate=St)},pa=St=>{if(!_t.current.length){alert("記録データがありません。先に『記録開始 → 停止』してください。");return}const It=_t.current.map(Wt=>({...Wt}));St==="ref"&&S(It),St==="cmp"&&k(It)},Ur=()=>{xt(St=>{const It=!St;return It&&(_t.current=[],Kt.current=performance.now(),Mt.current=0,R(Wt=>Wt+1)),It})},Pl=()=>{_t.current=[],Kt.current=0,Mt.current=0,R(St=>St+1)},xr=()=>{const St=[["t(s)","kneeL","kneeR","hipL","hipR","trunk","dKnee","dHip"]];for(const We of _t.current)St.push([We.t,Ze(We.kneeL),Ze(We.kneeR),Ze(We.hipL),Ze(We.hipR),Ze(We.trunk),Ze(We.dKnee),Ze(We.dHip)]);const It=St.map(We=>We.join(",")).join(`
`),Wt=new Blob([It],{type:"text/csv;charset=utf-8;"}),Xe=URL.createObjectURL(Wt),ge=document.createElement("a");ge.href=Xe,ge.download=`soralab_form_${Date.now()}.csv`,document.body.appendChild(ge),ge.click(),ge.remove(),URL.revokeObjectURL(Xe)},Ze=St=>St==null?"":St.toFixed(3),br=Ut.useMemo(()=>{const St=_t.current;return{labels:St.map(It=>It.t),datasets:[{label:"左膝角度 (°)",data:St.map(It=>It.kneeL??null),borderWidth:2,pointRadius:0,borderColor:Rr.kneeL,backgroundColor:Rr.kneeL},{label:"右膝角度 (°)",data:St.map(It=>It.kneeR??null),borderWidth:2,pointRadius:0,borderColor:Rr.kneeR,backgroundColor:Rr.kneeR},{label:"左股関節角度 (°)",data:St.map(It=>It.hipL??null),borderWidth:2,pointRadius:0,borderColor:Rr.hipL,backgroundColor:Rr.hipL},{label:"右股関節角度 (°)",data:St.map(It=>It.hipR??null),borderWidth:2,pointRadius:0,borderColor:Rr.hipR,backgroundColor:Rr.hipR},{label:"体幹前傾 (°)",data:St.map(It=>It.trunk??null),borderWidth:2,pointRadius:0,borderColor:Rr.trunk,backgroundColor:Rr.trunk}]}},[E]),An={responsive:!0,maintainAspectRatio:!1,animation:!1,scales:{x:{title:{display:!0,text:"時間 (秒)"},grid:{color:"#eee"},ticks:{color:"#333"}},y:{title:{display:!0,text:"角度 (°)"},grid:{color:"#eee"},ticks:{color:"#333"}}},plugins:{legend:{position:"top",labels:{usePointStyle:!0,boxWidth:10}},tooltip:{callbacks:{label:St=>`${St.dataset.label}: ${St.formattedValue}°`}}}},mc=Ut.useCallback(()=>{if(!w||!C)return;const St=Object.keys(i).filter(ge=>i[ge]),It={labels:[],datasets:[]},Wt={},Xe={mode:o?"cycle":"time"};if(o){const ge=w.map(we=>we.t),We=C.map(we=>we.t);for(const we of St){const nn=w.map(te=>te[we]??null).filter(te=>te!=null),Wn=C.map(te=>te[we]??null).filter(te=>te!=null);if(!nn.length||!Wn.length)continue;const Wr=R_(ge,nn,{prominence:5,minGapSec:.3}),Dn=R_(We,Wn,{prominence:5,minGapSec:.3}),Se=I_(ge,nn,Wr),ke=I_(We,Wn,Dn);if(!(Se.length&&ke.length))continue;const Gn=Se[0].normT.length,Is=Array(Gn).fill(0),ys=Array(Gn).fill(0);for(const te of Se)te.normV.forEach((Hn,_e)=>Is[_e]+=Hn/Se.length);for(const te of ke)te.normV.forEach((Hn,_e)=>ys[_e]+=Hn/ke.length);Wt[we]=A_(Is,ys),It.labels=Se[0].normT.map(te=>(te*100).toFixed(0));const ss=Rr[we]||"#666";It.datasets.push({label:`お手本:${we}`,data:Is,borderWidth:2.5,pointRadius:0,borderColor:ss,backgroundColor:ss}),It.datasets.push({label:`比較:${we}`,data:ys,borderWidth:2.5,pointRadius:0,borderColor:ss,backgroundColor:ss,borderDash:[6,4]}),Xe.ref={count:Se.length,avg:Du(Se.map(te=>te.dur)),sd:D_(Se.map(te=>te.dur)),min:Math.min(...Se.map(te=>te.dur)),max:Math.max(...Se.map(te=>te.dur)),cadence:60/Du(Se.map(te=>te.dur))},Xe.cmp={count:ke.length,avg:Du(ke.map(te=>te.dur)),sd:D_(ke.map(te=>te.dur)),min:Math.min(...ke.map(te=>te.dur)),max:Math.max(...ke.map(te=>te.dur)),cadence:60/Du(ke.map(te=>te.dur))}}}else{const ge=w.map(we=>we.t),We=C.map(we=>we.t);It.labels=ge.map(we=>we.toFixed(2));for(const we of St){const nn=w.map(ke=>ke[we]??null),Wn=C.map(ke=>ke[we]??null),Wr=ift(We,Wn),Dn=ge.map(ke=>wA(ke,We,Wr));Wt[we]=A_(nn.filter(ke=>ke!=null),Dn.filter(ke=>ke!=null));const Se=Rr[we]||"#666";It.datasets.push({label:`お手本:${we}`,data:nn,borderWidth:2.5,pointRadius:0,borderColor:Se,backgroundColor:Se}),It.datasets.push({label:`比較:${we}`,data:Dn,borderWidth:2.5,pointRadius:0,borderColor:Se,backgroundColor:Se,borderDash:[6,4]})}}if(!It.datasets.length){d(null),m(null),alert("比較に必要なデータが得られませんでした。記録時間を少し長くするか、指標を減らして再試行してください。");return}x(Wt),d({chartData:It}),m(Xe),ve&&mo(Wt,Xe,i,o)},[w,C,i,o,ve]),mo=Ut.useCallback((St=y,It=f,Wt=i,Xe=o)=>{try{co(null),je(!0);const ge=oft(St,It,Wt,Xe);yr(ge)}catch(ge){co(ge?.message||String(ge))}finally{je(!1)}},[y,f,i,o]);return Ot.jsxs("div",{style:{fontFamily:"system-ui, sans-serif",padding:16},children:[Ot.jsx("h1",{children:"SORA LAB フォーム可視化（PoC）"}),Ot.jsxs("div",{style:{display:"flex",gap:12,flexWrap:"wrap",alignItems:"center"},children:[Ot.jsx("button",{onClick:pc,disabled:A,children:"カメラ開始"}),Ot.jsxs("label",{style:{border:"1px solid #ccc",padding:"8px 12px",cursor:"pointer"},children:["動画ファイル読込",Ot.jsx("input",{type:"file",accept:"video/*",onChange:gs,style:{display:"none"}})]}),Ot.jsx("button",{onClick:ho,children:"停止"})]}),!A&&Ot.jsxs("div",{style:{marginTop:10,display:"flex",gap:8,alignItems:"center",flexWrap:"wrap"},children:[Ot.jsx("button",{onClick:fo,children:V?"⏸ 一時停止":"▶ 再生"}),Ot.jsx("button",{onClick:ki,children:"⟲ リプレイ"}),Ot.jsx("span",{children:"速度:"}),[.25,.5,.75,1].map(St=>Ot.jsxs("button",{onClick:()=>po(St),disabled:z===St,children:[St,"x"]},St))]}),Ot.jsx("div",{style:{marginTop:10,display:"flex",gap:8,alignItems:"center",flexWrap:"wrap"},children:Ot.jsxs("label",{children:[Ot.jsx("input",{type:"checkbox",checked:Y,onChange:St=>nt(St.target.checked)}),"省エネモード（発熱を抑える）"]})}),Ot.jsxs("div",{style:{marginTop:10,display:"flex",gap:8,alignItems:"center",flexWrap:"wrap"},children:[Ot.jsx("button",{onClick:Ur,style:{fontWeight:700},children:ut?"■ 記録停止":"● 記録開始"}),Ot.jsx("button",{onClick:Pl,disabled:!_t.current.length,children:"記録クリア"}),Ot.jsx("button",{onClick:xr,disabled:!_t.current.length,children:"CSVダウンロード"}),Ot.jsxs("span",{style:{color:"#666"},children:["サンプル数: ",_t.current.length]})]}),Ot.jsxs("div",{style:{marginTop:10,display:"flex",gap:8,flexWrap:"wrap",alignItems:"center"},children:[Ot.jsx("button",{onClick:()=>pa("ref"),disabled:!_t.current.length,children:"この記録を「お手本」に保存"}),Ot.jsx("button",{onClick:()=>pa("cmp"),disabled:!_t.current.length,children:"この記録を「比較」に保存"}),Ot.jsxs("span",{style:{marginLeft:8,color:"#333"},children:["保存状況：お手本 ",w?"✅":"❌"," / 比較 ",C?"✅":"❌"]})]}),Ot.jsxs("div",{style:{marginTop:12,padding:12,border:"1px solid #eee",borderRadius:8},children:[Ot.jsxs("div",{style:{display:"flex",gap:12,flexWrap:"wrap",alignItems:"center"},children:[[{key:"kneeL",label:"左膝"},{key:"kneeR",label:"右膝"},{key:"hipL",label:"左股"},{key:"hipR",label:"右股"},{key:"trunk",label:"体幹前傾"}].map(St=>Ot.jsxs("label",{children:[Ot.jsx("input",{type:"checkbox",checked:i[St.key]??!0,onChange:It=>a(Wt=>({...Wt,[St.key]:It.target.checked}))}),St.label]},St.key)),Ot.jsxs("label",{style:{marginLeft:8},children:[Ot.jsx("input",{type:"checkbox",checked:o,onChange:St=>u(St.target.checked)}),"動きを1回分に揃えて、平均したフォームで比較",Ot.jsx("span",{style:{fontSize:"0.85em",color:"#666",marginLeft:4},children:"（速さの違いを気にせず、フォームそのものを比べられます）"})]}),Ot.jsx("button",{onClick:mc,disabled:!w||!C,children:"比較（グラフ）"}),Ot.jsxs("label",{style:{marginLeft:8},children:[Ot.jsx("input",{type:"checkbox",checked:ve,onChange:St=>Zs(St.target.checked)}),"比較後にAIコメントを自動生成"]}),Ot.jsx("button",{onClick:()=>mo(),disabled:!h&&!f,children:"AIコメントを生成"}),h&&Ot.jsx("span",{style:{marginLeft:8},children:Object.entries(y).map(([St,It])=>Ot.jsxs("span",{style:{marginRight:10},children:[St,": RMSE ",It?.toFixed(2),"°"]},St))})]}),f?.mode==="cycle"&&Ot.jsx("div",{style:{marginTop:6},children:Ot.jsxs("table",{style:{fontSize:14},children:[Ot.jsx("thead",{children:Ot.jsxs("tr",{children:[Ot.jsx("th",{}),Ot.jsx("th",{children:"サイクル数"}),Ot.jsx("th",{children:"平均(s)"}),Ot.jsx("th",{children:"SD"}),Ot.jsx("th",{children:"最短"}),Ot.jsx("th",{children:"最長"}),Ot.jsx("th",{children:"ケイデンス(回/分)"})]})}),Ot.jsx("tbody",{children:["ref","cmp"].map(St=>{const It=f[St];return It?Ot.jsxs("tr",{children:[Ot.jsx("td",{children:St==="ref"?"お手本":"比較"}),Ot.jsx("td",{children:It.count}),Ot.jsx("td",{children:It.avg.toFixed(2)}),Ot.jsx("td",{children:It.sd.toFixed(2)}),Ot.jsx("td",{children:It.min.toFixed(2)}),Ot.jsx("td",{children:It.max.toFixed(2)}),Ot.jsx("td",{children:It.cadence.toFixed(1)})]},St):null})})]})}),h&&Ot.jsx("div",{style:{height:280,marginTop:8,background:"#fafafa",border:"1px solid #eee",borderRadius:8,padding:8},children:Ot.jsx(N_,{data:h.chartData,options:{responsive:!0,maintainAspectRatio:!1,animation:!1,scales:{x:{title:{display:!0,text:o?"サイクル(%)":"時間(秒)"},grid:{color:"#eee"},ticks:{color:"#333"}},y:{title:{display:!0,text:"角度(°)"},grid:{color:"#eee"},ticks:{color:"#333"}}},plugins:{legend:{position:"top",labels:{usePointStyle:!0,boxWidth:10}}}}})})]}),Ot.jsx("video",{ref:n,playsInline:!0,muted:!0,style:{display:"none"}}),Ot.jsx("video",{ref:t,controls:!0,playsInline:!0,muted:!0,style:{display:"none"}}),Ot.jsx("div",{style:{marginTop:12},children:Ot.jsx("canvas",{ref:e,style:{width:"100%",maxWidth:960,background:"#eee",borderRadius:8}})}),Ot.jsx("div",{style:{height:260,marginTop:12,background:"#fafafa",border:"1px solid #eee",borderRadius:8,padding:8},children:Ot.jsx(N_,{data:br,options:An})}),(fa||on||Vr)&&Ot.jsxs("div",{style:{marginTop:12,padding:12,border:"1px solid #eee",borderRadius:8,background:"#fffef8"},children:[Ot.jsx("div",{style:{fontWeight:700,marginBottom:6},children:"コーチからのひとこと"}),fa&&Ot.jsx("div",{children:"考え中です… ⏳"}),on&&Ot.jsxs("div",{style:{color:"#b00020"},children:["エラー: ",on]}),Vr&&Vr.split(`
`).map((St,It)=>Ot.jsx("p",{style:{margin:"6px 0"},children:St},It))]}),Ot.jsx("p",{style:{marginTop:12,color:"#555"},children:"コツ：横から全身が入るように撮影（30fps以上）。明るい場所で。"})]})}function wA(n,t,e){if(!t.length||!e.length)return null;if(n<=t[0])return e[0];if(n>=t[t.length-1])return e[e.length-1];let s=1;for(;s<t.length&&t[s]<n;)s++;const r=t[s-1],i=t[s],a=e[s-1],o=e[s];return a+(o-a)*(n-r)/(i-r)}function ift(n,t){const e=t.slice();let s=0;for(;s<e.length&&e[s]==null;)s++;if(s>0&&s<e.length)for(let i=0;i<s;i++)e[i]=e[s];let r=e.length-1;for(;r>=0&&e[r]==null;)r--;if(r>=0&&r<e.length-1)for(let i=r+1;i<e.length;i++)e[i]=e[r];for(let i=0;i<e.length;i++)if(e[i]==null){let a=i;for(;a<e.length&&e[a]==null;)a++;const o=e[i-1],u=e[a],h=n[i-1],d=n[a];for(let f=i;f<a;f++)e[f]=o+(u-o)*(n[f]-h)/(d-h);i=a}return e}function R_(n,t,{prominence:e=8,minGapSec:s=.35}={}){const r=[];for(let o=1;o<t.length-1;o++)t[o]<=t[o-1]&&t[o]<=t[o+1]&&r.push(o);const i=[];let a=-1e9;for(const o of r){const u=Math.max(0,o-10),h=Math.min(t.length-1,o+10),d=Math.max(...t.slice(u,o)),f=Math.max(...t.slice(o+1,h+1));Math.min(d-t[o],f-t[o])>=e&&n[o]-a>=s&&(i.push(o),a=n[o])}return i}function I_(n,t,e,s=100){const r=[];for(let i=0;i<e.length-1;i++){const a=n[e[i]],o=n[e[i+1]],u=Array.from({length:s},(d,f)=>f/(s-1)),h=u.map(d=>{const f=a+d*(o-a);return wA(f,n,t)});r.push({normT:u,normV:h,dur:o-a})}return r}function A_(n,t){const e=Math.min(n.length,t.length);if(e===0)return null;let s=0;for(let r=0;r<e;r++){const i=n[r]-t[r];s+=i*i}return Math.sqrt(s/e)}function Du(n){return n.reduce((t,e)=>t+e,0)/n.length}function D_(n){const t=Du(n);return Math.sqrt(Du(n.map(e=>(e-t)**2)))}function xp(n){return n==null||isNaN(n)?"-":`${n.toFixed(1)}°`}function aft(n){return n==null?"info":n<10?"good":n<20?"ok":n<30?"warn":"alert"}function Kr(n,t){return`${n} ${t}`}function oft(n,t,e,s){const r=[];r.push("いつもおつかれさまです。今日の計測をもとに、やさしく振り返ってみましょう。");const i=["kneeL","kneeR","hipL","hipR","trunk"].filter(o=>e[o]),a={kneeL:"左膝",kneeR:"右膝",hipL:"左股関節",hipR:"右股関節",trunk:"体幹前傾"};for(const o of i){const u=n?.[o];if(u==null)continue;const h=aft(u);h==="good"&&r.push(Kr("✅",`${a[o]}はお手本に近い動き（RMSE ${xp(u)}）。この調子！`)),h==="ok"&&r.push(Kr("☑️",`${a[o]}はまずまず一致（RMSE ${xp(u)}）。リズムを揃えるとさらに良くなりそう。`)),h==="warn"&&r.push(Kr("⚠️",`${a[o]}の差がやや大きめ（RMSE ${xp(u)}）。可動域のピーク付近で左右差が出ている可能性。`)),h==="alert"&&r.push(Kr("❗",`${a[o]}の差が大きい傾向（RMSE ${xp(u)}）。フォームの要点を一つに絞って練習しましょう。`))}if(t?.mode==="cycle"&&t.ref&&t.cmp){const o=t.ref.cadence,u=t.cmp.cadence,h=o&&u?Math.abs(o-u):null;h!=null&&(h<2?r.push(Kr("🎵",`ケイデンスはお手本に近いです（${u.toFixed(1)} 回/分）。リズムは良好！`)):r.push(Kr("🫧",`ケイデンスに差があります（お手本 ${o.toFixed(1)} / 比較 ${u.toFixed(1)} 回/分）。テンポ合わせを意識しましょう。`))),r.push(Kr("⏱️",`1サイクルの平均：お手本 ${t.ref.avg.toFixed(2)}s / 比較 ${t.cmp.avg.toFixed(2)}s`))}else s===!1&&r.push(Kr("ℹ️","今回は時間比較です。必要に応じて『動きを1回分に揃えて、平均したフォームで比較』をONにすると、リズム差を除いた形で波形比較ができます。"));return r.push("次回のおすすめ："),(i.includes("kneeL")||i.includes("kneeR"))&&r.push(Kr("・","膝角度は“曲げピークの深さとタイミング”を合わせる意識で。")),i.includes("trunk")&&r.push(Kr("・","体幹は“胸の向き”を固定し、股関節で前傾を作ると安定します。")),r.push(Kr("・","1～2項目に絞って撮影し、5～10サイクルほど計測してみましょう。")),r.push("無理せず、少しずつ。今日もよくできました！"),r.join(`
`)}JD.createRoot(document.getElementById("root")).render(Ot.jsx(Ut.StrictMode,{children:Ot.jsx(rft,{})}));export{$x as G,Lm as M,dpt as a,ctt as f,fpt as g,MQ as s,ppt as w};
